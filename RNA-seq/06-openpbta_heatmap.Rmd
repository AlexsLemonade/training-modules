---
title: "OpenPBTA: Create a heatmap"
output:   
  html_notebook: 
    toc: true
    toc_float: true
author: CCDL for ALSF
date: 2020
---

In this notebook, we cluster RNA-seq data from the Open Pediatric Brain Tumor Atlas (OpenPBTA) project and create a heatmap.
OpenPBTA is a collaborative project organized by the CCDL and the Center for Data-Driven Discovery in Biomedicine (D3b) at the Children's Hospital of Philadelphia conducted openly on GitHub.

You can read more about the project [here](https://github.com/alexslemonade/openpbta-analysis/#openpbta-analysis).

We've downloaded some of the publicly available expression data from the project and selected a subset with the the most common disease types for analysis here.

We'll use a package called [`ComplexHeatmap`](https://www.bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html) to make our heatmap.
This package also will perform clustering as part of the heatmap.
It is highly flexible and opinionated - the data structures we pass `ComplexHeatmap` functions often need to be _just right_.
See the [`ComplexHeatmap` Complete Reference](https://jokergoo.github.io/ComplexHeatmap-reference/book/) for more information.

## Set up

### Libraries

```{r load_libraries}
# We will manipulate RNASeq data with DESeq2 at the start
library(DESeq2)
# Then we'll be doing a bit of data wrangling with the Tidyverse
library(tidyverse)
# ComplexHeatmap is the package we'll use for making a heatmap
# It will do the hierarchical clustering for us as well
library(ComplexHeatmap)
```

### Directories and files

We have stored the data we'll use in this notebook in `data/open-pbta`. 

```{r directories, live = TRUE}
data_dir <- file.path("data", "open-pbta")

# We'll store the heatmap in plots/open-pbta - create directory if it doesn't exist yet
plots_dir <- file.path("plots", "open-pbta")
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir, recursive = TRUE)
}
```

#### Input files

```{r input_files}
# The metadata describing the samples
histologies_file <- file.path(data_dir, "pbta-histologies-subset.tsv")

# The RNAseq counts table
rnaseq_file = file.path(data_dir, "pbta-rsem-expected_count-subset.rds")
```

#### Output files

```{r png_output, live = TRUE}
heatmap_file <- file.path(plots_dir, 
                          "common_histologies_high_variance_heatmap.png")
```

## Read in and prepare data

### Metadata 

Let's read in the metadata file file and take a look at the data.

```{r read_rds, live = TRUE}
histologies_df <- read_tsv(histologies_file)  
```

Use the chunk below to explore the metadata data frame.

```{r explore_histologies_df, live = TRUE, eval = FALSE}
View(histologies_df)
```

We'll use the disease labels in a column called `short_histology` when we label the heatmap.
Let's count how many samples are assigned each `short_histology` label using the Tidyverse.

```{r count_histologies}
histology_count_df <- histologies_df %>%
  # Count how many samples are in each short_histology and name the column 
  # with that number n
  count(short_histology) %>%
  # Sort from largest number of samples to smallest number of samples in a 
  # histology
  arrange(desc(n))

histology_count_df
```

### RNA-seq data

Read in the expression count matrix (stored as a data frame).

```{r read_in_rnaseq, live = TRUE}
# Read in and examine the RNA-seq data
rnaseq_exp <- read_rds(rnaseq_file)
```

### Convert and round

The count data we have is mostly integers, but because of the estimation procedure that RSEM uses, some is not. 
`DESeq2`, which we will be using below expects all integers, so we will round all of the count data. 
This is easiest if we first convert from a data frame to a matrix.

```{r convert_round, live = TRUE}
rnaseq_mat <- rnaseq_exp %>%
  # move gene_id to the rownames
  tibble::column_to_rownames("gene_id") %>%
  # convert to a matrix and round
  as.matrix() %>%
  round()
```

### Variance Stabilizing Transformation

Raw count data is not usually suitable for the algorithms we use for clustering and heatmap display. 
To improve this, we will transform the count data to create an expression measure that is better suited for these analyses. 
The core transformation will map the expression to a log2 scale, while accounting for some of the expected variation among samples and genes.

Since different samples are usually sequenced to different depths, we want to transform our RNA-seq count data to make different samples more directly comparable. 
We also want to deal with the fact that genes with low counts are also likely to have higher variance (on the log2 scale), as that could bias our clustering.
To handle both of these considerations, we can calculate a Variance Stabilizing Transformation of the count data, and work with that transformed data for our analysis.

The `DESeq2` package has functions for doing these calculations, so we will convert our count matrix to a `DESeq2` dataset and perform the calculations there.

Since we are starting from a matrix, not a `SummarizedExperiment` as we did previously, we will need to provide the sample information ourselves.
Just to be sure nothing is out of order, we will check that the identifiers for the sample information stored in `histologies_df` matches the columns of our matrix.

```{r check-order}
all.equal(histologies_df$Kids_First_Biospecimen_ID,
          colnames(rnaseq_mat))
```

Now we can make our matrix into a `DESeq2` dataset, adding on the sample information from `histologies_df`. 
Unlike when we were performing differential expression analysis, we won't provide an experimental design at this stage.

```{r make-DESEq}
ddset <- DESeqDataSetFromMatrix(rnaseq_mat,
                                colData = histologies_df,
                                design = ~ 1) # don't store an experimental design
```

We will again remove low count genes, as they are not likely to be informative. 

```{r trim}
genes_to_keep <- rowSums(counts(ddset)) >= 10
ddset <- ddset[genes_to_keep, ]
```

Now we can apply the variance stabilizing transformation, saving the results in a new object.

```{r}
# apply variance stabilizing transformation
vst_data <- vst(ddset, blind = TRUE)
```

This object stores information about the transformation that was applied, but for now, we will only need the matrix of transformed data, which we can extract with `assay()`.

```{r select-columns}
# extract transformed data
expr_mat <- assay(vst_data)
```

What are the dimensions of this transformed RNA-seq data matrix?

```{r rnaseq_dim, live = TRUE}
dim(expr_mat)
```

Almost 50k genes would be hard to visualize on a single heatmap!
If we are making a heatmap to get an idea of the structure in our data, it can be helpful to subset to high variance genes.
This is because the genes that *don't* vary are not likely to contribute much to the overall patterns we are interested in.

First, we'll calculate the variance for each gene using `rowVars()` from the `matrixStats` package and then take the genes in the top 10%.

```{r high_var_genes}
# Calculate variance from the expression data 
gene_variance <- matrixStats::rowVars(expr_mat)
# Find the value that we'll use as a threshold to filter the top 10%
variance_threshold <- quantile(gene_variance, 0.9)
# Row indices of high variance genes
high_variance_index <- which(gene_variance > variance_threshold)
# What does a row index look like?
head(high_variance_index)
```

```{r high_var_mat, live = TRUE}
# Get a matrix that is subset to just the high variance genes
high_var_mat <- expr_mat[high_variance_index, ]
```

## Heatmap

### Annotation

First, we'll set up the metadata that we want to use to label samples in the heatmap.
In `ComplexHeatmap` terminology, this is called annotation, or `HeatmapAnnotation`, specifically.

```{r sample_annotation_df}
sample_annotation_df <- histologies_df %>%
  # Select only the columns that we'll use
  select(Kids_First_Biospecimen_ID,
         short_histology,
         composition,
         tumor_descriptor)

# Let's examine these columns
sample_annotation_df
```
`ComplexHeatmap` is going to want the data frame we provide to have the sample identifiers as row names, so let's set that up. 

```{r annotation_as_df, live = TRUE}
sample_annotation_df <- sample_annotation_df %>%
  tibble::column_to_rownames("Kids_First_Biospecimen_ID")
```

To specify the colors in our annotation bar, we need to create a list of named vectors.
The names of the list need to *exactly* match the column names in `sample_annotation_df` and the names in each vector need to *exactly* match the values in those columns.

```{r color_palettes}
# The Okabe Ito palette is recommended for those with color vision deficiencies  
histology_colors <- palette.colors(palette = "Okabe-Ito")[2:5]
# `palette.colors()` returns a named vector, which can cause trouble
histology_colors <- unname(histology_colors)

# annotation color list for ComplexHeatMap
sample_annotation_colors <- list(
  short_histology = c(
    "LGAT" = histology_colors[[1]],
    "Ependymoma" = histology_colors[[2]],
    "HGAT" = histology_colors[[3]],
    "Medulloblastoma" = histology_colors[[4]]
  ),
  composition = c(
    "Solid Tissue" = "#A0A0A0",  # light grey
    "Derived Cell Line" = "#000000"  # black
  ),
  tumor_descriptor = c(
    "Initial CNS Tumor" = "#3333FF",
    "Progressive" = "#FFFF99",
    "Recurrence" = "#CCCCFF",
    "Second Malignancy" = "#000033",
    "Unavailable" = "#FFFFFF"  # white for missing data
  )
)
```

We need to create a special type of object with `HeatmapAnnotation` using the annotation data frame and the list of color vectors.

```{r create_annotation, live = TRUE}
column_annotation <- HeatmapAnnotation(
  df = sample_annotation_df,
  col = sample_annotation_colors
)
```

### Values for display

We will z-score the expression values for display.
This is sometimes called a standardized score.
It's calculated for each value in a row (gene) by subtracting the gene's mean and dividing by the gene's standard deviation.

```{r}
zscores_mat <- 
  (high_var_mat - rowMeans(high_var_mat)) / matrixStats::rowSds(high_var_mat)
```


Let's look at the mean and standard deviation of values for a randomly selected gene prior to standardization.

```{r random_row_mean}
mean(high_var_mat[25, ])
```

```{r random_row_sd}
sd(high_var_mat[25, ])
```

And now those values after standardization.

```{r random_z_mean, live = TRUE}
mean(zscores_mat[25, ])
```

This value isn't exactly zero but it's very close!

```{r random_z_sd, live = TRUE}
sd(zscores_mat[25, ])
```

The standard deviation is now 1.
That means all the variance values will be equal to one, too.

```{r summary_row_variance}
summary(matrixStats::rowVars(zscores_mat))
```

If you're filtering to high variance values, it's important to do that _prior_ to standardizing.

### Heatmap itself!

Okay, now we're ready to make a heatmap complete with annotation bars.

```{r make_heatmap}
Heatmap(zscores_mat,
        # The distance metric used for clustering the rows
        # This is different from the default (Euclidean)
        clustering_distance_rows = "pearson",
        # Linkage method for row clustering
        # This is different from the default (complete)
        clustering_method_rows = "average",
        # Distance metric for columns
        clustering_distance_columns = "pearson",
        # Linkage for columns
        clustering_method_columns = "average",
        show_row_names = FALSE,
        show_column_names = FALSE,
        # Add annotation bars to the top of the 
        top_annotation = column_annotation,
        # This will be used as the label for the color bar
        # of the cells of the heatmap itself
        name = "z-score")
```

We have to create the heatmap _twice_ -- once for display in the notebook and once to save to a PNG file.

```{r save_heatmap_png, live = TRUE}
# Open PNG plot device
png(filename = heatmap_file, 
    width = 11, 
    height = 7, 
    units = "in", 
    res = 300)
# Heatmap, again!
Heatmap(zscores_mat,
        clustering_distance_rows = "pearson",
        clustering_method_rows = "average",
        clustering_distance_columns = "pearson",
        clustering_method_columns = "average",
        show_row_names = FALSE,
        show_column_names = FALSE,
        top_annotation = column_annotation,
        name = "z-score",
        use_raster = FALSE) # higher resolution for output (be careful with PDF output!)
# Shut down current graphics device
dev.off()
```

### Notes on clustering

You probably noticed that we a couple options in there when we made the heatmap about "clustering".
These options refer to the hierarchical clustering method that is used to determine the order of rows and columns in the heatmap, bringing samples and genes that show similar patterns together.

We will explore 


## Spotlight on medulloblastoma

The heatmap we made with all of the histologies under consideration suggested that there's some structure _within_ histologies.
Let's take a closer look at the medulloblastoma samples.

```{r mb_sample_ids, live = TRUE}
medulloblastoma_samples <- histologies_df %>%
  filter(short_histology == "Medulloblastoma") %>%
  pull(Kids_First_Biospecimen_ID)
```

Use all genes to create a matrix that only contains medulloblastoma samples.

```{r mb_mat, live = TRUE}
medulloblastoma_mat <- expr_mat[, medulloblastoma_samples]
```

We'll use Pearson correlation for our distance metric here again, but let's break down what goes into hierarchical clustering a bit here.

```{r calculate_cor}
# cor() will take the correlation between columns - we're interested in the 
# relationship between medulloblastoma samples, so we don't need to transpose
# the matrix before using cor()
mb_sample_correlation <- cor(medulloblastoma_mat,
                             use = "pairwise.complete.obs",
                             method = "pearson")
```

Hierarchical clustering is performed on dissimilarities, so we'll subtract the correlation values from 1 -- now we have distance information.
To use `hclust()` -- the built-in method for hierarchical clustering in R -- we need a dissimilarity structure.
`as.dist()` returns a special object of class `dist`, a distance matrix used by `hclust()`.

```{r cor_as_dist, live = TRUE}
mb_sample_dist <- as.dist(1 - mb_sample_correlation)
```

Now we're ready to perform [hierarchical clustering](https://en.wikipedia.org/wiki/Hierarchical_clustering) with `hclust()`.
This is an _agglomerative_ method of clustering - each sample starts in its own cluster and then at each step of the algorithm the two most similar clusters are joined until there's only a single cluster left.

```{r mb_hclust, live = TRUE}
mb_sample_hclust <- hclust(mb_sample_dist, 
                           method = "average")
```

Here, `method = "average"` refers to the agglomeration or linkage method used during clustering. 
The method we're using is also known as [UPGMA (unweighted pair group method with arithmetic mean)](https://en.wikipedia.org/wiki/UPGMA) and is how we specify what formula to use for calculating inter-cluster distances during hierarchical clustering.
The distance between two clusters is the average distance between all pairs of points in the two clusters, where each pair is comprised of one point from each of the two clusters.

To look at the dendrogram produced by `hclust()`, we can use built-in graphics by calling `plot()`.

```{r mb_dendrogram}
plot(mb_sample_hclust, 
     # Put the labels at the same height
     hang = -1, 
     # Control the size of the text labels
     cex = 0.5) 
```

How many groups of medulloblastoma samples do you think there are?

## Session Info

```{r session_info}
sessionInfo()
```
