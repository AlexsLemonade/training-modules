---
title: "Exercise: Pathway analysis of medulloblastoma PDX"
output: 
  html_notebook:
    toc: true
    toc_float: true
author: CCDL for ALSF
date: 2020
---

In this exercise notebook, we will perform over-representation analysis (ORA), Gene Set Enrichment Analysis (GSEA), and Gene Set Variation Analysis (GSVA) using a single dataset so we can compare the results.
We've set up the exercise to run through the minimal steps for ORA, GSEA, and GSVA, but we strongly encourage you to explore!
You can insert new chunks (`Cmd + Option + I` on Mac, `Ctrl + Alt + I` on Windows).

**Because we're performing 3 separate analyses, this notebook is pretty long!**
**Don't worry if you don't complete it in the allotted time; it is designed so you can revisit it after the course.**

## Introduction to the dataset

We will use an RNA-seq experiment comprised of medulloblastoma orthotopic patient-derived xenograft (PDX) models from [Huang *et al.* (2018)](https://doi.org/10.1126/scitranslmed.aat0150) to practice pathway analysis.

The experiment, [`SRP150101`](https://www.refine.bio/experiments/SRP150101/transcriptome-analysis-of-group-3-and-4-medulloblastoma-orthotopic-xenograft-mice-with-digoxin-treatment), was processed by [refine.bio](https://www.refine.bio/).

Here's an excerpt of the experiment description:

> RNA-seq data of Group 3 and 4 medulloblastoma with digoxin treatment.

Group 3 and Group 4 are subgroups of medulloblastoma. 
You can read more about these subgroups of medulloblastoma in [Menyh√°rt *et al.* (2019)](https://doi.org/10.1186/s13045-019-0712-y)

[Digoxin](https://en.wikipedia.org/wiki/Digoxin) is a treatment for various cardiovascular diseases.

*You may remember this dataset from the bulk RNA-seq exercise for exploratory data analysis!*

## How we processed and analyzed the data

In this section, we will include information about how we generated the data and result files we provide to you. 
We'll also include some code for your reference, but it is not intended to be run.

Starting with the output of `tximport::tximport()`, we created the `DESeqDataSet` with:

```r
ddset <- DESeqDataSetFromTximport(txi = txi,
                                  colData = metadata,
                                  design = ~ Group + treatment)
```

The metadata we used is available at `data/pdx-medulloblastoma/pdx_medulloblastoma_metadata.tsv`.

The VST transformed data, available at `data/pdx-medulloblastoma/pdx_medulloblastoma_vst.tsv`, was generated with:

```r
# Transformation
vst_data <- vst(ddset)

# Write tabular format to file
data.frame(assay(vst_data)) %>%
  tibble::rownames_to_column("gene_id") %>%
  readr::write_tsv(<FILENAME>)
```

To get the differential gene expression (DGE) results available at `results/gene-metrics/pdx_medulloblastoma_treatment_dge.tsv`, we did the following:

```r
# Differential gene expression
ddset <- DESeq(ddset)

# Get results table and perform shrinkage of log2 fold change (LFC) estimates.
# In general, shrinkage is improving an estimator by shrinking it towards some
# value. In this case, the LFC values undergo shrinkage towards zero when we
# don't have enough information about a gene.
# See https://hbctraining.github.io/DGE_workshop_salmon/lessons/05_DGE_DESeq2_analysis2.html
# for more background information.
results_table_digoxin <- results(ddset, alpha = 0.05)
results_lfc <- lfcShrink(ddset, 
                         coef = "treatment_digoxin_vs_none",
                         res = results_table_digoxin)

# Write results table to file
results_lfc %>%
  data.frame() %>%
  tibble::rownames_to_column("Gene") %>%
  # Filter out genes without LFC information (e.g., 0 counts)
  dplyr::filter(!is.na(log2FoldChange)) %>%
  readr::write_tsv(<FILENAME>)
```

**Some things to note:**

* For the treatment comparison, `none` was the reference. 
  Genes with higher expression in `digoxin` will have positive fold change values.
* The design formula when we set up the `DESeqDataSet` was `~ Group + treatment`.
  The differential gene expression results for `treatment` in our example should be the differences between digoxin vs. none, controlling for differences due to molecular subtype (`Group`).

## Set up

### Libraries

Load in `magrittr`, `clusterProfiler`, `msigdbr`, `GSVA`, `org.Hs.eg.db`, and `pheatmap`.

```{r libraries, solution = TRUE}

```

### Directories and files 

#### Directories

We will need the DGE results, the VST transformed RNA-seq data, and the metadata for all the analyses included in this notebook.

```{r input_directories}
# RNA-seq data, metadata
input_data_dir <- file.path("data", "pdx-medulloblastoma")
# Results directory
results_dir <- "results"
# Subdirectory of results that specifically holds the DGE results
dge_dir <- file.path("results", "gene-metrics")
```

#### Input files

* Metadata file: `data/pdx-medulloblastoma/pdx_medulloblastoma_metadata.tsv`
* Transformed RNA-seq data file: `data/pdx-medulloblastoma/pdx_medulloblastoma_vst.tsv`
* DGE results file: `results/gene-metrics/pdx_medulloblastoma_treatment_dge.tsv`

Use the next chunk to assign all of these file paths to variables in your environment.

```{r input_files, solution = TRUE}
# Metadata file

# Transformed RNA-seq file

# DGE results file

```

#### Output files

Let's look at the current contents of our **results** directory.

```{r peek_results}
# dir() produces a character vector of the files and directories in whatever
# directory we give it as an argument
dir(results_dir)
```

Each of the analysis types (ORA, GSEA, and GSVA) are stored in their own folder. 
Use the next chunk to set up output file names for each of the analyses we'll perform (ORA, GSEA, and GSVA).

```{r output_files, solution = TRUE}
# ORA results file

# GSEA results file

# GSVA results file

```

## Gene Sets

We can retrieve _all_ of the gene sets available for human in the `msigdbr` package with the command in the following chunk.

```{r msigdbr}
hs_msigdb_df <- msigdbr(species = "Homo sapiens")
head(hs_msigdb_df)
```

Take a look at the collections here: https://www.gsea-msigdb.org/gsea/msigdb/collections.jsp
The `gs_cat` and `gs_subcat` columns of `hs_msigdb_df` contain the collection information.
Once you've decided on what collection you want to use for your pathway analysis, use the next chunk to filter `hs_msigdb_df` and assign to a new data frame called `gene_set_df`. 
(Hint: We haven't loaded in the `dplyr` package.)

_Just a heads up, the solved version will use Hallmark gene sets!_

```{r filter_gene_sets, solution = TRUE}
# Save the new filtered data frame as gene_set_df

```

## Read in data and gene identifier conversion

The first two approaches we'll use, ORA and GSEA, will use the DGE results.
Use the next chunk to read in the DGE results and assign it to `dge_results_df`.

```{r read_in_dge, solution = TRUE}

```

> What gene identifiers are used in the DGE results?
  What gene identifiers are available in `gene_set_df`? 
  
To answer the first question, we can look at the `Gene` column that contains the gene identifiers.
The column name `Gene` doesn't tell us what kind of identifier we have!
When your instructors encounter an unfamiliar identifier, they often copy and paste one into Dr. Google.
All joking aside, for human datasets, you can search [GeneCards](https://www.genecards.org/).

For the first item in the list we searched the identifier in the `Gene` column: https://www.genecards.org/cgi-bin/carddisp.pl?gene=TSPAN6&keywords=ENSG00000000003
Notice under `External Ids for TSPAN6 Gene` that it indicates that this is an Ensembl identifier.
We can tell it's a _gene_ identifier because the prefix ends in `G`, rather than `T` which would indicate a transcript.

We'll need to convert the gene identifiers we have in the DGE results to something we can use for pathway analysis.

Let's remind ourselves what different gene identifiers are called in the `org.Hs.eg.db` package.

```{r keytypes}
keytypes(org.Hs.eg.db)
```

Use the next chunk to convert the identifiers in `Gene` column in the data frame of DGE results to identifiers you can use with `gene_set_df`.
Store the identifiers you convert _to_ in a new column that has a name that reflects what type of identifiers they are.
(Hint: You probably want to remove `NA` values.)

```{r identifier_conversion, solution = TRUE}
# Map from the identifiers in the DGE results data frame to one of the types of
# identifiers in gene_set_df and save the new identifier

```

## Pathway analysis

### ORA

Now that we have our DGE results and have converted the gene identifiers, we're ready to perform ORA.
ORA requires a list of genes of interest, so we'll need to filter to some set of genes we'll use in our analysis.

Use the next chunk to get a list of genes you'll use for ORA.
Let's focus on genes that increase with treatment with digoxin.
Given what we know about how the results were obtained (see: [How we processed and analyzed the data](#how-we-processed-and-analyzed-the-data)), consider:

* Which columns of the DGE results do we need to use to filter?
* What thresholds should we use?

```{r genes_of_interest, solution = TRUE}

# Only keep unique genes

```

In the next chunk, we generate the background set for our ORA. 
We are testing a list of _differentially expressed genes_, but not every gene in our list will be able to be **detected** by DGE.
For example, DESeq2 includes a step called independent filtering, where genes with low mean normalized counts will have adjusted p-values that are set to `NA` ([docs](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#independent-filtering-of-results)).
So to get our background set, we'll filter to _complete cases_.
These are genes (rows) that have no `NA` values associated with them.

```{r background_set}
detected_genes <- unique(
  dge_results_df %>%
    # Filter out rows that have any NA values
    dplyr::filter(complete.cases(.)) %>%
    # Return a vector of Entrez IDs
    dplyr::pull(entrez_id)
)
```

Use the next chunk for the ORA step itself.

```{r run_ora, solution = TRUE}

```

`enricher()` returns a specialized object that has _slots_.
Slots can be accessed with `@` the same way you can get a column of a data frame with `$` and the column name.
`@result` will return the statistics you are likely most interested in in a tabular format.

```{r explore_ora, solution = TRUE, eval = FALSE}
# Use this chunk to explore the ORA results

```

Write the ORA results to file.

```{r write_ora, solution = TRUE}

```

### GSEA

Now let's perform GSEA and see how the results compare to our ORA results.

First, get the ranked list for `GSEA()`.

```{r lfc_vector, solution = TRUE}

```

Perform GSEA in the next chunk.

```{r run_gsea, solution = TRUE}

```

Take a look at the GSEA results.

```{r view_gsea, solution = TRUE, eval = FALSE}

```

> How do these results compare with the ORA results?

Make a plot for at least one pathway!

```{r gseaplot, solution = TRUE}

```

Write GSEA results to file.

```{r write_gsea, solution = TRUE}

```

### GSVA

Instead of taking a gene list either filtered to genes that meet some criteria (ORA) or a ranked list of all genes (GSEA), GSVA requires the RNA-seq data.

#### Read in and prepare the RNA-seq data

Read in the TSV file that contains the transformed RNA-seq data.

```{r read_in_rnaseq}
rnaseq_df <- readr::read_tsv(rnaseq_file)
```

For GSVA, we'll use Entrez IDs.

```{r convert_rnaseq}
rnaseq_df <- rnaseq_df %>%
  dplyr::mutate(entrez_id = mapIds(org.Hs.eg.db, 
                                   keys = rnaseq_df$gene_id, 
                                   column = "ENTREZID", 
                                   keytype = "ENSEMBL", 
                                   multiVals = "first")
  ) %>%
  # Remove genes that do not have Entrez IDs
  dplyr::filter(!is.na(entrez_id)) %>%
  # This step puts the Entrez IDs as the first column and selects all the 
  # columns that contain expression values
  dplyr::select(entrez_id, tidyselect::starts_with("SRR"))
```

GSVA takes a matrix where the gene identifiers are rownames _and_ we can't have duplicated rownames.
First, we need to check if there are duplicate Entrez IDs.

```{r check_duplicated_entrez}
# duplicated() returns TRUE if something is a duplicate value of something 
# earlier in a vector and sum() will count how many times TRUE appears
sum(duplicated(rnaseq_df$entrez_id))
```

Since we have duplicate identifiers, we need to collapse them somehow.
In this case, for a given Entrez ID we'll pick the row that has the maximum average expression across the cohort.

*Note: When collapsing duplicates in any dataset, it's good practice to check how many times an identifier occurs and the correlation between duplicates.*
*For brevity, we're skipping that step since a low proportion of identifiers are duplicated.*

```{r collapse_rnaseq}
# Mean transformed value across the entire cohort
rnaseq_df$mean_value <- rowMeans(rnaseq_df[, -1])

# Because the next step includes sampling, we need to set a seed for 
# reproducibility
set.seed(2020)

# Now the collapse step
collapsed_rnaseq_df <- rnaseq_df %>%
  # For each set of rows that correspond to the same Entrez ID
  dplyr::group_by(entrez_id) %>%
  # Select the single row with the highest value in the mean_value column
  dplyr::top_n(1, mean_value) %>%
  # In the case of ties, where the mean values are the same, randomly pick one
  # row
  dplyr::sample_n(1) %>%
  # Drop the column that contains the mean
  dplyr::select(-mean_value)

# To save some space, remove the data frame that has duplicate identifiers
rm(rnaseq_df)
```

Use the next chunk make a matrix where the gene identifiers are rownames.

```{r rnaseq_matrix, solution = TRUE}

```

#### Perform GSVA

GSVA requires a list of gene sets, rather than a tidy data frame like the functions we used for ORA and GSEA.
We can use `gene_set_df` to get a list with `split()`, which divides data into groups determined by the second argument.

```{r split_gene_sets}
gene_set_list <- split(gene_set_df$entrez_gene, gene_set_df$gs_name)
```

Now that we've done all that prep, use this next chunk to perform GSVA!

```{r gsva, solution = TRUE}

```

#### Make a heatmap

Let's make a heatmap of the GSVA scores.
First, read in the metadata.

```{r read_in_metadata, solution = TRUE}

```

Now make a data frame that has the `Run` (sample identifiers) as rownames and only contains the `Group` and `treatment` columns from the metadata.

```{r annotation_df, solution = TRUE}

```

We'll use `pheatmap::pheatmap()` to plot the GSVA results, using the annotation data frame we just made to indicate the group and treatment of each sample.
Take a look at the possible arguments to `pheatmap::pheatmap()`.
We recommend starting with the `scale`, `annotation_col` and various `fontsize` arguments to start.

```{r heatmap, solution = TRUE}

```

Let's take a look at the PCA plot that was included in the bulk RNA-seq module.

![](https://github.com/AlexsLemonade/training-modules/raw/6bdf0b1493bcfb63a63e8509e2427d7d478a6f29/RNA-seq/diagrams/medulloblastoma_PCA_plot_treatment_group.png)

> Are the GSVA results consistent with what you would expect given the PCA plot?
  Revisit the documentation for DESeq2::plotPCA() if you need to!

Write the GSVA results to file.

```{r write_gsva, solution = TRUE}

```

## Session Info

```{r}
sessionInfo()
```
