---
title: "Setup: Introduction Module"
author: Stephanie Spielman for the Data Lab
date: "`r Sys.Date()`"
output: 
  html_notebook:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
set.seed(2022)

library(SingleCellExperiment)
library(magrittr)
library(SingleR) # annotation
library(bluster) # clustering to give the people their UMAP colors
```

To get the raw data:
```markdown
NAME=10k_PBMCs_TotalSeq_B_3p_raw_feature_bc_matrix.tar.gz
wget https://cf.10xgenomics.com/samples/cell-exp/6.0.0/10k_PBMCs_TotalSeq_B_3p/$NAME
tar -xf $NAME
# This gets unpacked into `raw_feature_bc_matrix`


# For posterity, first attempt was with MALT, but it had wildly low ADT counts
#NAME=malt_10k_protein_v3_raw_feature_bc_matrix.tar.gz
#wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/malt_10k_protein_v3/$NAME
```

## Filtering and normalization

```{r}

pbmc_10x_dir <- "raw_feature_bc_matrix"
# for now..
mito_file <- "https://raw.githubusercontent.com/AlexsLemonade/scpca-downstream-analyses/main/reference-files/Homo_sapiens.GRCh38.104.mitogenes.txt"



pbmc_sce_raw <- DropletUtils::read10xCounts(pbmc_10x_dir)
mito_genes <- readr::read_tsv(mito_file, 
                              col_names=FALSE) %>%
  # only keep relevant mitochondrial genes
  dplyr::filter(X1 %in% rownames(pbmc_sce_raw)) %>%
  dplyr::pull(X1)
```


### Initial Mitochondria QC:

Note that the `addPer<X>QC()` functions should be run before we split out the ADTs into their own altExp so that the appropriate QC columns actually get ported into the altExp.

```{r}
pbmc_sce_percellqc <- scater::addPerCellQC(
  pbmc_sce_raw, 
  subsets = list(mito = mito_genes))

# we'll need this later, so pop it in now
pbmc_sce_percellqc <- scater::addPerFeatureQC(pbmc_sce_percellqc)


# Filter out 0s, and see before/after dims:
dim(pbmc_sce_percellqc) 
pbmc_sce_percellqc <- pbmc_sce_percellqc[, pbmc_sce_percellqc$total > 0]
dim(pbmc_sce_percellqc) 
```


Before proceeding with further filtering, we'll want to re-arrange the SCE object to handle the RNA and ADT separately.
Currently, the ADTs and genes are both part of the primary experiment, so let's move the ADT counts into an altExp slot.

```{r}
gene_names <- as.data.frame(rowData(pbmc_sce_percellqc)) %>% 
  dplyr::filter(Type == "Gene Expression") %>% 
  dplyr::pull(ID)
adt_names <- as.data.frame(rowData(pbmc_sce_percellqc)) %>% 
  dplyr::filter(Type == "Antibody Capture") %>% 
  dplyr::pull(ID)

adt_pbmc <- pbmc_sce_percellqc[rownames(pbmc_sce_percellqc) %in% adt_names]

# split out the experiments:
pbmc_sce_percellqc <- pbmc_sce_percellqc[rownames(pbmc_sce_percellqc) %in% gene_names]
altExp(pbmc_sce_percellqc, "CITEseq") <- adt_pbmc
```



### Filter RNA

#### First, with `DropletUtils`

```{r}
# Filter RNA
droplet_df <- DropletUtils::emptyDrops(
  counts(pbmc_sce_percellqc), 
  BPPARAM = BiocParallel::MulticoreParam(4)
) 

# Filter down to low FDR cells and check out dimensions
# Values here are mostly NA.
# NOTE: this filtering does propagate to altExp!! :) 
cells_to_retain <- which(droplet_df$FDR <= 0.01)
filtered_sce <- pbmc_sce_percellqc[, cells_to_retain]
dim(filtered_sce) 
```


#### We can also filter RNA with `miQC`

Mito QC stats are already present in `pbmc_sce_percellqc`.
This is sometimes working and sometimes not for me, so commenting out for now...
```{r}
#miqc_model <- miQC::mixtureModel(pbmc_sce_percellqc) 
#filtered_sce_miqc <- miQC::filterCells(pbmc_sce_percellqc,
#                                       model = miqc_model)
#
#dim(filtered_sce_miqc)
```
Moving forward, one can choose to proceed with either `filtered_sce_miqc` or `filtered_sce`; we'll use `filtered_sce` for now.


#### Compare `DropletUtils` to `miQC` filtering

We may want to compare certain aspects of cells that were filtered out with DropletUtils vs miQC.
Chunk below, currently pending content..., can do that!

```{r}

```

### Filter ADT

This data does have a control antibody (IgG1), so we can leverage this ADT for QC and filtering.
```{r}
# Filter ADT
# http://bioconductor.org/books/3.16/OSCA.advanced/integrating-with-protein-abundance.html#applying-custom-qc-filters

controls <- grep("^Ig", rownames(altExp(filtered_sce)))
adt_qc_df <- DropletUtils::cleanTagCounts(altExp(filtered_sce), controls=controls) # I feel like this control might be crap!

summary(adt_qc_df$high.controls) # these are all NA????????
summary(adt_qc_df$discard) # these are MOSTLY NA????????

# Let's do this - remove cells that have zero ambient concentrations:
# This removes 11 cells
cells_to_retain <- which(adt_qc_df$zero.ambient == FALSE)
filtered_sce <- filtered_sce[, cells_to_retain]
dim(filtered_sce)
```



### Normalize RNA and ADT:


```{r}
# Normalize RNA
qclust <- scran::quickCluster(filtered_sce)
filtered_sce <- scran::computeSumFactors(filtered_sce, clusters = qclust)
norm_sce <- scater::logNormCounts(filtered_sce)

# Normalize ADT

# Calculate baseline:
# Try out control-based normalization here 
#  http://bioconductor.org/books/3.16/OSCA.advanced/integrating-with-protein-abundance.html#control-based-normalization
control_sf <- scater::librarySizeFactors(altExp(norm_sce), subset_row=controls)  # `controls` was previously defined during filtering
sum(control_sf == 0) # _HOLY WOW_

# Go for median instead, BUT TODO: would we want to exclude control here during baseline calculation? 
baseline <- DropletUtils::ambientProfileBimodal(altExp(filtered_sce)) # !! currently this does not exclude controls
median_sf <- scater::medianSizeFactors(altExp(norm_sce), reference = baseline)
sum(median_sf == 0) # none are 0 here, soooo let's do this?

# Normalize with the median size factors
altExp(norm_sce) <- scater::logNormCounts(altExp(norm_sce), 
                                          size.factors = median_sf)

```

### Behold, the filtered and normalized SCE:

```{r}
norm_sce

altExp(norm_sce)
```

## Dimension reduction

HVGs:
```{r}
num_genes <- 5000 # eh?

gene_variance <- scran::modelGeneVar(norm_sce)
hvg_list <- scran::getTopHVGs(gene_variance,
                               n = num_genes)
```

PCA:
```{r}
# Do we want to set the number of PCs?
norm_sce <- scater::runPCA(norm_sce,
                           subset_row = hvg_list)
```

UMAP:
```{r I map you map we all map for MapMap}
# We can arbitrarily cluster first just to have some colors in there for funsies
k <- 10

# perform the clustering
kclusters <- clusterRows(
  reducedDim(norm_sce, "PCA"),
  KmeansParam(centers = k)
)

# pop back into sce
norm_sce$kcluster <- factor(kclusters)


# Add in UMAPs and plot with colors
norm_sce <- scater::runUMAP(norm_sce,
                            dimred = "PCA")
scater::plotReducedDim(norm_sce, "UMAP", colour_by = "kcluster")
```

## Cell type annotation

We can introduce annotation with `SingleR`, and it might be a good idea to show how the results are highly influenced by the reference. 
For now, I'm just using the `HumanPrimaryCellAtlasData` reference as a starting place.


```{r}
ref_data <- celldex::HumanPrimaryCellAtlasData(ensembl = TRUE) # pick one for now to start
preds <- SingleR::SingleR(
  test = norm_sce, 
  ref = ref_data,
  labels = ref_data$label.main # "coarse-grained" labels
)
preds

# We can place these into the sce
norm_sce$celltype_predictions <- preds$pruned.labels
```


Visualize the predictions in a couple ways:
```{r}
SingleR::plotScoreHeatmap(preds)
```


```{r UMAPs are for the people}
# Not too shabby!
# maybe drop the size and alpha a bit to see more
scater::plotReducedDim(norm_sce, "UMAP", colour_by = "celltype_predictions", 
                       point_alpha = 0.4, point_size = 0.25)
```


## sessionInfo

```{r}
sessionInfo()
```
