---
title: "Differential expression analysis for single-cell RNA-seq"
author: "Data Lab for ALSF"
date: "2022"
output:
  html_notebook:
    toc: yes
    toc_float: yes
---

## Objectives 

This notebook will demonstrate how to:

- Use pseudo-bulking to prepare single-cell RNA-sequencing libraries for differential expression
- Perform differential expression with the `DESeq2` package
- Use `ggplot` and `EnhancedVolcano` to visualize gene expression changes across cell types and samples

---

Many of the previous steps that we have discussed - filtering through clustering and assignment of cell types are done on an individual sample level.
During cell type assignment, marker genes for sub populations and clusters of cells were assigned by comparing the gene expression in these sub populations to the gene expression of all other cells in the sample. 

Just like bulk RNA-seq, it is likely that one of our goals of performing single-cell RNA-seq will be to compare the gene expression of multiple samples to each other.
In this notebook, we will work with multiple samples to identify differentially expressed genes across cell types of interest using the [`DESeq2`](https://bioconductor.org/packages/release/bioc/html/DESeq2.html) package. 

We will continue working with samples from the [`SCPCP000005` project](https://scpca.alexslemonade.org/projects/SCPCP000005), an investigation of pediatric solid tumors led by the Dyer and Chen labs at St. Jude Children's Research Hospital.
This particular dataset contains 10 different samples that have been integrated using `fastMNN`, following the same procedure we outlined in `03-dataset_integration.Rmd`.
These 10 samples represent two different types of rhabdomyosarcoma: embryonal rhabdomyosarcoma and alveolar rhabdomyosarcoma.
We will read in a `SingleCellExperiment` object that contains both the uncorrected (merged but not integrated) and corrected (integrated) gene expression data for all 10 samples.

Just like in the integration notebook, this dataset contains the cell type annotations found in the `celltype_fine` and `celltype_broad` columns of the `colData`.
These cell types were originally assigned in [Patel _et al._ (2022)](https://doi.org/10.1016/j.devcel.2022.04.003).
We will use these cell type assignments to set up the differential expression analysis below, but they are not required.
Differential gene expression can be applied to any sub population of interest that is shared across samples and does not need to be explicitly defined by a cell type.

## Set Up

```{r setup}
# set seed for reproducibility
set.seed(2022)

# load libraries
library(magrittr) # the pipe (%>%)
library(ggplot2) # plotting functions
library(SingleCellExperiment) 

# package used for differential expression analysis
library(DESeq2)
```

Prior to integration all 10 samples went through the same filtering, normalization, and dimensionality reduction.
These 10 samples were then merged into one `SingleCellExperiment` (SCE) object following the same steps outlined in `03-dataset_integration.Rmd`.
The merged object was then integrated to obtain a corrected gene expression assay and corrected reduced dimensionality results.
The final SCE object was stored in `data/rms/integrated/rms_all_sce.rds`.

We also have provided a metadata file, `data/rms/annotations/rms_sample_metadata.tsv`, that contains information from each sample, such as diagnosis, sex, age, etc.
In this file each row corresponds to a sample found in the integrated SCE object.

To begin, let's set up our directories and files:

```{r filepaths}
# set up file paths 
# data directory for RMS data
data_dir <- file.path("data", "rms")

# integrated file containing all libraries to use for DE analysis
integrated_sce_file <- file.path(data_dir, "integrated", "rms_all_sce.rds")

# sample metadata with information needed to setup DE analysis
sample_metadata_file <- file.path(data_dir, "annotations", "rms_sample_metadata.tsv")

# directory to store output
deseq_dir <- file.path("analysis", "rms", "deseq")
if(!dir.exists(deseq_dir)){
  dir.create(deseq_dir, recursive = TRUE)
}

# results file to output from DE analysis
deseq_output_file <- file.path(deseq_dir, "rms_myoblast_deseq_results.tsv")
```

We can go ahead and read in the SCE object and the metadata file.

```{r read files}
# read in the SCE object that has already been integrated
integrated_sce <- readr::read_rds(integrated_sce_file)

# read in sample metadata file 
sample_metadata <- readr::read_tsv(sample_metadata_file)
```

## Dataset Exploration

Before we dive into differential expression, let's explore our integrated SCE object and the dataset a little more.

We'll start by looking at what's inside the object.
Here we should have both the original (uncorrected) data and the integrated (corrected) data for both the gene expression and the reduced dimensionality results.
How are those stored in our object?

```{r dimnames}
# look at the assay names in our object
assayNames(integrated_sce)

# look at the names of the dimensionality reduction present in the SCE object
reducedDimNames(integrated_sce)
```

When we look at the assay names we should see that there are 3 matrices, `counts`, `logcounts`, and `fastmnn_corrected`. 
The `counts` and `logcounts` assays correspond to the uncorrected gene expression data that has been merged but NOT integrated.
The `fastmnn_corrected` data contains the corrected gene expression data obtained from integration. 
For this exercise we will not be using the `fastmnn_corrected` data (more on why not once we get to setting up the differential expression), but we need to be aware that it is present and be able to distinguish it from our uncorrected data. 

In the `reducedDim` slots you should see `PCA` and `UMAP` which both correspond to the pre-integrated dimensionality reduction results.
You should also see `fastmnn_PCA` and `fastmnn_UMAP` reduced dimensions, which correspond to the integrated results.
Let's start by looking at the UMAP of our data and labeling each sample.

Which reduced dimensionality slot should we use for making our UMAP plot?

```{r all sample UMAP}
# UMAP plot of all samples in integrated data
scater::plotReducedDim(integrated_sce,
                       # use the UMAP results from integrating with fastMNN
                       dimred = "fastmnn_UMAP",
                       # color points by original sample name
                       colour_by = "sample",
                       # adjust the point size and transparency
                       point_size= 0.5,
                       point_alpha = 0.2)
```

Here we used the `fastmnn_UMAP`, because these UMAP embeddings have been corrected for batch effects and now transform all data points into the same gene expression space. 
If you were to plot the default of `dimred=UMAP` you would see visually separate clusters that align to the individual samples as discussed in the data integration notebook. 

**Note: You should always use the batch-corrected dimensionality reduction results for visualizing datasets containing multiple libraries or samples.**

We can also take a look at the sample metadata table that we loaded: 

```{r sample metadata}
# print out sample metadata
head(sample_metadata)
```

Looking at this sample table, we see that all the samples are of the same diagnosis, rhabdomyosarcoma, but come from two types of rhabdomyosarcoma - embryonal rhabdomyosarcoma (ERMS) and alveolar rhabdomyosarcoma (ARMS).
These samples also come from a variety of tissue sites and stages of disease (initial diagnosis vs recurrence).

For today's example, we are particularly interested in comparing the gene expression across cell types in samples from patients diagnosed with ARMS vs. samples from patients diagnosed with ERMS.
To help us out later on when we are performing our analysis and making plots, let's incorporate the information in this sample metadata table into the `colData` of the integrated SCE object.
This will allow us to match each of the samples in the SCE object with the diagnosis group.

```{r modify coldata}
# add the sample metadata to the colData from the integrated SCE object
coldata_df <- colData(integrated_sce) %>%
  # convert from DataFrame to data.frame
  as.data.frame() %>%
  # merge with sample metadata 
  dplyr::left_join(sample_metadata, by = c("sample" = "library_id")) %>%
  # create a new columns
  dplyr::mutate(cell_id = paste(sample, barcode, sep = "-"), # combination of barcode and sample
                # simplify subdiagnosis for easier plotting and DE later
                diagnosis_group = forcats::fct_recode(
                  subdiagnosis,
                  "ARMS" = "Alveolar rhabdomyosarcoma",
                  "ERMS" = "Embryonal rhabdomyosarcoma"
                ))

# add modified data.frame back to SCE as DataFrame
colData(integrated_sce) <- DataFrame(coldata_df, row.names = coldata_df$cell_id)

# take a look at the new modified colData
head(colData(integrated_sce))
```

Now when we look at the `colData` of the SCE object we should see new columns, including the `diagnosis_group` column which indicates if each cell comes from an ERMS or ARMS sample.
We can now use that column to label any UMAP plots (or other plot types) that we make.
In the chunk below we will color our cells by subdiagnosis.

```{r diagnosis group UMAP}
# UMAP of all samples, separating by diagnosis group
scater::plotReducedDim(integrated_sce,
                       dimred = "fastmnn_UMAP",
                       colour_by = "diagnosis_group",
                       point_size= 0.5,
                       point_alpha = 0.2) 
```

Interestingly, it looks like samples from the ARMS and ERMS subdiagnoses tend to integrate with or samples of the same subdiagnosis rather than integrate all together. 

In the integration notebook we also looked at the distribution of cell types after integration.
We expect that cells of the same cell type should integrate with other cells of the same type.
Is that the case with this dataset?

_A word of caution when evaluating the cell type results for this dataset: The cell types for this dataset were assigned in a two stage process.
The first stage assigned cells as tumor or non-tumor.
The next stage further classified tumor cells into type of tumor cell (i.e., myoblast, myocyte, or mesoderm).
Some samples could not be further classified, so all of their tumor cells are denoted Tumor.
The samples which could be further classified have a mix of `Tumor_Mesoderm`, `Tumor_Myoblast`, and `Tumor_Myocyte`._

```{r celltype UMAP}
# # UMAP of all libraries, separating by diagnosis group and labeling cell type
scater::plotReducedDim(integrated_sce,
                       dimred = "fastmnn_UMAP",
                       # color each point by cell type
                       colour_by = "celltype_broad",
                       point_size= 0.5, 
                       point_alpha = 0.4)
```

Unlike with the previous datasets we have seen where all cells of the same cell type always grouped together, this dataset shows some slightly different patterns.
We see that there are at least 2 clear distinct groups for each cell type, 1 in each half of the UMAP.
It looks like this is because the difference in diagnosis group accounts for differences across all cells in the sample, even those from the same type. 
We can take advantage of the `facet_wrap()` function from `ggplot2` to look at two (or more, but we'll start with two) variables in the `colData` at once - the cell type and the subdiagnosis.
In the below plot we will color our cells by cell type but we will also use `facet_wrap()` to plot the cells from each subdiagnosis in their own separate panel of the plot.


```{r celltype subdiagnosis UMAP}
# # UMAP of all libraries, separating by diagnosis group and labeling cell type
scater::plotReducedDim(integrated_sce,
                       dimred = "fastmnn_UMAP",
                       # color each point by cell type
                       colour_by = "celltype_broad",
                       point_size= 0.5, 
                       point_alpha = 0.4,
                       other_fields = "diagnosis_group") +
  # split plots by diagnosis group 
  facet_wrap(~ diagnosis_group)
```

As expected, we see that the visual clusters of cell types are being separated, most likely due to different subdiagnoses.
Although we expect that the same cell types are present in both, each of the subdiagnoses for rhabdomyosarcoma have a distinct genomic and epigenomic landscape, likely accounting for the global gene expression changes seen between samples from these two subdiagnoses in the UMAP ([Shern _et al._ 2014](https://doi.org/10.1158/2159-8290.CD-13-0639), [Stewart _et al._](https://doi.org/10.1016/j.ccell.2018.07.012)).

We can also use a stacked barplot to look at the distribution of cell types across each sample.

```{r celltype barplot}
# filter coldata data.frame to only include tumor cells
tumor_cells_df <- coldata_df %>%
  dplyr::filter(stringr::str_detect(celltype_broad, "Tumor"))

# create a stacked barplot
ggplot(tumor_cells_df, aes(x = sample, fill = celltype_broad)) + 
    geom_bar(color = "black", size = 0.2) +
    labs(
      x = "Library",
      y = "Number of cells", 
      fill = "Cell type"
    ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  # split by diagnosis group 
  # only show non-NA values on x-axis
  facet_wrap(~diagnosis_group, 
             scales = "free_x",
             space = "free_x")
```

Similar to the UMAP, this plot shows that ARMS and ERMS share a lot of the same cell types.

We also see that only 6 of these libraries have tumor cells that have been further classified into cell type. 
3 libraries contain cells that are only classified as tumor or non-tumor, and tumor cells are not further classified and the remaining library appears to not have been assigned any cell types, as they are all labeled with `NA`.
We will continue our analysis only using the 6 libraries with fully classified cell types, removing the other 3 before we proceed with differential expression.

The reason we want to pare down our list of samples to consider is that we want to ensure that the cell types (or subpopulations) that we are interested in are present in all samples included in our differential gene expression analysis. 
We want to remove any samples that do not contain our cell population(s) of interest as they have no counts to contribute to the differential expression analysis.

```{r subset sce}
# define samples to keep
library_ids <- c(
  "SCPCL000479",
  "SCPCL000480",
  "SCPCL000481",
  "SCPCL000484",
  "SCPCL000488",
  "SCPCL000491"
)

# subset sce to only contain samples with IDs of interest 
samples_to_keep <- integrated_sce$sample %in% library_ids
rms_sce <- integrated_sce[,samples_to_keep]

# remove original integrated object 
rm(integrated_sce)
```


We now have an updated SCE object that contains 6 samples that were obtained from a mix of ARMS and ERMS patients.
We are particularly interested in identifying differentially expressed genes in tumor cell types between ARMS and ERMS.
Before we do that we need to ensure that we have enough biological replicates from each group to set up our experiment. 
It is imperative to consider good experimental design and ensure that we have enough biological replicates (at least > 3 for each group) when performing differential gene expression analysis.
Here one sample, or group of cells collected together, from one piece of tissue is one biological replicate.

We can count how many samples we have from each diagnosis group to ensure we have enough replicates.

```{r count diagnosis}
# total how many of each diagnosis group are left after subsetting 
sample_metadata %>%
  dplyr::filter(library_id %in% library_ids) %>%
  dplyr::count(subdiagnosis)
```

We have 3 ARMS and 3 ERMS samples which is great! 
We can now proceed forward with these 6 samples to identify differentially expressed genes in each of the shared cell types.
Lets take another look at the cell types found in these libraries and also how many of each cell type are present in our dataset.

```{r celltype table}
# look at distribution of cell types across all libraries 
as.data.frame(colData(rms_sce)) %>%
  # count number of cells in each cell type
  dplyr::count(celltype_broad) %>%
  # sort from largest to smallest
  dplyr::arrange(desc(n))
```

This table shows us that the majority of cells are tumor cells, in particular the largest population of cells are the `Tumor_Myoblast`.
Looking back at our stacked boxplot, we can see that this cell type is shared among all 6 of our selected samples. 

For this example we will focus on identifying differentially expressed genes in one cell type, the `Tumor_Myoblast` cells, but the principles applied below can be applied to any cell types or subpopulations of interest.

## Differential Expression Analysis

### Pseudo-bulking 

Before we can compare the gene expression profiles of myoblasts in ARMS vs. ERMS patients, we will need to "pseudo-bulk" the gene counts. 
Pseudo-bulking creates a new counts matrix that contains the total counts across all cells of a given label (e.g. cell type) for each sample. 
This allows us to use single-cell resolution to define the labels and sum gene counts across groups of cells containing the same label, and avoids counting each cell as its own replicate. 

Pseudo-bulking is implemented prior to differential expression analysis on single-cell data for the following reasons: 

- Produces larger counts, which allows us to use standard normalization and differential expression methods used by bulk RNA-sequencing. 
-  Collapses gene expression counts by sample, so that samples, rather than cells, represent replicates.
- Masks variance within a sample to emphasize variance across samples.

We are starting with the simple comparison of looking at one cell type and comparing across two groups of samples: the ERMS and ARMS subdiagnoses. 
Our first step will be to pseudo-bulk our dataset to group our cells by cell type and by sample.
This will create a new `SingleCellExperiment` (SCE) object that contains the pseudo-bulked counts for all genes. 
We can subset this SCE to just contain our cell type of interest (tumor myoblasts) for input to differential expression analysis. 

Before we apply pseudo-bulking to our dataset, let's look at a simple example of how pseudo-bulking works. 

```{r}
# create an example counts matrix
counts_mtx <- matrix(1:12, 
                     ncol = 4,
                     dimnames = list(c("geneA", "geneB", "geneC"),
                                     c("A-cell1", "A-cell2", "B-cell1", "B-cell2")))
counts_mtx
```


```{r}
# create new matrix, summing the counts for each gene across all cells in the specified group
pseudobulked_counts <- cbind(
  rowSums(counts_mtx[,c("A-cell1", "A-cell2")]), # sum all counts for cells labeled with group A
  rowSums(counts_mtx[,c("B-cell1", "B-cell2")]) # sum all counts for cells labeled with group B
)
pseudobulked_counts 
```

Now the actual pseudo-bulking for our dataset! 
We can pseudo-bulk using any grouping that we are interested in.
For right now, we are interested in looking at gene expression across cell types, so we want to group the pseudo-bulked counts matrix by both cell type and sample. 

```{r}
# first let's subset our coldata to only have the columns we care about in pseudo-bulking 
pseudobulked_groups <- colData(rms_sce)[, c("celltype_broad", "sample")]

# this creates a new SCE object that contains the pseudo-bulked counts across the provided groups 
pseudobulked_sce <- scuttle::aggregateAcrossCells(rms_sce, 
                                                  id = pseudobulked_groups)

# column names aren't automatically added, so let's add them in 
colnames(pseudobulked_sce) <- glue::glue("{pseudobulked_sce$celltype_broad}_{pseudobulked_sce$sample}")

pseudobulked_sce
```

How does the new pseudo-bulked `SingleCellExperiment` look different? 

```{r}
# only 37 columns in the counts assay 
counts(pseudobulked_sce)[1:10, 1:10]
```

Let's take a look at what the `colData` now looks like in the pseudo-bulked SCE object. 

```{r}
# note the new addition of the column with number of cells per group 
colData(pseudobulked_sce)
```

*Add more justification on filtering and why we need it*

Before we are ready to proceed with our pseudo-bulked counts matrix, we want to do some filtering.
We will remove any groups in the pseudo-bulked dataset that may have a low number of cells. 

```{r}
# filter by number of cells 
filtered_pseudobulked_sce <- pseudobulked_sce[, pseudobulked_sce$ncells >= 10]
```


```{r}
dim(pseudobulked_sce)
dim(filtered_pseudobulked_sce)
```

### Perform differential expression with DESeq2

*Intro about DESeq2*

Before we identify differentially expressed genes, we will want to subset the pseudo-bulked `SingleCellExperiment` object to contain only the cell type that we are interested in comparing across the two subdiagnoses.

```{r}
tumor_myoblast_sce <- filtered_pseudobulked_sce[, filtered_pseudobulked_sce$celltype_broad == "Tumor_Myoblast"]
```

This leaves us with 6 columns in our dataset that should all have `celltype_broad = Tumor_Myoblast`. 

```{r}
table(tumor_myoblast_sce$celltype_broad)
```

Now we are ready to set up our `DESeq2` object. 

```{r}
# deseq2 requires the coldata object as a separate input
#  in data.frame format
coldata_df <- as.data.frame(colData(tumor_myoblast_sce))
  
# set up the deseq object 
deseq_object <- DESeq2::DESeqDataSetFromMatrix(counts(tumor_myoblast_sce),
                                               colData = coldata_df,
                                               design = ~ diagnosis_group)
```

Use the median of ratios method for count normalization followed by regularized log transformation.

```{r}
# estimate size factors first 
deseq_object <- DESeq2::estimateSizeFactors(deseq_object)

# normalize and log transform to use for visualization
normalized_object <- DESeq2::rlog(deseq_object, blind = TRUE, fitType = 'local')
normalized_object
```

Evaluate QC here using PCA. 
Here we can label by the diagnosis groups to show that the highest amount of variance is due to different subdiagnoses. 

```{r}
DESeq2::plotPCA(normalized_object, intgroup = "diagnosis_group")
```

```{r}
# run DESeq
# use the same fit type as with rlog 
deseq_object <- DESeq2::DESeq(deseq_object, fitType = "local")
```

Next we take a look at the dispersions, we expect to see dispersions decrease as means are increasing and follow the line of best fit. 

```{r}
plotDispEsts(deseq_object)
```

Now we can extract the results from the object, specifying the p-value threshold that we would like to use.

```{r}
# extract the results as a DataFrame
deseq_results <- DESeq2::results(deseq_object, alpha = 0.05)
```

But we aren't done yet!

The estimates of log2 fold change calculated by `DESeq()` are not corrected for expression level.
This means that when counts are small, we are likely to end up with some large fold change values that overestimate the true extent of the change between conditions.

We can correct this by applying a "shrinkage" procedure, which will adjust large values with small counts downward, while preserving values with larger counts, which are likely to be more accurate.

To do this, we will use the `lfcShrink()` function, but first we need to know the name and/or position of the "coefficient" that was calculated by `DESeq()`, which we can do with the `resultsNames()` function.

```{r}
# identify position of coefficient
DESeq2::resultsNames(deseq_object)
```


```{r}
# appyly logFC shrinkage
shrink_results <- DESeq2::lfcShrink(deseq_object, res = deseq_results, coef = 2, type = "apeglm")
```

Now we can get the updated results and combine with the `rowData` from the SCE object to extract the gene symbol. 

```{r}
# create a data frame with the results 
deseq_results <- shrink_results %>%
  tibble::as_tibble(rownames = "ensembl_id")

# first look at the significant results 
deseq_results_sig <- deseq_results %>%
  dplyr::filter(padj <= 0.05)

deseq_results_sig
```


```{r}
# convert rowdata to dataframe 
sce_rowdata_df <- rowData(tumor_myoblast_sce) %>%
  # create a column with rownames stored as ensembl id to use for joining with deseq results
  tibble::as_tibble(rownames = "ensembl_id")

# combine deseq results with rowdata by ensembl id 
deseq_results <- deseq_results %>%
  dplyr::left_join(sce_rowdata_df, by = "ensembl_id")

head(deseq_results)
```

```{r}
# save our results 
readr::write_tsv(deseq_results, deseq_output_file)
```


### Exploring the identified differentially expressed genes 

Let's also do some initial analysis to look at what types of genes are being identified and see if what is being identified as actually up/down regulated appear to correlate back to the single cell data. 

The first plot we'll make is a volcano plot and we can label the significant genes with their gene symbols. 

```{r}
EnhancedVolcano::EnhancedVolcano(deseq_results,
                x = 'log2FoldChange', # fold change statistic to plot
                y = 'pvalue', # significance values
                lab = deseq_results$gene_symbol, # labels for points
                pCutoff = 1e-05, # The p value cutoff we will use (default)
                FCcutoff = 1, # The fold change cutoff (default)
                title = NULL, # no title
                subtitle = NULL, # or subtitle
                caption = NULL, # or caption
                drawConnectors = TRUE, # add some fun arrows
                labSize = 3  # smaller labels
                ) +
  # change the overall theme
  theme_bw() +
  # move the legend to the bottom
  theme(legend.position = "bottom")
```

Let's make some UMAPs where we plot a gene that's identified to be differentially expressed in a given cell type and see what the expression of that gene is across samples. 
First we need to extract the expression for each of the genes we would like to plot from the `logcounts` matrix and combine with the `colData`.

```{r}
# add column to colData with expression of gene of interest 
# here we will actually put all of the significant genes so then we can plot any of them
sig_expressed_genes <- deseq_results %>%
  dplyr::filter(pvalue < 1e-5,
                abs(log2FoldChange) > 2) %>%
  dplyr::pull(ensembl_id)

sig_genes_counts <- logcounts(rms_sce[sig_expressed_genes,]) %>%
  as.matrix() %>%
  t() %>%
  as.data.frame() %>%
  dplyr::mutate(cell_id = colnames(rms_sce))
  
combined_coldata_df <- as.data.frame(colData(rms_sce)) %>%
  dplyr::left_join(sig_genes_counts, by = "cell_id")

# add back modified coldata containing gene expression for sig genes 
colData(rms_sce) <- DataFrame(combined_coldata_df, row.names = combined_coldata_df$cell_id)
```

We will pick a gene and look at the expression of that gene across subdiagnosis, sample, and cell type.

```{r}
# filter to just myoblast cells and remove any NA's before plotting
myoblast_combined_sce <- rms_sce[, which(rms_sce$celltype_broad == "Tumor_Myoblast")]

# first look at just ARMS vs. ERMS 
scater::plotReducedDim(myoblast_combined_sce,
                       dimred = "fastmnn_UMAP",
                       colour_by = "ENSG00000196090", #PTPRT
                       point_size= 0.5,
                       point_alpha = 0.4,
                       other_fields = "diagnosis_group") +
  facet_wrap(~ diagnosis_group, nrow = 3)
```


```{r}
# let's look across some other cell types
celltypes <- c("Tumor_Myoblast", "Tumor_Mesoderm", "Tumor_Myocyte", "Vascular Endothelium")

# subset to just tumor celltypes that we are interested in
tumor_sce <- rms_sce[, which(rms_sce$celltype_broad %in% celltypes)]
```


```{r}
# pick a few genes to look at 
genes_to_plot <- c("ENSG00000196090", #PTPRT
                   "ENSG00000148935") #GAS2

# create a violin plot across cell types of interest
scater::plotExpression(tumor_sce,
                       features = genes_to_plot, #PTPRT
                       x = "diagnosis_group", 
                       colour_by = "diagnosis_group",
                       other_fields = "celltype_broad",
                       point_size = 0.1) +
  facet_grid(Feature ~ celltype_broad) + 
  theme(strip.text = element_text(size = 7)) + 
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1)))
```

```{r}
# now do some exploration of other genes on your own! 
```

## Session Info 

```{r}
sessionInfo()
```

