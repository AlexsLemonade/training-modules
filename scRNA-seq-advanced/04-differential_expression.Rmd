---
title: "Differential expression analysis for single-cell RNA-seq"
author: "Data Lab for ALSF"
date: "2022"
output:
  html_notebook:
    toc: yes
    toc_float: yes
---

## Objectives 

This notebook will demonstrate how to:

- Use pseudo-bulking to prepare single-cell RNA-sequencing libraries for differential expression
- Perform differential expression with the `DESeq2` package
- Use `ggplot2` and `EnhancedVolcano` to visualize gene expression changes across cell types and samples

---

Just like bulk RNA-seq, it is likely that one of the goals when performing single-cell RNA-seq will be to compare the gene expression of multiple samples to each other.
Unlike bulk RNA-seq analysis, single-cell RNA-seq analysis allows us to identify and annotate cell types or subpopulations of cells present in each of our samples.
This means that we can account for differences in cell type composition across samples and specifically focus on cell types or populations of interest when performing differential expression (DE) analysis.
In this notebook, we will work with multiple samples to identify differentially expressed genes across cell types of interest using the [`DESeq2`](https://bioconductor.org/packages/release/bioc/html/DESeq2.html) package. 

We will continue working with samples from the [`SCPCP000005` project](https://scpca.alexslemonade.org/projects/SCPCP000005), an investigation of pediatric solid tumors led by the Dyer and Chen labs at St. Jude Children's Research Hospital.
This particular dataset contains 10 different samples that have been integrated using `fastMNN`, following the same procedure we outlined in `03-dataset_integration.Rmd`.
These 10 samples represent two different types of rhabdomyosarcoma (RMS): embryonal rhabdomyosarcoma (ERMS) and alveolar rhabdomyosarcoma (ARMS).
These two subtypes can be distinguished by the presence of the `PAX3/PAX7-FOXO1` fusion gene present only in ARMS patients.
Additionally, cells found in ARMS tumors tend to have an increased mutational burden and cells are in a more differentiated state in comparison to ERMS tumor cells ([Shern _et al._ 2014](https://doi.org/10.1158/2159-8290.CD-13-0639), [Stewart _et al._](https://doi.org/10.1016/j.ccell.2018.07.012)).
RMS tumors, regardless of subtype, are made up of cells typically associated with development of skeletal muscle: mesoderm, myoblasts, and myocytes ([Sebire and Malone 2003](https://doi.org/10.1136/jcp.56.6.412)).
The group that published the data we are going to look at in this notebook identified distinct differences between ARMS and ERMS tumors. 
Here we will look at a subset of the samples they sequenced and walk through testing one of their hypothesis that cell types have distinct gene expression patterns in ARMS vs. ERMS samples.

## Set Up

```{r setup}
# set seed for reproducibility
set.seed(2022)

# load libraries
library(magrittr) # the pipe (%>%)
library(ggplot2) # plotting functions
library(SingleCellExperiment) 

# package used for differential expression analysis
library(DESeq2)
```

We will start by reading in a `SingleCellExperiment` (SCE) object that contains both the uncorrected (merged but not integrated) and corrected (integrated) gene expression data for all 10 samples.

Prior to integration all 10 samples went through the same filtering, normalization, and dimensionality reduction.
These 10 samples were then merged into one `SingleCellExperiment` object following the same steps outlined in `03-dataset_integration.Rmd`.
The merged object was then integrated with `fastMNN` to obtain a corrected gene expression assay and corrected reduced dimensionality results.
The final SCE object was stored in `data/rms/integrated/rms_all_sce.rds`.

We also have provided a metadata file, `data/rms/annotations/rms_sample_metadata.tsv`, that contains information from each sample, such as diagnosis, sex, age, etc.
In this file each row corresponds to a sample found in the integrated SCE object.

To begin, let's set up our directories and files:

```{r filepaths}
# set up file paths 
# data directory for RMS data
data_dir <- file.path("data", "rms")

# integrated file containing all samples to use for DE analysis
integrated_sce_file <- file.path(data_dir, "integrated", "rms_all_sce.rds")

# sample metadata with information needed to setup DE analysis
sample_metadata_file <- file.path(data_dir, "annotations", "rms_sample_metadata.tsv")

# directory to store output
deseq_dir <- file.path("analysis", "rms", "deseq")
if(!dir.exists(deseq_dir)){
  dir.create(deseq_dir, recursive = TRUE)
}

# results file to output from DE analysis
deseq_output_file <- file.path(deseq_dir, "rms_myoblast_deseq_results.tsv")
```

We can go ahead and read in the SCE object and the metadata file.

```{r read files}
# read in the SCE object that has already been integrated
integrated_sce <- readr::read_rds(integrated_sce_file)

# read in sample metadata file 
sample_metadata <- readr::read_tsv(sample_metadata_file)
```

## Dataset Exploration

Before we dive into differential expression, let's explore our integrated SCE object and the dataset a little more.

We'll start by looking at what's inside the object.
Here we should have both the original (uncorrected) data and the integrated (corrected) data for both the gene expression and the reduced dimensionality results.
How are those stored in our object?

```{r print sce}
# print out entire object
integrated_sce

# look at the assay names in our object
assayNames(integrated_sce)

# look at the names of the dimensionality reduction present in the SCE object
reducedDimNames(integrated_sce)
```

When we look at the assay names we should see that there are 3 matrices, `counts`, `logcounts`, and `fastmnn_corrected`. 
The `counts` and `logcounts` assays correspond to the uncorrected gene expression data that has been merged but NOT integrated.
The `fastmnn_corrected` data contains the corrected gene expression data obtained from integration. 
For this exercise we will not be using the `fastmnn_corrected` data (more on why not once we get to setting up the differential expression), but we need to be aware that it is present and be able to distinguish it from our uncorrected data. 

In the `reducedDim` slots you should see `PCA` and `UMAP` which both correspond to the pre-integrated dimensionality reduction results.
You should also see `fastmnn_PCA` and `fastmnn_UMAP` reduced dimensions, which correspond to the integrated results.

Just like in the integration notebook, this dataset also contains the cell type annotations found in the `celltype_fine` and `celltype_broad` columns of the `colData`.
These cell types were originally assigned in [Patel _et al._ (2022)](https://doi.org/10.1016/j.devcel.2022.04.003).
We will use these cell type assignments to set up the DE analysis below, but they are not required.
It's important to note that DE analysis can be applied to any sub population of interest that is shared across samples and does not need to be explicitly defined by a cell type.

Because we are going to be doing DE analysis between ARMS and ERMS samples, let's start by labeling cells in the integrated dataset based on their RMS subtype.
To do this we will need to be sure that the subtype is present in the `colData` of the integrated SCE object.
If it's not there, we need to add it in.

```{r coldata head}
# look at the head of the coldata
head(colData(integrated_sce))
```

Fortunately we also have the sample metadata table that we read in earlier, which contains information about each of the samples present in the dataset.


```{r sample metadata}
# print out sample metadata
head(sample_metadata)
```

Looking at this sample table, we see a column named `subdiagnosis` which accounts for the RMS subtype, ARMS or ERMS.
We also see other columns that contain information about each specific sample and may contribute to differences seen across the samples.

We can incorporate the information in this sample metadata table into the `colData` of the integrated SCE object.
This will allow us to match each of the samples in the SCE object with the RMS subtype and also allow us to use any of the columns in the sample metadata for plotting.

```{r modify coldata}
# add the sample metadata to the colData from the integrated SCE object
coldata_df <- colData(integrated_sce) %>%
  # convert from DataFrame to data.frame
  as.data.frame() %>%
  # merge with sample metadata 
  dplyr::left_join(sample_metadata, by = c("sample" = "library_id")) %>%
  # create a new columns
  dplyr::mutate(cell_id = paste(sample, barcode, sep = "-"), # combination of barcode and sample
                # simplify subdiagnosis for easier plotting and DE later
                diagnosis_group = forcats::fct_recode(
                  subdiagnosis,
                  "ARMS" = "Alveolar rhabdomyosarcoma",
                  "ERMS" = "Embryonal rhabdomyosarcoma"
                ))

# add modified data.frame back to SCE as DataFrame
colData(integrated_sce) <- DataFrame(coldata_df, row.names = coldata_df$cell_id)

# take a look at the new modified colData
head(colData(integrated_sce))
```

Now when we look at the `colData` of the SCE object we should see new columns, including the `diagnosis_group` column which indicates if each cell comes from an ERMS or ARMS sample.
We can now use that column to label any UMAP plots (or other plot types) that we make.
In the chunk below we will start by taking a look at our integration results and color our cells by RMS subtype.

**Reminder: You should always use the batch-corrected dimensionality reduction results for visualizing datasets containing multiple libraries or samples.**

```{r diagnosis group UMAP}
# UMAP of all samples, separating by diagnosis group
scater::plotReducedDim(integrated_sce,
                       dimred = "fastmnn_UMAP",
                       colour_by = "diagnosis_group",
                       point_size= 0.5,
                       point_alpha = 0.2) 
```

Interestingly, it looks like samples from the ARMS and ERMS subtypes tend to cluster with samples of the same subtype rather than cluster all together. 

In the integration notebook we also looked at the distribution of cell types after integration.
In that notebook we discussed that cells of the same cell type are expected to integrate with other cells of the same type.
Is that the case with this dataset?

A word of caution when evaluating the cell type results for this dataset: The cell types for this dataset were assigned in a two stage process as described in [Patel _et al._ (2022)](https://doi.org/10.1016/j.devcel.2022.04.003).
The first stage assigned cells as tumor or non-tumor.
The next stage further classified tumor cells into one of three types of tumor cells: myoblast, myocyte, or mesoderm.
Some samples could not be further classified, so all of their tumor cells are denoted `Tumor`.
The samples which could be further classified have a mix of `Tumor_Mesoderm`, `Tumor_Myoblast`, and `Tumor_Myocyte`.

```{r celltype UMAP}
# # UMAP of all libraries, separating by diagnosis group and labeling cell type
scater::plotReducedDim(integrated_sce,
                       dimred = "fastmnn_UMAP",
                       # color each point by cell type
                       colour_by = "celltype_broad",
                       point_size= 0.5, 
                       point_alpha = 0.4)
```

That doesn't appear to be the case with this dataset. 
Unlike with the previous datasets we have seen where all cells of the same cell type always grouped together, this dataset shows some slightly different patterns and not all cells of the same cell type cluster together.
One reason is that tumor data can be heterogeneous and every tumor is unique.
Depending on the tumor type we may not expect every sample to integrate perfectly.
In this particular case we are looking at two subtypes of RMS that have been shown to have distinctly different mutation burdens and differentiation states, so it's likely that those differences are contributing to how well they will be integrated.

To explore whether cells are grouping together both by cell type and by RMS subtype, we can create a plot that incorporates both pieces of metadata.
We will take advantage of the `facet_wrap()` function from `ggplot2` to look at two (or more, but we'll start with two) variables in the `colData` at once - the cell type and the subdiagnosis.
In the below plot we will color our cells by cell type while also using `facet_wrap()` so that cells from different subdiagnoses will be in their own plot panel.

```{r celltype subdiagnosis UMAP}
# UMAP of all samples, separating by diagnosis group and labeling cell type
scater::plotReducedDim(integrated_sce,
                       dimred = "fastmnn_UMAP",
                       # color each point by cell type
                       colour_by = "celltype_broad",
                       point_size= 0.5, 
                       point_alpha = 0.4,
                       # tell scater that we want to use diagnosis_group for plotting
                       other_fields = "diagnosis_group") +
  # split plots by diagnosis group 
  facet_wrap(~ diagnosis_group)
```

As expected, we see that the visual clusters of cell types are being separated, most likely due to different RMS subtypes.

We can also use a stacked barplot to look at the distribution of cell types across each sample.

```{r celltype barplot}
# filter coldata data.frame to only include tumor cells
tumor_cells_df <- coldata_df %>%
  dplyr::filter(stringr::str_detect(celltype_broad, "Tumor"))

# create a stacked barplot
ggplot(tumor_cells_df, aes(x = sample, fill = celltype_broad)) + 
    geom_bar(position = "fill", color = "black", size = 0.2) +
    labs(
      x = "Library",
      y = "Number of cells", 
      fill = "Cell type"
    ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  # split by diagnosis group 
  # only show non-NA values on x-axis
  facet_grid(cols = vars(diagnosis_group), 
             scales = "free_x",
             space = "free_x")
```

Similar to the UMAP, this plot shows that ARMS and ERMS share a lot of the same cell types.

We also see that only 6 of these libraries have tumor cells that have been further classified into mesoderm, myoblast, and myocyte. 
3 libraries contain cells that are only classified as tumor or non-tumor, and tumor cells are not further classified, and the remaining library appears to not have been assigned any cell types and is not present in our plot, as they are all labeled with `NA`.
We will continue our analysis only using the 6 libraries with fully classified cell types, removing the other 3 before we proceed with differential expression.

The reason we want to pare down our list of samples to consider is that we want to ensure that the cell types (or subpopulations) that we are interested in are present in all samples included in our DE analysis. 
We want to remove any samples that do not contain our cell population(s) of interest as they have no counts to contribute to the DE analysis.

```{r subset sce}
# define samples to keep
library_ids <- c(
  "SCPCL000479",
  "SCPCL000480",
  "SCPCL000481",
  "SCPCL000484",
  "SCPCL000488",
  "SCPCL000491"
)

# subset sce to only contain samples with IDs of interest 
samples_to_keep <- integrated_sce$sample %in% library_ids
rms_sce <- integrated_sce[,samples_to_keep]

# remove original integrated object to save some memory
rm(integrated_sce)

# print out our new sce 
rms_sce
```


We now have an updated SCE object that contains 6 samples that were obtained from a mix of ARMS and ERMS patients.
We are particularly interested in identifying DE genes in tumor cell types between ARMS and ERMS.
We should also make sure that we have enough biological replicates from each group to set up our experiment. 
It is imperative to consider good experimental design and ensure that we have enough biological replicates (at least 3 for each group) when performing differential gene expression analysis.

If we look back at our stacked barplot we see that we picked 3 ARMS and 3 ERMS samples.
We can also see that the majority of cells are tumor cells, in particular the largest population of cells appears to be the `Tumor_Myoblast`. 
For this example we will focus on identifying DE genes in one cell type, the `Tumor_Myoblast` cells, but the principles applied below can be applied to any cell types or subpopulations of interest.

## Differential Expression Analysis

### Pseudo-bulking 

Before we can compare the gene expression profiles of myoblasts in ARMS vs. ERMS patients, we will need to "pseudo-bulk" the gene counts. 
Pseudo-bulking creates a new counts matrix that contains the total counts across all cells of a given label (e.g. cell type) for each sample. 
This allows us to use single-cell resolution to define the labels and sum gene counts across groups of cells containing the same label, and avoids counting each cell as its own replicate. 

Pseudo-bulking is implemented prior to differential expression analysis on single-cell data for the following reasons: 

- Produces larger counts, which allows us to use standard normalization and differential expression methods used by bulk RNA-sequencing. 
-  Collapses gene expression counts by sample, so that samples, rather than cells, represent replicates.
- Masks variance within a sample to emphasize variance across samples.

We are starting with the simple comparison of looking at one cell type and comparing across two groups of samples: the ERMS and ARMS subdiagnoses. 
Our first step will be to pseudo-bulk our dataset to group our cells by cell type and by sample.
This will create a new `SingleCellExperiment` (SCE) object that contains the pseudo-bulked counts for all genes. 
We can subset this SCE to just contain our cell type of interest (tumor myoblasts) for input to differential expression analysis. 

Before we apply pseudo-bulking to our dataset, let's look at a simple example of how pseudo-bulking works. 

```{r}
# create an example counts matrix
counts_mtx <- matrix(1:12, 
                     ncol = 4,
                     dimnames = list(c("geneA", "geneB", "geneC"),
                                     c("A-cell1", "A-cell2", "B-cell1", "B-cell2")))
counts_mtx
```


```{r}
# create new matrix, summing the counts for each gene across all cells in the specified group
pseudobulked_counts <- cbind(
  rowSums(counts_mtx[,c("A-cell1", "A-cell2")]), # sum all counts for cells labeled with group A
  rowSums(counts_mtx[,c("B-cell1", "B-cell2")]) # sum all counts for cells labeled with group B
)
pseudobulked_counts 
```

Now the actual pseudo-bulking for our dataset! 
We can pseudo-bulk using any grouping that we are interested in.
For right now, we are interested in looking at gene expression across cell types, so we want to group the pseudo-bulked counts matrix by both cell type and sample. 

```{r}
# first let's subset our coldata to only have the columns we care about in pseudo-bulking 
pseudobulked_groups <- colData(rms_sce)[, c("celltype_broad", "sample")]

# this creates a new SCE object that contains the pseudo-bulked counts across the provided groups 
pseudobulked_sce <- scuttle::aggregateAcrossCells(rms_sce, 
                                                  id = pseudobulked_groups)

# column names aren't automatically added, so let's add them in 
colnames(pseudobulked_sce) <- glue::glue("{pseudobulked_sce$celltype_broad}_{pseudobulked_sce$sample}")

pseudobulked_sce
```

How does the new pseudo-bulked `SingleCellExperiment` look different? 

```{r}
# only 37 columns in the counts assay 
counts(pseudobulked_sce)[1:10, 1:10]
```

Let's take a look at what the `colData` now looks like in the pseudo-bulked SCE object. 

```{r}
# note the new addition of the column with number of cells per group 
colData(pseudobulked_sce)
```

*Add more justification on filtering and why we need it*

Before we are ready to proceed with our pseudo-bulked counts matrix, we want to do some filtering.
We will remove any groups in the pseudo-bulked dataset that may have a low number of cells. 

```{r}
# filter by number of cells 
filtered_pseudobulked_sce <- pseudobulked_sce[, pseudobulked_sce$ncells >= 10]
```


```{r}
dim(pseudobulked_sce)
dim(filtered_pseudobulked_sce)
```

### Perform differential expression with DESeq2

*Intro about DESeq2*

Before we identify differentially expressed genes, we will want to subset the pseudo-bulked `SingleCellExperiment` object to contain only the cell type that we are interested in comparing across the two subdiagnoses.

```{r}
tumor_myoblast_sce <- filtered_pseudobulked_sce[, filtered_pseudobulked_sce$celltype_broad == "Tumor_Myoblast"]
```

This leaves us with 6 columns in our dataset that should all have `celltype_broad = Tumor_Myoblast`. 

```{r}
table(tumor_myoblast_sce$celltype_broad)
```

Now we are ready to set up our `DESeq2` object. 

```{r}
# deseq2 requires the coldata object as a separate input
#  in data.frame format
coldata_df <- as.data.frame(colData(tumor_myoblast_sce))
  
# set up the deseq object 
deseq_object <- DESeq2::DESeqDataSetFromMatrix(counts(tumor_myoblast_sce),
                                               colData = coldata_df,
                                               design = ~ diagnosis_group)
```

Use the median of ratios method for count normalization followed by regularized log transformation.

```{r}
# estimate size factors first 
deseq_object <- DESeq2::estimateSizeFactors(deseq_object)

# normalize and log transform to use for visualization
normalized_object <- DESeq2::rlog(deseq_object, blind = TRUE, fitType = 'local')
normalized_object
```

Evaluate QC here using PCA. 
Here we can label by the diagnosis groups to show that the highest amount of variance is due to different subdiagnoses. 

```{r}
DESeq2::plotPCA(normalized_object, intgroup = "diagnosis_group")
```

```{r}
# run DESeq
# use the same fit type as with rlog 
deseq_object <- DESeq2::DESeq(deseq_object, fitType = "local")
```

Next we take a look at the dispersions, we expect to see dispersions decrease as means are increasing and follow the line of best fit. 

```{r}
plotDispEsts(deseq_object)
```

Now we can extract the results from the object, specifying the p-value threshold that we would like to use.

```{r}
# extract the results as a DataFrame
deseq_results <- DESeq2::results(deseq_object, alpha = 0.05)
```

But we aren't done yet!

The estimates of log2 fold change calculated by `DESeq()` are not corrected for expression level.
This means that when counts are small, we are likely to end up with some large fold change values that overestimate the true extent of the change between conditions.

We can correct this by applying a "shrinkage" procedure, which will adjust large values with small counts downward, while preserving values with larger counts, which are likely to be more accurate.

To do this, we will use the `lfcShrink()` function, but first we need to know the name and/or position of the "coefficient" that was calculated by `DESeq()`, which we can do with the `resultsNames()` function.

```{r}
# identify position of coefficient
DESeq2::resultsNames(deseq_object)
```


```{r}
# appyly logFC shrinkage
shrink_results <- DESeq2::lfcShrink(deseq_object, res = deseq_results, coef = 2, type = "apeglm")
```

Now we can get the updated results and combine with the `rowData` from the SCE object to extract the gene symbol. 

```{r}
# create a data frame with the results 
deseq_results <- shrink_results %>%
  tibble::as_tibble(rownames = "ensembl_id")

# first look at the significant results 
deseq_results_sig <- deseq_results %>%
  dplyr::filter(padj <= 0.05)

deseq_results_sig
```


```{r}
# convert rowdata to dataframe 
sce_rowdata_df <- rowData(tumor_myoblast_sce) %>%
  # create a column with rownames stored as ensembl id to use for joining with deseq results
  tibble::as_tibble(rownames = "ensembl_id")

# combine deseq results with rowdata by ensembl id 
deseq_results <- deseq_results %>%
  dplyr::left_join(sce_rowdata_df, by = "ensembl_id")

head(deseq_results)
```

```{r}
# save our results 
readr::write_tsv(deseq_results, deseq_output_file)
```


### Exploring the identified differentially expressed genes 

Let's also do some initial analysis to look at what types of genes are being identified and see if what is being identified as actually up/down regulated appear to correlate back to the single cell data. 

The first plot we'll make is a volcano plot and we can label the significant genes with their gene symbols. 

```{r}
EnhancedVolcano::EnhancedVolcano(deseq_results,
                x = 'log2FoldChange', # fold change statistic to plot
                y = 'pvalue', # significance values
                lab = deseq_results$gene_symbol, # labels for points
                pCutoff = 1e-05, # The p value cutoff we will use (default)
                FCcutoff = 1, # The fold change cutoff (default)
                title = NULL, # no title
                subtitle = NULL, # or subtitle
                caption = NULL, # or caption
                drawConnectors = TRUE, # add some fun arrows
                labSize = 3  # smaller labels
                ) +
  # change the overall theme
  theme_bw() +
  # move the legend to the bottom
  theme(legend.position = "bottom")
```

Let's make some UMAPs where we plot a gene that's identified to be differentially expressed in a given cell type and see what the expression of that gene is across samples. 
First we need to extract the expression for each of the genes we would like to plot from the `logcounts` matrix and combine with the `colData`.

```{r}
# add column to colData with expression of gene of interest 
# here we will actually put all of the significant genes so then we can plot any of them
sig_expressed_genes <- deseq_results %>%
  dplyr::filter(pvalue < 1e-5,
                abs(log2FoldChange) > 2) %>%
  dplyr::pull(ensembl_id)

sig_genes_counts <- logcounts(rms_sce[sig_expressed_genes,]) %>%
  as.matrix() %>%
  t() %>%
  as.data.frame() %>%
  dplyr::mutate(cell_id = colnames(rms_sce))
  
combined_coldata_df <- as.data.frame(colData(rms_sce)) %>%
  dplyr::left_join(sig_genes_counts, by = "cell_id")

# add back modified coldata containing gene expression for sig genes 
colData(rms_sce) <- DataFrame(combined_coldata_df, row.names = combined_coldata_df$cell_id)
```

We will pick a gene and look at the expression of that gene across subdiagnosis, sample, and cell type.

```{r}
# filter to just myoblast cells and remove any NA's before plotting
myoblast_combined_sce <- rms_sce[, which(rms_sce$celltype_broad == "Tumor_Myoblast")]

# first look at just ARMS vs. ERMS 
scater::plotReducedDim(myoblast_combined_sce,
                       dimred = "fastmnn_UMAP",
                       colour_by = "ENSG00000196090", #PTPRT
                       point_size= 0.5,
                       point_alpha = 0.4,
                       other_fields = "diagnosis_group") +
  facet_wrap(~ diagnosis_group, nrow = 3)
```


```{r}
# let's look across some other cell types
celltypes <- c("Tumor_Myoblast", "Tumor_Mesoderm", "Tumor_Myocyte", "Vascular Endothelium")

# subset to just tumor celltypes that we are interested in
tumor_sce <- rms_sce[, which(rms_sce$celltype_broad %in% celltypes)]
```


```{r}
# pick a few genes to look at 
genes_to_plot <- c("ENSG00000196090", #PTPRT
                   "ENSG00000148935") #GAS2

# create a violin plot across cell types of interest
scater::plotExpression(tumor_sce,
                       features = genes_to_plot, #PTPRT
                       x = "diagnosis_group", 
                       colour_by = "diagnosis_group",
                       other_fields = "celltype_broad",
                       point_size = 0.1) +
  facet_grid(Feature ~ celltype_broad) + 
  theme(strip.text = element_text(size = 7)) + 
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1)))
```

```{r}
# now do some exploration of other genes on your own! 
```

## Session Info 

```{r}
sessionInfo()
```

