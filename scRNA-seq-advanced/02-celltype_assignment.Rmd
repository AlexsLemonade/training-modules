---
title: "Assigning Cell Types"
author: Data Lab for ALSF
date: 2022
output:
  html_notebook: 
    toc: true
    toc_float: true
---

## Objectives

This notebook will demonstrate how to:

- 

---

In this notebook, we will attempt to assign cell types to each of the cells in a dataset, using some of the automated tools that are available within the Bioconductor universe.

Much of the material in this notebook is directly inspired by, and draws heavily on, material presented in the book [_Orchestrating Single Cell Analysis with Bioconductor_](http://bioconductor.org/books/3.16/OSCA/). 

The data we will use for this notebook is derived from a [10x Genomics dataset of human peripheral blood mononuclear cells (PBMCs)](https://software.10xgenomics.com/single-cell-gene-expression/datasets/6.0.0/10k_PBMCs_TotalSeq_B_3p.)
These data include both single cell RNA-seq counts and quantification of antibody-derived tags (ADTs) performed by sequencing short DNA barcodes attached to specific antibodies. 
This type of ADT sequencing with single cells is commonly known as CITE-seq, after the protocol developed by [Stoeckius _et al._ (2017)](https://doi.org/10.1038/nmeth.4380).  
The antibodies used here are the [The TotalSeqâ„¢-B Human TBNK Cocktail](https://www.biolegend.com/en-us/products/totalseq-b-human-tbnk-cocktail-19043), a set of antibodies designed to react with immune cell surface markers.

The data here have already been filtered, normalized, and had dimension reductions calculated for the scRNA-seq data.
The ADT data has also been separately filtered and normalized.
For details about how to perform these tasks with data that has been processed with Cell Ranger, have a look at our `exercise_01` notebook in this directory.

The processed gene expression and ADT data were saved into a combined `SingleCellExperiment` (SCE) object, and we will start with that object for our exploration here.

## Set Up

To start, we will load some of the libraries we will need later, and set a random number seed for reproducibility.

```{r setup}
# Load libraries
library(magrittr) # the pipe (%>%) operator
library(ggplot2) # plotting functions
library(SingleCellExperiment) # our main class for storing Single Cell data


# Setting the seed for reproducibility
set.seed(12345)
```


### Input and output

As mentioned, our input file here is a single normalized and processed SCE object, stored as an `rds` file. 
That should be all we need to read in!

Our output will be a table of per-cell information, which will include the cell type assignments we have made throughout this notebook.
We aren't planning any significant modifications of the underlying data, so we won't bother re-saving the whole SCE object as a new `.rds` file this time.

```{r filepaths, live=TRUE}
# directory for the input data
data_dir <- file.path("data", "PBMC-TotalSeqB", "normalized")

# the input file itself
sce_file <- file.path(data_dir, "PBMC_TotalSeqB_normalized_sce.rds")

# A directory to store outputs
analysis_dir <- file.path("analysis", "PBMC-TotalSeqB")

# check whether the output directory exists 
if (!dir.exists(analysis_dir)){
  dir.create(analysis_dir, recursive = TRUE)
}

# output table path
cellinfo_file <- file.path(analysis_dir, "PBMC_TotalSeqB_cellinfo.tsv")
```


## Exploring a CITE-seq `SingleCellExperiment`

Now that the preliminary setup is out of the way, we can get started. 
First we will read in the `SingleCellExperiment` from the input file we defined earlier.

```{r read SCE, live=TRUE}
# read in the SCE file
sce <- readr::read_rds(sce_file)
# print a summary of the SCE
sce
```
This should look similar to the SCE objects that we have seen before, containing `counts` and `logcounts` assays where each cell is a column and each row is a gene.
We also have some of the `rowData`, `colData` and reduced dimension matrices that we have seen before.

But where are the data from the ADTs?
We wouldn't necessarily want those stored in the main data matrices, as the characteristics of ADT barcode data is going to be quite different from gene expression data.

To keep the ADT data separate from the RNA gene expression data, we have split this data off into an _alternative experiment_ (`altExp`) slot.
You can see the name of this `altExp` on the line `altExpNames` above. 
We _could_ have more than one type of alternative experiment (such as spike-in or ATAC-seq), but in this case, just the one.

To access the contents of the `altExp` slot, we can use the `altExp()` function.
Let's look at what we have in that slot:

```{r view altExp, live=TRUE}
# print a summary of the 'ADT' altExp
altExp(sce, "ADT")
```

It is another `SingleCellExperiment`! 
Inception!
Let's look at that embedded SCE more closely.

The first thing to note is that this `altExp` has the same number of columns as did the main SCE object. 
Those corresponded to the individual cells before, and still do!

There are only 10 rows, however, and these correspond to the ADTs that were assayed by this particular experiment. 
Just as we did with the full SCE, we can use `rowData()` to view the table containing metadata associated with each of these rows.
We'll add the `altExp()` function to point it to the embedded object we are interested in. 
Since there is only one `altExp`, we don't need the second (name) argument (`"ADT"`) that we used above; the default behavior of `altExp()` is to just give us the first `altExp`, and that is the one (and only) that we need.


```{r adt rows, live=TRUE}
# What proteins were assayed?
adt_tags <- rowData(altExp(sce))
adt_tags
```

You can see here that the names and symbols of the tags used, along with the designation that all have an "Antibody Capture" type (as opposed to "Gene Expression" for the RNA data).
One you might note looks different is the `IgG1` control, which is actually a mouse antibody used as a negative control. 


### Clustering redux

While dimension reduction was performed on this data, we have not yet performed any clustering.

Let's assign some clusters to our cells, using graph-based clustering and default parameters, taking as input the PCA matrix that was previously calculated.
Note that this PCA matrix and the UMAP built from it were derived from the gene expression data, so the clustering is going to reflect the gene expression data only.
While we have the ADT data, it is _not_ being used for this stage of the analysis.


```{r}
# perform clustering
nn_clusters <- bluster::clusterRows(
  # PCA input
  reducedDim(sce, "PCA"), 
  # graph clustering & parameters
  bluster::NNGraphParam()
)

# add clusters to colData
sce$nn_cluster <- nn_clusters
```

Now we can plot the clusters we have identified with our old friend `scater::plotUMAP()`.

```{r plot clusters}
# plot clusters
scater::plotUMAP(sce, colour_by = "nn_cluster") + 
  # rename the legend
  guides(colour = guide_legend(title = "Cluster"))
```
But what are these clusters, really? 
Do they correspond to particular cell types that we are interested in?

Does it bother you that we just used the default nearest-neighbor graph clustering parameters?
Do you know what those were?


## Investigating cell types

### Using ADT data

The first way we will identify cell types of individual cells is to use the ADT normalized counts.
These antibody markers were (hopefully) chosen for their relevance to the sequenced cell population.

The first marker we will look at is `CD3`, which is a protein complex that is found on the surface of T cells.
We can again use the `plotUMAP()` function to color cells by `CD3` ADT levels. 

Note that this function can plot data from the `colData` table (as we used it above when plotting clusters), in the main gene expression matrix (as we used it in the previous notebook), *AND* in `altExp` tables and matrices!
So to color by the ADT levels (as normalized in the `logcounts` matrix) we only need to provide the tag name that we want to plot in the `colour_by` argument.

```{r plot CD3, live = TRUE}
# plot CD3 expression
scater::plotUMAP(sce, colour_by = "CD3")
```

It appears that we have a number of potential T cells down in the lower left!

Let's look at a couple of other markers to try to break those up more specifically.

Two other markers of relevance to the T cells are `CD4` and `CD8`.
The `CD4` complex is present in helper T cells (hence their other common name, CD4+ T cells).
By contrast, the `CD8` complex is found on killer T cells (CD8+ cells).

Let's plot the ADT results for those two markers as well below:

```{r plot CD4, live=TRUE}
# plot CD4 marker
scater::plotUMAP(sce, 
                 colour_by = "CD4")
```

```{r plot CD8, live=TRUE}
# plot CD8 marker
scater::plotUMAP(sce, 
                 colour_by = "CD8")
```


### Rule-based classification

Plotting the levels of the ADTs provides a nice visual representation, but what we really want to do is to turn these values into specific cell-type assignments for each cell.
Such classification could be considered as analogous to a cell-sorter assay, where we would set up some rules to look at a few markers for each cell and use those to assign a cell type.
The simplest type of rule might be one where we use a threshold to call a marker as present or absent, then to use the presence of a marker to indicate a specific cell type.

To do this, we will need to make some decisions, such as the thresholds should we use to determine whether a cell is or is not expressing a particular marker. 
In general, markers that are useful for this cell-typing approach will have a bimodal distribution of expression levels which can be used to separate the population into two groups of cells.
One group of cells will have only a background level signal for each marker (due to non-specific binding or other factors), while the other group, those that express the protein, will have a much higher level of binding and higher counts.

To assess whether the ADTs we have chosen have a useful distribution of expression values, and to identify thresholds we might use, we would like to plot each ADT tag. To do this, we will pull out the expression values for these markers from the SCE object and do some data wrangling. 

We are interested in the normalized counts for the ADT tags, which are stored in the `logcounts` assay of the `altExp`.
If you recall, this matrix is stored with the columns as cells and rows as markers, but we really want it with each row a cell and each column a marker. 
So we will first transpose the data, then convert it to a data frame for our next steps.
Because the SCE object stores the assay data matrices in a specialized format, we have to do one extra step convert it first to a "regular" R matrix or R won't know how to convert it to a data frame.

```{r extract ADT}
# convert logcounts data to a data frame
adt_df <- logcounts(altExp(sce)) %>%
  t() %>% # transpose
  as.matrix() %>% # convert to matrix
  as.data.frame() # convert to data frame

# view the data frame
head(adt_df)
```

If we just wanted to plot one of these tags, we could do so right away, but with a bit more data wrangling, we can convert these results into a "tidier" format, that will allow us to take full advantage of `tidyverse` tools!
In particular, it will let us plot them all at once with `ggplot2` faceting.

Right now the data is in a "wide" format, such that each column is a different tag. 
But the data in all of the columns is the same type, and measures something similar: the normalized count of an ADT.
One could even argue that each row contains 10 different observations, where the "tidy" data ideal, as espoused by [Wickham (2014)](https://doi.org/10.18637/jss.v059.i10), requires a single observation per row, a "long" format.
This long format will have one column that tells us which ADT was measured and a second column with the measurement value itself.

We can perform this conversion using the [`tidyr::pivot_longer()`](https://tidyr.tidyverse.org/articles/pivot.html) function,
which allows us to convert our data frame with one column per tag into a data frame with separate columns for the tag id (`ADT`) and the expression value (`logcount`).
Following conversion, we will filter to just the ADTs that we care about.

```{r pivot longer, live=TRUE}
adt_df_long <- adt_df %>%
  # pivot to long format
  tidyr::pivot_longer(
    everything(), # use all columns
    names_to = "ADT", # convert row names to a column called "ADT"
    values_to = "logcount" # name the value column "logcount"
  ) %>%
  # filter to tags we are interested in
  dplyr::filter(ADT %in% c("CD3", "CD4", "CD8"))

# look at the resulting df
head(adt_df_long)
```

Now we can make a density plot with `ggplot2` for all three ADTs we are interested in at once.

```{r plot ADTs, live=TRUE}
# plot logcounts by ADT
ggplot(adt_df_long, aes(x = logcount, fill = ADT)) + 
  geom_density() + # density plot
  facet_wrap(~ADT, ncol = 1) + # facet by ADT
  theme_bw() + # nicer theme
  theme(legend.position = "none") # no legend needed
```

These look pretty good!
There seem to be different baseline levels for each of the different tags, but each has a pretty clear bimodal distribution.

We can now use the values from these plots to construct a set of rules to classify the T cells. 
We will do this using the "wide" data frame from earlier. 

The thresholds we are using here were found just "by eye", so this is not a particularly principled method of cell type assignment, but it can be fairly effective.
Here we are assigning only three cell types; cells that do not fit any of these criteria will be set as `NA`.

```{r threshold celltypes}
adt_df <- adt_df %>%
  dplyr::mutate(
    celltype = dplyr::case_when(
      CD3 > 6.7 & CD4 > 8 ~ "CD4+ T-cell",
      CD3 > 6.7 & CD8 > 6 ~ "CD8+ T-cell",
      CD3 > 6.7 ~ "T-cell"
    )
  )
```

Now we will want to add the cell types we have assigned back to our original SCE object.
We can do that by defining a new column name, `threshold_celltype` that will be added to the `colData` object.
Creating and assigning values to this column can be done with the `$` shortcut, and then we can plot our results with the `plotUMAP()` function as before.

```{r plot thresholds}
sce$threshold_celltype <- adt_df$celltype
scater::plotUMAP(sce, 
                 colour_by = "threshold_celltype") + 
  guides(color = guide_legend(title = "Cell type"))
```

How did we do? 

Note that while we applied this technique to assign cell types using the ADT data, we could use the same type of procedure using gene expression data alone, or a combination of gene expression data and tag data.

However, what we did here was very ad-hoc and quite manual!
We didn't calculate any statistics, and we had to look at every tag we were interested in to pick thresholds.
A different data set might have different background levels, which would require different thresholds. 

While this technique might be good for some simple experiments, and can be useful for manual curation, it might not translate well to more complex data sets with multiple samples.
We also looked at each marker separately, which might not be the most efficient or robust method of analysis.

For a more principled approach that allows identification of cell types by looking at the expression of sets of genes that are known to characterize each cell type, you might look at the [`AUCell` package](https://bioconductor.org/packages/release/bioc/html/AUCell.html).
For more on that method, the OSCA chapter [Assigning cell labels from gene sets](http://bioconductor.org/books/3.16/OSCA.basic/cell-type-annotation.html#assigning-cell-labels-from-gene-sets) is a very good reference.



## Cell type annotation with `SingleR`

First, we need some reference data.
Text about importance of reference data goes here!


```{r}
# Don't ask about creating the cache directories, just create them
ExperimentHub::setExperimentHubOption("ASK", FALSE)
AnnotationHub::setAnnotationHubOption("ASK", FALSE)

# Get Data from the Blueprint & Encode projects from celldex
blueprint_encode <- celldex::BlueprintEncodeData(ensembl = TRUE)
```
What is this `blueprint_encode` object?

```{r}
blueprint_encode
```

A `SummarizedExperiment` is very similar to a `SingleCellExperiment`, except rather than having each column as a cell, each column is a sample.
Otherwise, the components are very similar: each row is still a gene, for example, and additional data about the samples
are stored in the `colData`.
In fact, the `SingleCellExperiment` is derived from a `SummarizedExperiment`, with some extra slots that are more relevant to single cell data.

What information do we have for the samples?

```{r}
colData(blueprint_encode)
```

Let's see how many samples of each type we have:

```{r}
data.frame(colData(blueprint_encode)) %>% 
  dplyr::count(label.main, label.fine)
```

### What does `SingleR` do?

`SingleR` builds a model from a set of training data, and then uses that model to classify cells (or groups of cells) in new data sets.
We will show how to separate these results

This time we will do the training and classification in a single step, using the convenience function `SingleR::SingleR()`.

```{r}
singler_result <- SingleR::SingleR(
  sce,
  ref = blueprint_encode,
  labels = blueprint_encode$label.main
)
```

Plot the results:
```{r}
SingleR::plotScoreHeatmap(singler_result)
```


```{r}
sce$celltype_main <- singler_result$pruned.labels
```

```{r}
scater::plotUMAP(sce, colour_by = "celltype_main")
```

This is a pretty clean plot, for which we can thank that this is a PBMC data set.

```{r}
table(singler_result$pruned.labels, useNA = "ifany")
```

 
We can do some cleanup using `forcats`.

```{r}
# combine all of the uncommon cell types
common_labels <- singler_result$pruned.labels %>%
  forcats::fct_lump_min(100)
sce$celltype_common <- common_labels
```


```{r}
scater::plotUMAP(sce, colour_by = "celltype_common")
```

We can also use the finer-grained cell type data.

If we were classifying multiple samples, we would want to do the training only once!

So let's separate the training from the fitting.
First fit the model.

```{r}
singler_finemodel <- SingleR::trainSingleR(
  blueprint_encode,
  labels = blueprint_encode$label.fine,
  # use DE to select genes (default)
  genes = "de", 
  # only use genes in the sce object
  restrict = rownames(sce),
  BPPARAM = BiocParallel::MulticoreParam(4)
)
```

Now classify the cells based on that model.

```{r}
singler_result_fine <- SingleR::classifySingleR(
  sce,
  singler_finemodel,
  BPPARAM = BiocParallel::MulticoreParam(4)
)
```


What labels were assigned, and how many?

```{r}
table(singler_result_fine$pruned.labels, useNA = "ifany")
```

```{r}
sce$celltype_fine <- singler_result_fine$pruned.labels
scater::plotUMAP(sce, colour_by = "celltype_fine")
```

That's a pretty messy plot.
Let's collapse a bit more manually this time. 

```{r}
collapsed_labels <- singler_result_fine$pruned.labels %>%
  forcats::fct_collapse(
    "HSC" = c("CLP","CMP", "GMP", "HSC", "Megakaryocytes", "MEP", "MPP"),
    "B-cells" = c("Class-switched memory B-cells", "Memory B-cells", "naive B-cells", "Plasma cells")
  ) %>%
  # Sort all CD4+ labels together at the start
  forcats::fct_relevel("CD4+ T-cells", "CD4+ Tcm", "CD4+ Tem", "Tregs")
```

Now we plot.

```{r}
sce$celltype_collapsed <- collapsed_labels
scater::plotUMAP(sce, colour_by = "celltype_collapsed")
```


### Heatmap of cell types & clusters


Let's look at how the cell type assignments we have compare to the clusters we found from the data alone.

To do this, we will first use `table` function to build a contingency table of the cell types and clusters that each cell was classified with. 

```{r}
# create a table of clusters & cell type counts
type_cluster_tab <- table(sce$celltype_fine, sce$nn_cluster, useNA = "ifany")
type_cluster_tab
```

Since the number of cells in each cluster will vary, we'd like to convert these counts into proportions. 
We'll do this by dividing each cluster/cell type count by the total number of cells in that cluster.


```{r}
# normalize by the number of cells in each cluster (columns)
type_cluster_tab <- apply(
  type_cluster_tab, 
  2, # apply function to columns
  function(x){x/sum(x)} # function to apply
)
type_cluster_tab
```

Now we can plot these results as a heatmap, using the `pheatmap` package. 
There is a lot of customization we could do here, but `pheatmap` (pretty heatmap) has good defaults, so we won't spend too much time on it for now.

```{r}
# plot with pheatmap
pheatmap::pheatmap(type_cluster_tab)
```



### Classifying by clusters

This section inspired by the fact that `SingleR()` has a `clusters` argument.

First we will make a new matrix where we sum the counts across cells that are from the same type according to our clustering.
The idea here is that we can reduce noise by combining a bunch of cells.

Note that in this case we are using raw counts. 
`SingleR` is non-parametric, so it shouldn't matter! 
(And adding log values felt bad.)

```{r}
sce_cluster_mat <- DelayedArray::colsum(counts(sce), sce$nn_cluster)
dim(sce_cluster_mat)
```

```{r}
singler_result_cluster <- SingleR::classifySingleR(
  sce_cluster_mat, 
  singler_finemodel
)
```

```{r}
singler_result_cluster$labels
```
Add cluster labels to individual cells.

```{r}
sce$celltype_cluster <- singler_result_cluster$labels[sce$nn_cluster]
```

Plot with cluster labels.

```{r}
scater::plotUMAP(sce, colour_by = "celltype_cluster")
```

This sure looks nice, but what have we done here? 
We are _assuming_ that each cluster has only a single cell type!


### MetaCell-like

Inspired by https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1812-2 
(I may refine to match methods better, but maybe this is good enough?)

Alternatively cluster cells with a fast algorithm to find neighbors, then assign types to those. 
We have ~8000 cells, so lets cluster those into groups of ~40 cells, which means we want to make about 200 clusters.

A quick way to do this is with k-means clustering.

```{r}
kclusters <- bluster::clusterRows(
  reducedDim(sce, "PCA"), 
  bluster::KmeansParam(
    centers = 200,
    iter.max = 100 # more iterations to be sure of convergence
  )
)
```

Now apply the same procedure, using these clusters:

```{r}
kcluster_mat <- DelayedArray::colsum(counts(sce), kclusters)
kcluster_result <- SingleR::classifySingleR(
  kcluster_mat, 
  singler_finemodel
  )

sce$celltype_kcluster <- kcluster_result$labels[kclusters]
```

```{r}
scater::plotUMAP(sce, colour_by = "celltype_kcluster")
```

### Save results

To save space, we won't write out the whole SCE object, as we haven't changed any of the core data there. 
Instead we will just write out the cell information table (`colData`) as a TSV file.

```{r save sce}
readr::write_tsv(as.data.frame(colData(sce)), file = cellinfo_file)
```


## Session Info

```{r session info}
sessionInfo()
```

