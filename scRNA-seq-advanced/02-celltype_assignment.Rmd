---
title: "Assigning Cell Types"
author: Data Lab for ALSF
date: 2022
output:
  html_notebook: 
    toc: true
    toc_float: true
---

## Objectives

This notebook will demonstrate how to:

- 

---

In this notebook, we will attempt to assign cell types to each of the cells in a dataset, using some of the automated tools that are available within the Bioconductor universe.


Much of the material in this notebook is directly inspired by, and draws heavily on, material presented in the book [_Orchestrating Single Cell Analysis with Bioconductor_](http://bioconductor.org/books/3.16/OSCA/). 

The data we will use for this notebook is derived from a 10x Genomics Dataset: https://software.10xgenomics.com/single-cell-gene-expression/datasets/6.0.0/10k_PBMCs_TotalSeq_B_3p. 
The data here have already been filtered, normalized, and had dimension reductions calculated.

In addition to gene expression data, this data set includes data from antibody-derived tags (ADTs) which are used to mark cell-surface proteins. 

## Set Up

To start, we will load some of the libraries we will need later, and set a random number seed for reproducibility.

```{r setup}
# Load libraries
library(magrittr) # the pipe (%>%) operator
library(ggplot2) # plotting functions
library(SingleCellExperiment) # our main class for storing Single Cell data


# Setting the seed for reproducibility
set.seed(12345)
```


### Input and output

```{r}
data_dir <- file.path("data", "PBMC-TotalSeqB", "normalized")
sce_file <- file.path(data_dir, "PBMC_TotalSeqB_normalized_sce.rds")
```


Read in the SingleCellExperiment
```{r}
sce <- readRDS(sce_file)
```


Let's explore what is in the SCE already:

```{r}
sce
```

Notice the `altExpNames`?
Those are the ADT data, stored as an _Alternative Experiment_.
To access these, we can use the `altExp()` function. 
Let's look at what we have in that slot:

```{r}
altExp(sce, "ADT")
```


Ah! Another SingleCellExperiment! Inception!
Since there is only one `altExp`, the second argument is optional, so we won't use it for the rest of this notebook.
Here the columns are again the cells, but now the rows are the proteins that were assayed with the antibodies and tags.

```{r}
# What proteins were assayed?
adt_tags <- rownames(altExp(sce))
adt_tags
```


### Clustering redux

These data don't have clusters assigned yet, so let's add those, using the PCA matrix we have for the gene expression data.


```{r}
# perform clustering
nn_k <- 20
nn_clusters <- bluster::clusterRows(
  reducedDim(sce, "PCA"), 
  bluster::NNGraphParam(
    k = nn_k, 
    type = "jaccard",
    cluster.fun = "louvain"
  )
)

# add clusters to colData
sce$nn_cluster <- nn_clusters
```

```{r}
scater::plotUMAP(sce, 
                 colour_by = "nn_cluster")
```
But what are these clusters? Do they correspond to cell types?

## Cell surface markers

The markers we have were presumably chosen for the fact that they mark particular cell types, so let's look at a few.

CD3 is a marker of T-cells 

```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD3")
```

CD4+ T-cells

```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD4")
```
CD8+ T-cells

```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD8")
```

Looking at all of the markers here, but we probably don't want to do this, as we haven't introduced `purrr` yet.
```{r}
all_plots <- adt_tags %>%
  purrr::map(~ scater::plotUMAP(sce, colour_by = .))

patchwork::wrap_plots(all_plots)
```


So one thing we could do is construct a set of rules based on ADT tags, similar to how you might set gating rules for cell sorting.



What thresholds should we use?
If this is a useful marker, we should see a bimodal plot of the marked density.

We'll do a bit of wrangling to pull out the ADT data, transpose it so each row is a cell,
then convert it into a data frame for plotting. 
(We have to first convert to a "regular" R matrix or R won't know how to convert it to a data frame)

```{r}
# convert to a data frame
adt_df <- logcounts(altExp(sce)) %>%
  t() %>% 
  as.matrix() %>%
  as.data.frame()
```
Now we can make a density plot with `ggplot2`!

```{r}
ggplot(adt_df, aes(x = CD3)) + 
  geom_density() +
  theme_bw()
```

Looking at a few of tehse, we can define some rough cutoffs.
This is very manual and not particulary principled, but it _is_ a potential way to assign cell types.

```{r}
adt_df <- adt_df %>%
  dplyr::mutate(
    celltype = dplyr::case_when(
      CD3 > 6.7 & CD4 > 8 ~ "CD4+ T cell",
      CD3 > 6.7 & CD8 > 6 ~ "CD8+ T cell",
      CD3 > 6.7 ~ "T cell"
    )
  )
```

```{r}
sce$threshold_celltype <- adt_df$celltype
scater::plotUMAP(sce, 
                 colour_by = "threshold_celltype")
```

We could do similar things for any marker gene from the expression data as well.

A more careful version of this is AUCell... do we want to introduce this?


## Cell type annotation with SingleR

Get some cell data
```{r}
# Don't ask about creating the cache directories, just create them
ExperimentHub::setExperimentHubOption("ASK", FALSE)
AnnotationHub::setAnnotationHubOption("ASK", FALSE)

# Get Data from the Blueprint & Encode projects from celldex
blueprint_encode <- celldex::BlueprintEncodeData(ensembl = TRUE)
```
What is this `blueprint_encode`?

```{r}
blueprint_encode
```

A SummarizedExperiment is very similar to a SingleCellExperiment, except rather than having each column as a cell, each column is a sample.
Otherwise, the components are very similar: each row is still a gene, for example, and additional data about the samples
are stored in the `colData`.

What information do we have for the samples?

```{r}
colData(blueprint_encode)
```

Let's see how many samples of each type we have:

```{r}
data.frame(colData(blueprint_encode)) %>% 
  dplyr::count(label.main, label.fine)
```

### What does SingleR do?

First we build a model that we can use for classifying expression.
Some options we might explore: how to find choose genes to include in the model.
`genes = "de"` is the default, using genes differentially expressed among the labels
`genes = "sd"`uses genes with the most variability across the data set.

This time we will do the training and classification in a single step, using the convenience function `SingleR::SingleR()`.

```{r}
singler_result <- SingleR::SingleR(
  sce,
  ref = blueprint_encode,
  labels = blueprint_encode$label.main
)
```

Plot the results:
```{r}
SingleR::plotScoreHeatmap(singler_result)
```


```{r}
sce$celltype_main <- singler_result$pruned.labels
```

```{r}
scater::plotUMAP(sce, colour_by = "celltype_main")
```

```{r}
table(singler_result$pruned.labels)
```

We can do some cleanup using `forcats`.

```{r}
# combine all of the uncommon cell types
common_labels <- singler_result$pruned.labels %>%
  forcats::fct_lump_min(100)
sce$celltype_common <- common_labels
```


```{r}
scater::plotUMAP(sce, colour_by = "celltype_common")
```

We can also use the finer-grained cell type data.

If we were classifying multiple samples, we would want to do the training only once!

So let's separate the training from the fitting.
First fit the model.

```{r}
singler_finemodel <- SingleR::trainSingleR(
  blueprint_encode,
  labels = blueprint_encode$label.fine,
  # use DE to select genes (default)
  genes = "de", 
  # only use genes in the sce object
  restrict = rownames(sce),
  BPPARAM = BiocParallel::MulticoreParam(4)
)
```

Now classify the cells based on that model.

```{r}
singler_result_fine <- SingleR::classifySingleR(
  sce,
  singler_finemodel,
  BPPARAM = BiocParallel::MulticoreParam(4)
)
```


What labels were assigned, and how many?

```{r}
table(singler_result_fine$labels)
```

```{r}
sce$celltype_fine <- singler_result_fine$pruned.labels
scater::plotUMAP(sce, colour_by = "celltype_fine")
```

That's a pretty messy plot.
Let's collapse a bit more manually this time. 

```{r}
collapsed_labels <- singler_result_fine$pruned.labels %>%
  forcats::fct_collapse(
    "HSC" = c("CLP","CMP", "GMP", "HSC", "Megakaryocytes", "MEP", "MPP"),
    "B-cells" = c("Class-switched memory B-cells", "Memory B-cells", "naive B-cells", "Plasma cells")
  ) %>%
  # Sort all CD4+ labels together at the start
  forcats::fct_relevel("CD4+ T-cells", "CD4+ Tcm", "CD4+ Tem", "Tregs")
```

Now we plot.

```{r}
sce$celltype_collapsed <- collapsed_labels
scater::plotUMAP(sce, colour_by = "celltype_collapsed")
```


### Heatmap of cell types & clusters





### Classifying by clusters

This section inspired by the fact that `SingleR()` has a `clusters` argument.

First we will make a new matrix where we sum the counts across cells that are from the same type according to our clustering.
The idea here is that we can reduce noise by combining a bunch of cells.

Note that in this case we are using raw counts. 
SingleR is non-parametric, so it shouldn't matter! 
(And adding logcounts felt bad.)

```{r}
sce_cluster_mat <- DelayedArray::colsum(counts(sce), sce$nn_cluster)
dim(sce_cluster_mat)
```

```{r}
singler_result_cluster <- SingleR::classifySingleR(
  sce_cluster_mat, 
  singler_finemodel
  )
```

```{r}
singler_result_cluster$labels
```
Add cluster labels to individual cells.

```{r}
sce$celltype_cluster <- singler_result_cluster$labels[sce$nn_cluster]
```

Plot with cluster labels.

```{r}
scater::plotUMAP(sce, colour_by = "celltype_cluster")
```

### MetaCellish

Alternatively cluster cells with a fast algorithm to find neighbors, then assign types to those. 
We have ~8000 cells, so lets cluster those into groups of ~40 cells, which means we want to make about 200 clusters.

A quick way to do this is with k-means clustering.

```{r}
kclusters <- bluster::clusterRows(
  reducedDim(sce, "PCA"), 
  bluster::KmeansParam(
    centers = 200,
    iter.max = 100 # more iterations to be sure of convergence
  )
)
```

Now apply the same procedure, using these clusters:

```{r}
kcluster_mat <- DelayedArray::colsum(counts(sce), kclusters)
kcluster_result <- SingleR::classifySingleR(
  kcluster_mat, 
  singler_finemodel
  )

sce$celltype_kcluster <- kcluster_result$labels[kclusters]
```

```{r}
scater::plotUMAP(sce, colour_by = "celltype_kcluster")
```

## Session Info

```{r session info}
sessionInfo()
```

