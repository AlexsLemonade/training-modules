---
title: "Assigning Cell Types"
author: Data Lab for ALSF
date: 2022
output:
  html_notebook: 
    toc: true
    toc_float: true
---

## Objectives

This notebook will demonstrate how to:

- 

---

In this notebook, we will attempt to assign cell types to each of the cells in a dataset, using some of the automated tools that are available within the Bioconductor universe.

Much of the material in this notebook is directly inspired by, and draws heavily on, material presented in the book [_Orchestrating Single Cell Analysis with Bioconductor_](http://bioconductor.org/books/3.16/OSCA/). 

The data we will use for this notebook is derived from a [10x Genomics dataset of human peripheral blood mononuclear cells (PBMCs)](https://software.10xgenomics.com/single-cell-gene-expression/datasets/6.0.0/10k_PBMCs_TotalSeq_B_3p.)
These data include both single cell RNA-seq counts and quantification of antibody-derived tags (ADTs) performed by sequencing short DNA barcodes attached to specific antibodies. 
This type of ADT sequencing with single cells is commonly known as CITE-seq, after the protocol developed by [Stoeckius _et al._ (2017)](https://doi.org/10.1038/nmeth.4380).  
The antibodies used here are the [The TotalSeqâ„¢-B Human TBNK Cocktail](https://www.biolegend.com/en-us/products/totalseq-b-human-tbnk-cocktail-19043), a set of antibodies designed to react with immune cell surface markers.

The data here have already been filtered, normalized, and had dimension reductions calculated for the scRNA-seq data.
The ADT data has also been separately filtered and normalized.
For details about how to these tasks were performed with data that has been processed with Cell Ranger, have a look at our `exercise_01` notebook in this directory.

The processed gene expression and ADT data were saved into a combined `SingleCellExperiment` (SCE) object, and we will start with that object for our exploration here.

## Set Up

To start, we will load some of the libraries we will need later, and set a random number seed for reproducibility.

```{r setup}
# Load libraries
library(magrittr) # the pipe (%>%) operator
library(ggplot2) # plotting functions
library(SingleCellExperiment) # our main class for storing Single Cell data


# Setting the seed for reproducibility
set.seed(12345)
```


### Input and output

As mentioned, our input file here is a single normalized and processed SCE object, stored as an `rds` file. 
That should be all we need to read in!

Our output will be a table of per-cell information, which will include the cell type assignments we have made throughout this notebook.
We aren't planning any significant modifications of the underlying data, so we won't bother re-saving it as a new object this time.

```{r filepaths, live=TRUE}
# directory for the input data
data_dir <- file.path("data", "PBMC-TotalSeqB", "normalized")

# the input file itself
sce_file <- file.path(data_dir, "PBMC_TotalSeqB_normalized_sce.rds")

# A directory to store outputs
analysis_dir <- file.path("analysis", "PBMC-TotalSeqB")

# check whether the output directory exists 
if (!dir.exists(analysis_dir)){
  dir.create(analysis_dir, recursive = TRUE)
}

# output table path
cellinfo_file <- file.path(analysis_dir, "PBMC_TotalSeqB_cellinfo.tsv")
```


## Exploring a CITE-seq `SingleCellExperiment`

Now that the preliminary setup is out of the way, we can get started. 
First we will read in the `SingleCellExperiment` from the input file we defined earlier.

```{r read SCE, live=TRUE}
# read in the SCE file
sce <- readRDS(sce_file)
# print a summary of the SCE
sce
```
This should look similar to the SCE objects that we have seen before, containing `counts` and `logcounts` assays where each cell is a column and each row is a gene.
We also have some of the `rowData`, `colData` and reduced dimension matrices that we have seen before.

But where are the data from the ADTs?
We wouldn't necessarily want those stored in the main data matrices, as the characteristics of ADT barcode data is going to be quite different from gene expression data.

To keep the ADT data separate, we have split this data off into an _alternative experiment_ (`altExp`) slot.
You can see the name of this `altExp` on the line `altExpNames` above. 
We _could_ have more than one type of alternative experiment, but in this case, just the one.

To access the contents of the `altExp` slot, we can use the `altExp()` function.
Let's look at what we have in that slot:

```{r view altExp, live=TRUE}
altExp(sce, "ADT")
```

It is another `SingleCellExperiment`! 
Inception!
Let's look at that embedded SCE more closely.

The first thing to note is that we have the same number of columns for this `altExp` as we did with the full SCE. 
Those corresponded to the individual cells before, and still do!

There are only 10 rows, however, and these now correspond to the ADTs that were assayed by this particular experiment. 
Just as we did with the full SCE, we can use `rowData()` to look at table of metadata for each of these rows.
We'll add the `altExp()` function to point it to the embedded object we are interested in. 
Since there is only one `altExp`, we don't need the second argument (`"ADT"`) that we used above; the default behavior of `altExp()` is to just give us the first `altExp`, and that is all we need.


```{r adt rows, live=TRUE}
# What proteins were assayed?
adt_tags <- rowData(altExp(sce))
adt_tags
```

You can see here that the names and symbols of the tags used, along with the designation that all have an "Antibody Capture" type.
One you might note looks different is the `IgG1` control, which is actually a mouse antibody used as a negative control. 


### Clustering redux

While these data did have dimension reduction performed, they were not analyzed for clustering yet.

Let's assign some clusters to our cells, using graph-based clustering and default parameters, taking as input the PCA matrix that was previously calculated.
Note that this PCA matrix and the UMAP built from it were derived from the gene expression data, so the clustering is going to reflect the gene expression data only.
While we have the ADT data, it is _not_ being used for this stage of the analysis.


```{r}
# perform clustering
nn_clusters <- bluster::clusterRows(
  # PCA input
  reducedDim(sce, "PCA"), 
  # graph clustering & parameters
  bluster::NNGraphParam()
)

# add clusters to colData
sce$nn_cluster <- nn_clusters
```

Now we can plot the clusters we have identified with our old friend `scater::plotUMAP()`.

```{r, }
scater::plotUMAP(sce, 
                 colour_by = "nn_cluster")
```
But what are these clusters? 
Do they correspond to particular cell types that we are interested in?


## Using cell surface marker data

The markers we have were presumably chosen for the fact that they mark particular cell types, so let's look at a few.

CD3 is a marker of T-cells 

```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD3")
```

CD4+ T-cells

```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD4")
```
CD8+ T-cells

```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD8")
```


So one thing we could do is construct a set of rules based on ADT tags, similar to how you might set gating rules for cell sorting.


What thresholds should we use?
If this is a useful marker, we should see a bimodal plot of the marker density.

We'll do a bit of wrangling to pull out the ADT data, transpose it so each row is a cell,
then convert it into a data frame for plotting. 
(We have to first convert to a "regular" R matrix or R won't know how to convert it to a data frame)

```{r}
# convert to a data frame
adt_df <- logcounts(altExp(sce)) %>%
  t() %>% 
  as.matrix() %>%
  as.data.frame()
```

With a bit more wrangling, we can put the expression data for the three tags we care about into a single column, which will allow us to plot all three together a bit more neatly.
Here we are using the `tidyr::pivot_longer()` function, which allows us to convert our data frame with one column per tag into a data frame with separate columns for the tag id (`ADT`) and the expression value (`logcount`).

```{r}
adt_df_long <- adt_df %>%
  dplyr::select(c("CD3", "CD4", "CD8")) %>%
  tidyr::pivot_longer(everything(), names_to = "ADT", values_to = "logcount")
```


Now we can make a density plot with `ggplot2`!

```{r}
ggplot(adt_df_long, aes(x = logcount, fill = ADT)) + 
  geom_density() +
  scale_x_continuous(breaks = seq(0, 10, by = 2)) + 
  facet_wrap(~ADT, ncol = 1) +
  theme_bw() +
  theme(legend.position = "none")
```

Looking at a few of these, we can define some rough cutoffs.
This is very manual and not particularly principled, but it _is_ a potential way to assign cell types.

```{r}
adt_df <- adt_df %>%
  dplyr::mutate(
    celltype = dplyr::case_when(
      CD3 > 6.7 & CD4 > 8 ~ "CD4+ T-cell",
      CD3 > 6.7 & CD8 > 6 ~ "CD8+ T-cell",
      CD3 > 6.7 ~ "T-cell"
    )
  )
```

```{r}
sce$threshold_celltype <- adt_df$celltype
scater::plotUMAP(sce, 
                 colour_by = "threshold_celltype")
```

We could do similar things for any marker gene from the expression data as well.

While we did this in a fairly ad-hoc manner, there are some more principled versions of this technique.
One of those is found in the [`AUCell` package](https://bioconductor.org/packages/release/bioc/html/AUCell.html), which allows identification of groups of cells based on their expression of sets of genes.


## Cell type annotation with `SingleR`

First, we need some reference data.
Text about importance of reference data goes here!


```{r}
# Don't ask about creating the cache directories, just create them
ExperimentHub::setExperimentHubOption("ASK", FALSE)
AnnotationHub::setAnnotationHubOption("ASK", FALSE)

# Get Data from the Blueprint & Encode projects from celldex
blueprint_encode <- celldex::BlueprintEncodeData(ensembl = TRUE)
```
What is this `blueprint_encode` object?

```{r}
blueprint_encode
```

A `SummarizedExperiment` is very similar to a `SingleCellExperiment`, except rather than having each column as a cell, each column is a sample.
Otherwise, the components are very similar: each row is still a gene, for example, and additional data about the samples
are stored in the `colData`.
In fact, the `SingleCellExperiment` is derived from a `SummarizedExperiment`, with some extra slots that are more relevant to single cell data.

What information do we have for the samples?

```{r}
colData(blueprint_encode)
```

Let's see how many samples of each type we have:

```{r}
data.frame(colData(blueprint_encode)) %>% 
  dplyr::count(label.main, label.fine)
```

### What does `SingleR` do?

`SingleR` builds a model from a set of training data, and then uses that model to classify cells (or groups of cells) in new data sets.
We will show how to separate these results

This time we will do the training and classification in a single step, using the convenience function `SingleR::SingleR()`.

```{r}
singler_result <- SingleR::SingleR(
  sce,
  ref = blueprint_encode,
  labels = blueprint_encode$label.main
)
```

Plot the results:
```{r}
SingleR::plotScoreHeatmap(singler_result)
```


```{r}
sce$celltype_main <- singler_result$pruned.labels
```

```{r}
scater::plotUMAP(sce, colour_by = "celltype_main")
```

This is a pretty clean plot, for which we can thank that this is a PBMC data set.

```{r}
table(singler_result$pruned.labels, useNA = "ifany")
```

 
We can do some cleanup using `forcats`.

```{r}
# combine all of the uncommon cell types
common_labels <- singler_result$pruned.labels %>%
  forcats::fct_lump_min(100)
sce$celltype_common <- common_labels
```


```{r}
scater::plotUMAP(sce, colour_by = "celltype_common")
```

We can also use the finer-grained cell type data.

If we were classifying multiple samples, we would want to do the training only once!

So let's separate the training from the fitting.
First fit the model.

```{r}
singler_finemodel <- SingleR::trainSingleR(
  blueprint_encode,
  labels = blueprint_encode$label.fine,
  # use DE to select genes (default)
  genes = "de", 
  # only use genes in the sce object
  restrict = rownames(sce),
  BPPARAM = BiocParallel::MulticoreParam(4)
)
```

Now classify the cells based on that model.

```{r}
singler_result_fine <- SingleR::classifySingleR(
  sce,
  singler_finemodel,
  BPPARAM = BiocParallel::MulticoreParam(4)
)
```


What labels were assigned, and how many?

```{r}
table(singler_result_fine$pruned.labels, useNA = "ifany")
```

```{r}
sce$celltype_fine <- singler_result_fine$pruned.labels
scater::plotUMAP(sce, colour_by = "celltype_fine")
```

That's a pretty messy plot.
Let's collapse a bit more manually this time. 

```{r}
collapsed_labels <- singler_result_fine$pruned.labels %>%
  forcats::fct_collapse(
    "HSC" = c("CLP","CMP", "GMP", "HSC", "Megakaryocytes", "MEP", "MPP"),
    "B-cells" = c("Class-switched memory B-cells", "Memory B-cells", "naive B-cells", "Plasma cells")
  ) %>%
  # Sort all CD4+ labels together at the start
  forcats::fct_relevel("CD4+ T-cells", "CD4+ Tcm", "CD4+ Tem", "Tregs")
```

Now we plot.

```{r}
sce$celltype_collapsed <- collapsed_labels
scater::plotUMAP(sce, colour_by = "celltype_collapsed")
```


### Heatmap of cell types & clusters


Let's look at how the cell type assignments we have compare to the clusters we found from the data alone.

To do this, we will first use `table` function to build a contingency table of the cell types and clusters that each cell was classified with. 

```{r}
# create a table of clusters & cell type counts
type_cluster_tab <- table(sce$celltype_fine, sce$nn_cluster, useNA = "ifany")
type_cluster_tab
```

Since the number of cells in each cluster will vary, we'd like to convert these counts into proportions. 
We'll do this by dividing each cluster/cell type count by the total number of cells in that cluster.


```{r}
# normalize by the number of cells in each cluster (columns)
type_cluster_tab <- apply(
  type_cluster_tab, 
  2, # apply function to columns
  function(x){x/sum(x)} # function to apply
)
type_cluster_tab
```

Now we can plot these results as a heatmap, using the `pheatmap` package. 
There is a lot of customization we could do here, but `pheatmap` (pretty heatmap) has good defaults, so we won't spend too much time on it for now.

```{r}
# plot with pheatmap
pheatmap::pheatmap(type_cluster_tab)
```



### Classifying by clusters

This section inspired by the fact that `SingleR()` has a `clusters` argument.

First we will make a new matrix where we sum the counts across cells that are from the same type according to our clustering.
The idea here is that we can reduce noise by combining a bunch of cells.

Note that in this case we are using raw counts. 
`SingleR` is non-parametric, so it shouldn't matter! 
(And adding log values felt bad.)

```{r}
sce_cluster_mat <- DelayedArray::colsum(counts(sce), sce$nn_cluster)
dim(sce_cluster_mat)
```

```{r}
singler_result_cluster <- SingleR::classifySingleR(
  sce_cluster_mat, 
  singler_finemodel
)
```

```{r}
singler_result_cluster$labels
```
Add cluster labels to individual cells.

```{r}
sce$celltype_cluster <- singler_result_cluster$labels[sce$nn_cluster]
```

Plot with cluster labels.

```{r}
scater::plotUMAP(sce, colour_by = "celltype_cluster")
```

This sure looks nice, but what have we done here? 
We are _assuming_ that each cluster has only a single cell type!


### MetaCell-like

Inspired by https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1812-2 
(I may refine to match methods better, but maybe this is good enough?)

Alternatively cluster cells with a fast algorithm to find neighbors, then assign types to those. 
We have ~8000 cells, so lets cluster those into groups of ~40 cells, which means we want to make about 200 clusters.

A quick way to do this is with k-means clustering.

```{r}
kclusters <- bluster::clusterRows(
  reducedDim(sce, "PCA"), 
  bluster::KmeansParam(
    centers = 200,
    iter.max = 100 # more iterations to be sure of convergence
  )
)
```

Now apply the same procedure, using these clusters:

```{r}
kcluster_mat <- DelayedArray::colsum(counts(sce), kclusters)
kcluster_result <- SingleR::classifySingleR(
  kcluster_mat, 
  singler_finemodel
  )

sce$celltype_kcluster <- kcluster_result$labels[kclusters]
```

```{r}
scater::plotUMAP(sce, colour_by = "celltype_kcluster")
```

### Save results

To save space, we won't write out the whole SCE object, as we haven't changed any of the core data there. 
Instead we will just write out the cell information table (`colData`) as a TSV file.

```{r save sce}
readr::write_tsv(as.data.frame(colData(sce)), file = cellinfo_file)
```


## Session Info

```{r session info}
sessionInfo()
```

