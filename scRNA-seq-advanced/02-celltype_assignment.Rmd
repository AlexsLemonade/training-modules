---
title: "Assigning Cell Types"
author: Data Lab for ALSF
date: 2022
output:
  html_notebook: 
    toc: true
    toc_float: true
---

## Objectives

This notebook will demonstrate how to:

- 

---

In this notebook, we will review basic processing for single-cell RNA-seq data, starting with the output from Cell Ranger, and proceeding through filtering, quality control, normalization, and dimension reduction. We will perform these tasks using tools from the [Bioconductor project](https://bioconductor.org), in particular [`SingleCellExperiment` objects](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) and functions that work with those objects.
Much of the material in this notebook is directly inspired by, and draws heavily on, material presented in the book [_Orchestrating Single Cell Analysis with Bioconductor_](http://bioconductor.org/books/3.16/OSCA/). 

The data we will use for this notebook is derived from a 10x Genomics Dataset: https://software.10xgenomics.com/single-cell-gene-expression/datasets/6.0.0/10k_PBMCs_TotalSeq_B_3p. 

## Set Up

To start, we will load some of the libraries we will need later, and set a random number seed for reproducibility.

```{r setup}
# Load libraries
library(magrittr) # the pipe (%>%) operator
library(ggplot2) # plotting functions
library(SingleCellExperiment) # our main class for storing Single Cell data


# Setting the seed for reproducibility
set.seed(12345)
```


### Input and output

```{r}
data_dir <- file.path("data", "PBMC-TotalSeqB", "normalized")
sce_file <- file.path(data_dir, "PBMC_TotalSeqB_normalized_sce.rds")
```


Read in the SingleCellExperiment
```{r}
sce <- readRDS(sce_file)
```


Let's explore what is in the SCE:

```{r}
sce
```
What do we have in the colData (cell information)?

```{r}
names(colData(sce))
```


```{r}
# What proteins were assayed?
adt_tags <- rownames(altExp(sce))
adt_tags
```


## Clustering redux

```{r}
# perform clustering
nn_k <- 20
nn_clusters <- bluster::clusterRows(
  reducedDim(sce, "PCA"), 
  bluster::NNGraphParam(
    k = nn_k, 
    type = "jaccard",
    cluster.fun = "louvain"
  )
)

# add clusters to colData
sce$nn_cluster <- nn_clusters
```

```{r}
scater::plotUMAP(sce, 
                 colour_by = "nn_cluster")
```
But what are these clusters? Do they correspond to cell types?

## Cell surface markers

The markers we have were presumably chosen for the fact that they mark particular cell types, so let's look at a few.

CD3 is a marker of T-cells 
```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD3")
```

CD4+ T cells

```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD4")
```

```{r}
scater::plotUMAP(sce, 
                 colour_by = "CD8")
```
```{r}
all_plots <- adt_tags %>%
  purrr::map(~ scater::plotUMAP(sce, colour_by = .))

patchwork::wrap_plots(all_plots)
```


So one thing we could do is construct a set of rules based on ADT tags, similar to how you might set gating rules for cell sorting.


```{r}
# convert to a data frame
adt_df <- logcounts(altExp(sce)) %>%
  t() %>% 
  as.matrix() %>%
  as.data.frame()
```

What thresholds should we use?

```{r}
ggplot(adt_df, aes(x = CD3)) + geom_density()
```


```{r}
adt_df <- adt_df %>%
  dplyr::mutate(
    celltype = dplyr::case_when(
      CD3 > 6.7 & CD4 > 8 ~ "CD4+ T cell",
      CD3 > 6.7 & CD8 > 6 ~ "CD8+ T cell",
      CD3 > 6.7 ~ "T cell"
    )
  )
```

```{r}
sce$threshold_celltype <- adt_df$celltype
scater::plotUMAP(sce, 
                 colour_by = "threshold_celltype")
```

We could do similar things for any marker gene from the expression data as well.


## Cell type annotation with SingleR

Get some cell data
```{r}
# Don't ask about creating the cache directories, just create them
ExperimentHub::setExperimentHubOption("ASK", FALSE)
AnnotationHub::setAnnotationHubOption("ASK", FALSE)

# Get Data from the Blueprint & Encode projects from celldex
be_data <- celldex::BlueprintEncodeData(ensembl = TRUE)
```
What is this `be_data`?

```{r}
be_data
```

Explore the sample data:

```{r}
colData(be_data)
```


```{r}
data.frame(colData(be_data)) %>% 
  dplyr::count(label.fine, label.main)
```

### What does SingleR do?


First we build a model that we can use for classifying expression.
Some options we might explore: how to find choose genes to include in the model.
`genes = "de"` is the default, using genes differentially expressed among the labels
`genes = "sd"`uses genes with the most variability across the data set.

This time we will do the training and classification in a single step, using the convenience function `SingleR::SingleR()`.

```{r}
singler_result <- SingleR::SingleR(
  sce,
  ref = be_data,
  labels = be_data$label.main
)
```

Plot the results:
```{r}
SingleR::plotScoreHeatmap(singler_result)
```


```{r}
sce$celltype_main <- singler_result$pruned.labels
```

```{r}
scater::plotUMAP(sce, colour_by = "celltype_main")
```

```{r}
table(singler_result$pruned.labels)
```

```{r}
# combine all of the uncommon cell types
common_labels <- singler_result$pruned.labels %>%
  forcats::fct_lump_min(100)
sce$celltype_common <- common_labels
```


```{r}
scater::plotUMAP(sce, colour_by = "celltype_common")
```

We can also use the finer-grained cell type data.

If we were classifying multiple samples, we would want to do the training only once!

As thi

```{r}
singler_finemodel <- SingleR::trainSingleR(
  be_data,
  labels = be_data$label.fine,
  # use DE to select genes (default)
  genes = "de", 
  # only use genes in the sce object
  restrict = rownames(sce),
  BPPARAM = BiocParallel::MulticoreParam(4)
)
```

Now fit the model

```{r}
singler_result_fine <- SingleR::classifySingleR(
  sce,
  singler_finemodel,
  BPPARAM = BiocParallel::MulticoreParam(4)
)
```



```{r}
sort(unique(singler_result_fine$labels))
```
```{r}
singler_result_fine <- SingleR::SingleR(
  sce,
  ref = be_data,
  labels = be_data$label.fine
)
```


```{r}
sce$celltype_fine <- singler_result_fine$pruned.labels
scater::plotUMAP(sce, colour_by = "celltype_fine")
```

What are the counts for each of these labels?
```{r}
table(singler_result_fine$labels)
```

```{r}
collapsed_labels <- singler_result_fine$pruned.labels %>%
  forcats::fct_collapse(
    "HSC" = c("CLP","CMP", "GMP", "HSC", "Megakaryocytes", "MEP", "MPP"),
    "B-cells" = c("Class-switched memory B-cells", "Memory B-cells", "naive B-cells", "Plasma cells")
  ) %>%
  # Sort all CD4+ labels together at the start
  forcats::fct_relevel("CD4+ T-cells", "CD4+ Tcm", "CD4+ Tem", "Tregs")
```



```{r}
sce$celltype_collapsed <- collapsed_labels
scater::plotUMAP(sce, colour_by = "celltype_collapsed")
```




### Operating on clusters

```{r}
sce_cluster_mat <- DelayedArray::colsum(logcounts(sce), sce$nn_cluster)
dim(sce_cluster_mat)
```

```{r}
singler_result_cluster <- SingleR::classifySingleR(
  sce_cluster_mat, 
  singler_finemodel
  )
```

```{r}
singler_result_cluster$labels
```
Add cluster labels to individual cells.

```{r}
sce$celltype_cluster <- singler_result_cluster$labels[sce$nn_cluster]
```

Plot with cluster labels.

```{r}
scater::plotUMAP(sce, colour_by = "celltype_cluster")
```

### MetaCellish

Alternatively cluster cells with a fast algorithm to find neighbors, then assign types to those. 
We have ~8000 cells, so lets cluster those into groups of ~40 cells, which means we want to make about 200 clusters.

A quick way to do this is with k-means clustering.
```{r}
kclusters <- bluster::clusterRows(
  reducedDim(sce, "PCA"), 
  bluster::KmeansParam(
    centers = 200,
    iter.max = 100
  )
)
```

Now apply the same procedure, using these clusters:

```{r}
kcluster_mat <- DelayedArray::colsum(logcounts(sce), kclusters)
kcluster_result <- SingleR::classifySingleR(
  kcluster_mat, 
  singler_finemodel
  )

sce$celltype_kcluster <- kcluster_result$labels[kclusters]
```

```{r}
scater::plotUMAP(sce, colour_by = "celltype_kcluster")
```

## Session Info

```{r session info}
sessionInfo()
```

