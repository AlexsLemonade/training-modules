---
title: "Reading and filtering scRNA-seq data"
author: Data Lab for ALSF
date: 2022
output:
  html_notebook: 
    toc: true
    toc_float: true
---

## Objectives

This notebook will demonstrate how to:

- Read Cell Ranger data into R
- Filter to cells using `emptyDropsCellRanger()`
- Calculate quality control measures
- Remove likely compromised cells with `miQC()`

---


In this notebook, we will



## Set Up

```{r setup}
# Load libraries
library(magrittr)
library(ggplot2)
library(SingleCellExperiment)


# Setting the seed for reproducibility
set.seed(12345)
```

### Directories and files



The gene expression data and and antibody tag counts were processed with Cell Ranger 6.0.
We have provided the raw data folder 


```{r filepaths}
# main data directory
data_dir <- file.path("data", "glioblastoma")

# Path to the Cell Ranger matrix file
raw_matrix_dir <- file.path(data_dir, "raw_feature_bc_matrix")

# reference data directory
ref_dir <- file.path("data", "reference")
# Path to mitochondrial genes table
mito_file <- file.path(ref_dir, "hs_mitochondrial_genes.tsv")

# Directory and file to save output
normalized_dir <- file.path(data_dir, "normalized")
if (!dir.exists(normalized_dir)) {
  dir.create(normalized_dir, recursive = TRUE)
}

output_sce_file <- file.path(normalized_dir, "gliobastoma_normalized_sce.rds")

```


## Reading Cell Ranger data

```{r}
raw_sce <- DropletUtils::read10xCounts(raw_matrix_dir) 
```

Look at the object:
```{r}
raw_sce
```

36601 features, 734492 droplet barcodes.

### Separating gene expression from antibody tags

```{r}
head(rowData(raw_sce))
```

### Filtering empty droplets

Most droplets are empty

```{r}
droplet_df <- DropletUtils::emptyDropsCellRanger(
  counts(raw_sce), 
  BPPARAM = BiocParallel::MulticoreParam(4)
)

cells_to_retain <- which(droplet_df$FDR <= 0.01)
filtered_sce <- raw_sce[, cells_to_retain]
```

```{r}
filtered_sce
```
### Calculating QC statistics

Get the mitochondrial genes
```{r}
mito_genes <- readr::read_tsv(mito_file) %>%
  dplyr::filter(gene_id %in% rownames(filtered_sce)) %>%
  dplyr::pull(gene_id)
```


```{r}
filtered_sce <- scuttle::addPerCellQC(filtered_sce,
                                      subsets = list(mito = mito_genes))
```

```{r}
cell_stats <- colData(filtered_sce) %>%
  as.data.frame()
cell_stats
```

### Filtering compromised cells


```{r}
ggplot(cell_stats, aes(x = detected, y = subsets_mito_percent)) +
  geom_point(alpha = 0.2)
```

Fit a mixture model 
```{r}
miqc_model <- miQC::mixtureModel(filtered_sce) 
```

Plot the model results
```{r}
miQC::plotModel(filtered_sce, miqc_model)
```


```{r}
miQC::plotFiltering(filtered_sce, miqc_model)
```
```{r}
qcfiltered_sce <- miQC::filterCells(filtered_sce, model = miqc_model)
```


## Normalization and Dimension Reduction

### RNA-seq normalization

We will start with normalizing the RNA-seq data.
The goal here is to convert the raw counts into a measure that accounts for differences in sequencing depth between cells, and to convert the distribution of expression values from the skewed distribution we expect to see in raw counts to one that is more normally distributed.  

```{r}
# Normalize RNA
qclust <- scran::quickCluster(qcfiltered_sce)
qcfiltered_sce <- scran::computeSumFactors(qcfiltered_sce, clusters = qclust)
normalized_sce <- scuttle::logNormCounts(qcfiltered_sce)
```

This creates a new "assay" in the `normalized_sce` object, `logcounts`, which contains the normalized count values.

```{r}
normalized_sce

```

### Dimension Reduction

HVGs:
```{r}
num_genes <- 2000

gene_variance <- scran::modelGeneVar(normalized_sce)
hv_genes <- scran::getTopHVGs(gene_variance,
                              n = num_genes)
```

PCA:
```{r}
# Do we want to set the number of PCs?
normalized_sce <- scater::runPCA(normalized_sce,
                                 subset_row = hv_genes)
```

UMAP:
```{r}
normalized_sce <- scater::runUMAP(normalized_sce,
                                  dimred = "PCA")
```



## Unsupervised clustering
```{r}
nn_k <- 20
nn_clusters <- bluster::clusterRows(
  reducedDim(normalized_sce, "PCA"), 
  bluster::NNGraphParam(
    k = nn_k, 
    type = "jaccard",
    cluster.fun = "louvain",
    BPPARAM = BiocParallel::MulticoreParam(4)
  )
)

normalized_sce$nn_cluster <- nn_clusters
```

```{r}
scater::plotUMAP(normalized_sce,
                 colour_by = "nn_cluster")
```

## Save normalized results

```{r}
saveRDS(normalized_sce, file = output_sce_file)
```



## Session Info

```{r session info}
sessionInfo()
```

