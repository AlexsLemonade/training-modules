---
title: "Integrating scRNA-Seq datasets"
author: The Data Lab for ALSF
date: 2022
output:
  html_notebook: 
    toc: true
    toc_depth: 3
    toc_float: true
---

## Objectives

This notebook will demonstrate how to:

- Prepare SCE objects for integration
- Apply integration methods including `fastMNN` and `harmony`
- Visually explore the results of integration
- Learn skills in functional programming in the `tidyverse` with `purrr`

---

In this notebook, we'll perform integration of four scRNA-seq datasets from the [Single-cell Pediatric Cancer Atlas (`ScPCA`)](https://scpca.alexslemonade.org/), a database of uniformly-processed pediatric scRNA-seq data built and maintained by the Data Lab.
This database currently hosts projects from ten different ALSF-funded labs who have generated single-cell pediatric cancer transcriptomic data with the ultimate goal of making this data easily accessible to investigators (like you!).

Specifically, we'll have a look at four libraries from the [`SCPCP000005` project](https://scpca.alexslemonade.org/projects/SCPCP000005), an investigation of pediatric solid tumors led by the [Dyer](https://www.stjude.org/research/labs/dyer-lab.html) and [Chen](https://www.stjude.org/research/labs/chen-lab-taosheng.html) labs at St. Jude Children's Research Hospital.
The particular libraries we'll integrate come from three rhabdomyosarcoma (RMS) patients ([Patel _et al._ (2022)](https://doi.org/10.1016/j.devcel.2022.04.003)), and all samples (which are single-nuclei) were sequenced with 10Xv3 technology.

We'll be integrating these libraries with two different tools, [`fastmNN`](http://www.bioconductor.org/packages/release/bioc/html/batchelor.html) and [`harmony`](https://portals.broadinstitute.org/harmony/). 
Integration corrects for batch effects that arise from different library preparations so that libraries can be jointly analyzed. 
`fastMNN` corrects for batch effects using a faster variant of the mutual-nearest neighbors algorithm, the technical details of which you can learn more about [from this resource](https://marionilab.github.io/FurtherMNN2018/theory/description.html).
`harmony`, on the other hand, corrects for batch effects using an iterative clustering approach, and unlike `fastMNN`, it is also able to consider additional covariates beyond just the batch groupings.


Regardless of which integration tool is used, the SCE objects to be integrated need to be re-formatted and merged into a single (uncorrected!) SCE object that contains all cells from all SCES for all genes that the SCEs have in common.
This merged SCE, which should also contain explicit information about batch origins for each cell, can be provided to the integration method to obtain a formally batch-corrected SCE object. 

Before we dive into this, let's first see what this merging process conceptually looks like:


<!-- Insert diagram ala https://bioconductor.org/books/3.13/OSCA.intro/the-singlecellexperiment-class.html showing before/after SCE objects. Explain the diagram aloud. --> 

## Set Up

```{r setup}
# Load libraries
library(magrittr)
library(ggplot2)
library(SingleCellExperiment)

# Set the seed for reproducibility
set.seed(12345)
```


## Operating on lists with `purrr::map()`

We have already prepared count data for the four samples we'll be integrating (i.e., filtered cells, normalized counts, and calculated PCA & UMAP).
These SCE objects, stored as RDS files, are available in the `data/rms/processed/` directory. 
Files are named according to their `ScPCA` library IDs:

- `SCPCL000478.rds`
- `SCPCL000479.rds`
- `SCPCL000480.rds`
- `SCPCL000481.rds`

To read in these files, we could use `readr::read_rds()` (or the base R `readRDS()`) function four times, once for each of the files. 
A different and more modular coding approach to reading in these files (and more!) is to leverage the [`purrr`](https://purrr.tidyverse.org/) `tidyverse` package, which provides a convenient set of functions for _functional programming_.
You can read more about functional programming in R in [Chapter 21 of _R for Data Science_](https://r4ds.had.co.nz/iteration.html#for-loops-vs.-functionals).

Of particular interest is the [`purrr::map()`](https://purrr.tidyverse.org/reference/map.html) family of functions, which can be used to run a given function on each element of a list or vector in one call.
The general syntax for `purrr::map()` and friends is:

```
# Syntax for using the map function:
purrr::map(<input vector or list>, 
           <function to apply to each item in the input>, 
           <any additional arguments to the function can go here>, 
           <and also here if there are even more arguments, and so on>)

```


Let's see a very simple example in action by quickly taking the square root of a vector of values:
```{r map_example}
squares <- c(4, 9, 16, 25, 36)

# get the square root of each number without purrr
sqrt(squares[1])
sqrt(squares[2])
sqrt(squares[3])

# The `map()` function always returns a list
purrr::map(squares, # vector to map over
           sqrt)    # function to apply to each item in `squares`
```

The output from running `purr::map()` is always a list (but note that there are other `purrr::map()` relatives which return other object types, as you can read about in [the `purrr::map()` documentation](https://purrr.tidyverse.org/reference/index.html)).

We'll note that, in this case, it's possible to simply run `sqrt()` directly on the `squares` vector itself:
```{r quick squares}
sqrt(squares)
```

But, more involved scenarios (as we'll see!) will necessitate the use of `map()`, in particular when the input is a list itself.


One other new coding strategy we'll learn in this notebook is using the [`glue`](https://glue.tidyverse.org/) package to combine strings.
This package offers a convenient function `glue::glue()` that can be used instead of the base R `paste()` function.

```{r paste}
# Define a variable for example:
org_name <- "Data Lab"

# We can use paste to combine strings and variables:
paste("Welcome to the", org_name, "workshop on Advanced scRNA-seq!")
```

We can use `glue::glue()` to accomplish the same goal with some different syntax:

```{r glue}
# glue::glue takes a single string argument (only one set of quotes!), and 
#  variables can easily be included inside {curly braces}
glue::glue("Welcome to the {org_name} workshop on Advanced scRNA-seq!")
```


## Directories and files

To begin, let's set up our directories and files:

```{r directories}
# Define directory where integration data is stored
data_dir <- file.path("data", "rms", "processed")

# Output file name for the merged (unintegrated) object
merged_sce_file <- file.path(data_dir, "merged_sce.rds")

# Output file name for the integrated object
integrated_sce_file <- file.path(data_dir, "integrated_sce.rds")
```

Now, let's use `purrr::map()` to read in our SCE objects so that they are immediately stored together in a list. 
We'll want to use the `readr::read_rds()` function to read in each file, so we'll first need a vector of the file names we'll be reading in.


```{r read input} 
# Vector of all the libraries to read in:
library_names <- c("SCPCL000478",
                   "SCPCL000479",
                   "SCPCL000480",
                   "SCPCL000481")

# Now, convert these to file paths matching `<data_dir>`/`<library_name>`.rds
library_paths <- file.path(data_dir, 
                           glue::glue("{library_names}.rds")
)
library_paths
```

We can now read these files in and create a list of four SCE objects:

```{r}
# Use purrr::map() to read all files into a list at once:
sce_list <- purrr::map(
  library_paths, 
  readr::read_rds
)
sce_list
```

We now have a list of length four, where each item is a processed SCE object!
However, we'll need to keep track of which library each item is, so it's helpful to add _names_ to this list representing the relevant library names.

```{r add list names}
# Assign the library names as the names for sce_list
names(sce_list) <- library_names

sce_list
```

If you look closely at the printed SCE objects, you may notice that they all contain colData columns `celltype_fine` and `celltype_broad`.
These columns (which we added to SCE objects during pre-processing) contain putative _cell type annotations_ as assigned in [Patel _et al._ (2022)](https://doi.org/10.1016/j.devcel.2022.04.003). 
We will end up leveraging these cell type annotations to explore how successful our integration is: After integration, we expect cell types from different samples to cluster together, rather than being separated by batches. 

Before we proceed, it's critical to remember that integration methods _do not actually use_ these cell type annotations, and high-confidence annotations are not always (usually!) available for a given dataset.
If we have annotations, they are a helpful "bonus" for assessing the integration's success, but they are not necessary for performing integration, nor should you expect to always be able to assess integration using them.


## Prepare the SCE list for integration

Now that we have a list of processed SCE objects, we need to merge the objects into one overall SCE object which we can provide as input to integration methods.
A word of caution before we begin: **This merged SCE object is NOT an integrated SCE!** 
Merging SCEs itself does not perform any batch correction; that's why we proceed to integration next.

To merge SCE objects, we do need to do some wrangling and bookkeeping to ensure compatibility and that we don't lose important information.
Overall we'll want to take care of these items: 

1. We should be able to trace library-specific information back to the originating library, including...
  - Cell-level information: Which library is each cell from? 
  Although cells have unique barcode identifiers, these barcodes are only guaranteed to be unique _within_ a library. 
  Now that we are merging several libraries, we won't necessarily be able to identify a cell's originating library from its barcode alone.
  - Library-specific statistics, e.g. gene-level statistics for a given library found in `rowData`
2. SCE objects should contain the same genes: Each `rowData` table should have the same rownames.
3. SCE columns should match: Each `colData` should have the same column names.

Here is a schematic of what this wrangling will look like:

<!-- But! a lot of the text that explains the technical steps happens in the next chunks and subsection so should this diagram be lower?--> 

![](diagrams/technical_merge_sce.png)

We'll begin by take some time to thoroughly explore our SCE objects to figure out what wrangling steps we need to take for these specific data.
Don't skip this exploration!
Bear in mind that we determine here needs wrangling will probably not be exactly the same for other SCE objects you work with.


#### Preserving library information at the cell level

How will we be able to tell which library a given cell came from?

First, we'll want to directly add information to the SCE that indicates the different libraries.
The best way to do this is simply to add a `colData` column with the library information.

In addition, we want to pay some attention to the `colData` rownames, which must remain unique after merging since duplicate rownames will cause an R error.
Usually (but not always!), the `colData` _rownames_` themselves are cell barcodes, which is the case for our SCE objects (one is shown below as an example):

```{r barcodes}
# Look at the colData rownames for the `SCPCL000478` library, for example
rownames( colData(sce_list$SCPCL000478) ) %>%
  # Only print out the first 6 for convenience
  head()
```

Because barcodes theoretically can be repeated across libraries, we could end up in a situation with non-unique rownames, which would make R complain!

One way to ensure that barcodes remain unique even after merging is to actually modify the rownames by _prepending_ the relevant library name. 
For example, we'll update the `CCTTTGGCACTACCCT` in the `SCPCL000478` SCE to become: `SCPCL000478-CCTTTGGCACTACCCT`, thereby ensuring fully unique rownames for all cells.

#### Preserving library information at the gene level

The `rowData` table in SCE objects will often contain both "general" and "library-specific" information, for example:


```{r rowdata colnames}
head( rowData(sce_list$SCPCL000478) )
```

Here, the rownames are Ensembl gene IDs, and columns are `gene_symbol`, `mean`, and `detected`. 
The `gene_symbol` column is general information not specific to any library or experiment, but `mean` and `detected` are library-specific gene statistics. 
So, `gene_symbol` does not need to be traced back to its originating library, but `mean` and `detected` do.
To this end, we can take a similar approach to what we'll do for cell barcodes: We can change the library-specific `rowData` column names by prepending the library name.
For example, rather than being called `mean`, this column will be named `SCPCL000478-mean` for the `SCPCL000478` library.

All our SCE objects have the same `rowData` columns (as we can see in the next chunk), so we'll perform this renaming across all SCEs.

```{r compare rowdata}
# Use `purrr::map()` to quickly extract rowData names for all SCEs
purrr::map(sce_list,
           # This syntax is a formula where the period is a stand-in for 
           # each item in sce_list
           ~names(rowData(.)))
```


#### Ensuring that only shared genes are used

The final step in ensuring SCE compatibility is to make sure they all contain the same genes, which are unambiguously stored in our SCE objects as Ensembl ID `rowData` rownames, which you can map back to gene names by simply asking my co-instructor Josh. 

We can use some `purrr` magic to quickly find the set of shared genes among our libraries:
```{r shared genes}
shared_genes <- sce_list %>%
  # get rownames for each SCE in sce_list
  purrr::map(rownames) %>%
  # reduce to the _intersection_ among lists
  purrr::reduce(intersect)

# We've now created a vector genes that are present in all SCEs
head(shared_genes)
```

<!--- I might get rid of this text and chunk `check shared genes` for time/space? --> 
In this case, all SCE objects we're working with actually already contained the same genes, but it can't hurt to be sure!
To confirm this, we can check that `shared_genes` is the same size as the genes in each SCE:

```{r check shared genes}
# How many shared genes?
length(shared_genes)

# How many genes in each SCE?
# Same number as the shared genes all around!
genes_per_sce <- sce_list %>%
  purrr::map(rownames) %>%
  purrr::map(length)
```
<!--- end of stuff maybe to get rid of -->


#### Ensuring matching columns in `colData`

Finally, we'll need to have the same column names across all SCE `colData` tables.
Again, let's look at all the `colData` names in the SCEs:

```{r compare coldata}
purrr::map(sce_list,
           ~names(colData(.)))
```
It looks like the columns are all already matching among SCEs, so there's no specific preparation we'll need to do there.


### Perform SCE merging


As you can see, there's a lot of moving parts to consider! 
Again, these moving parts may (will!) differ for SCEs that you are working with, so you have to explore your own SCEs in depth to prepare for merging.

We'll write a _custom function_ (seen in the chunk below) tailored to our wrangling steps that prepares a single SCE object for merging.
We'll then use our new `purrr::map()` programming skills to run this function over the `sce_list` to end up with a formatted version of `sce_list` that we can merge.
It's important to remember that this is not a function for general use - it's been precisely written to match the processing we need to do for _these_ SCEs, and different SCEs in the wild will require different types of processing.

```{r format function}
format_sce <- function(sce, library_name, shared_genes) {
  # Input arguments:
  ## sce: An SCE object to format
  ## library_name: The SCE object's name
  ## shared_genes: A vector of genes that are present across all SCE objects
  # This function returns a formatted SCE object.
  
  ###### Ensure that we can identify the originating library ######
  # Add a column called `sample` that stores this information
  colData(sce)$sample <- library_name
  
  
  ###### Ensure colData rownames will be unique ######
  # Update the colData row names by prepending {library_name}
  rownames(colData(sce)) <- glue::glue("{library_name}-{rownames(colData(sce))}")
        
  
  ###### Ensure gene-level statisticss can be identified ######
  # We want to rename the columns `mean` and `detected` to contain the {library_name}
  # Recall the names are: "gene_symbol", "mean", "detected"   
  names(rowData(sce)) <- c("gene_symbol", 
                           glue::glue("{library_name}-mean"),
                           glue::glue("{library_name}-detected"))
  
  ###### Subset the SCE object to only contain the shared genes ######
  sce <- sce[shared_genes,]
  

  # Return the formatted SCE object
  return(sce)
}
```

To run this function, we'll use the `purrr::map2()` function, a relative of `purrr::map()` that allows you to simultaneously loop over _two_ input lists/vectors.
In our case, we want to run `format_sce()` over paired `sce_list` items and `sce_list` names.

```{r format sces for merge}
# We can use `purrr::map2()` to loop over two list/vector arguments simultaneously
# We get to march down the list and the list's names at once more text.
sce_list_formatted <- purrr::map2(
  # Each "iteration" will march down sce_list and names(sce_list) simultaneously
  sce_list,
  names(sce_list),
  # Name of the function to run
  format_sce,
  # Additional arguents to the function
  shared_genes = shared_genes
)

sce_list_formatted
```
(Psst, like `purrr` and want to dive deeper? Check out [the `purrr::imap()` function](https://purrr.tidyverse.org/reference/imap.html)!)


At long last, we are ready to merge the SCEs!
We'll use the R function `cbind()` for this.
The `cbind()` function is often used to combine data frames by column, i.e. "stack" them on top of each other.
The same principle applies here, but when run on SCE objects, `cbind()` will create a new SCE object by combining `counts` and `logcounts` matrices by column, as well as combining reduced dimension slots appropriately.

Since we need to apply `cbind()` to a _list_ of objects, we need to use some slightly-gnarly syntax: We'll use the function `do.call()`, which allows the `cbind()` input to be a list of objects to combine.

```{r merge sces}
# Merge SCE objects 
merged_sce <- do.call(cbind, sce_list_formatted)

# Let's have a look!
merged_sce
```
We now have a single SCE object that contains all cells from all libraries we'd like to integrate.

Let's take a peek at some of the innards of this new SCE object:
```{r explore merged_sce}
# What are the unique values in the `sample` column?
unique( colData(merged_sce)$sample )

# What are the new colData rownames?
head( rownames(colData(merged_sce)) )

# What does rowData look like?
head( rowData(merged_sce) )
```

Let's export this to our `merged_sce_file`.
```{r export merged_sce}
readr::write_rds(merged_sce, 
                 merged_sce_file)

```

<!--coffee break-->




## Integration


So far, we've created a `merged_sce` object which are (almost!) ready to integrate.

The integration methods we'll be using here actually perform batch correction on a reduced dimension representation of the normalized gene expression values, specifically the PCA.
The main reason for this is efficiency.


On one hand, the merged SCE object object already contains PCA and UMAP reduced dimensions, which were calculated during our pre-processing:

```{r merged_sce view pca}
# re-read in merged_sce as needed:
# merged_sce <- readr::read_rds(merged_sce_file)

merged_sce
```

These represent the original dimension reductions that were performed on _each individual library_, but we actually need to calculate PCA (and UMAP for visualization) from the merged object directly.

Why can't we use the library-specific PCA? 
Part of the PCA calculation itself involves scaling the raw data to center the mean.
When this is performed on each library individually, all libraries are separately centered, which leads to the data "overlapping" in space.
To see this, let's look at the UMAP for individual libraries:

```{r individual UMAPs}
# UMAPs scaled separately when calculated from individual libraries:
scater::plotReducedDim(merged_sce,
                       dimred = "UMAP",
                       # Color points based on the `sample` variable we added during merging
                       colour_by = "sample",
                       # Include some point styling to help us see the points
                       point_size = 0.5,
                       point_alpha = 0.2) +
  # Modify the legend key so its points are larger and easier to see
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) +
  # Add a plot title
  ggtitle("UMAP calculated on each library separately")
```


As we see in this UMAP, all libraries are centered at zero and all overlapping!
This visual artifact can give the _incorrect impression_ that data is integrated - to be clear, this data is NOT integrated!

For input to integration, we'll want the PCA scaling to consider normalized gene expression values from all libraries simultaneously, while also taking into consideration batch differences, so we'll need to recalculate PCA (and UMAP for visualization). 
We'll also save these new reduced dimensions with different names, `merged_PCA` and `merged_UMAP`, to distinguish them from already-present `PCA` and `UMAP`.


First, as usual, we'll determine the high-variance genes to use for PCA from the `merged_sce` object.
For this, we'll also provide the argument `block = merged_sce$sample` when modeling gene variance, which tells `scran::modelGeneVar()` to first model variance separately for each batch and then combine those modeling statistics.

```{r calc merged hv_genes}
num_genes <- 2000

# calculate high-variance genes to use for dimension reduction
gene_variance <- scran::modelGeneVar(merged_sce,
                                     # specify the grouping/batch column:
                                     block = merged_sce$sample)

# find the high-variance genes
hv_genes <- scran::getTopHVGs(gene_variance,
                              n = num_genes)
```


To calculate the PCs themselves, we'll use an approach from the `batchelor` package, which is the R package that contains the `fastMNN` method.
In particular, we'll use the `batchelor::multiBatchPCA()` function which accommodates the fact that we have separate batches in our SCE to perform the appropriate scaling we need.
According to the documentation for this function, 
> This function is roughly equivalent to `cbinding` all matrices in and performing PCA on the merged matrix. The main difference is that each sample is forced to contribute equally to the identification of the rotation vectors. Specifically, the mean vector used for centering is defined as the grand mean of the mean vectors within each batch. Each batch's contribution to the gene-gene covariance matrix is also divided by the number of cells in that batch. 


```{r merged_pca}
# Use batchelor to calculate PCA from for merged_sce
merged_pca <- batchelor::multiBatchPCA(merged_sce,
                                       # Consider only the high-variance genes
                                       subset.row = hv_genes,
                                       # Batch-level information
                                       batch = merged_sce$sample,
                                       # This argument ensures that the returned object 
                                       #  is a single matrix that contains all samples, 
                                       #  instead of a separate matrix for each sample
                                       preserve.single = TRUE)
 

# Not very interesting!
merged_pca


# Use indexing to see the PCA matrix
head(merged_pca[[1]])
```


We can now include this PCA matrix in our `merged_sce` object:
```{r add merged_pca}
# add PCA results to merged SCE object 
reducedDim(merged_sce, "merged_PCA") <- merged_pca[[1]]
```


Now that we have the PCA matrix, we can proceed to calculate UMAP for visualization. 
We'll calculate this as "usual":
```{r merged_umap}
# add merged_UMAP from merged_PCA
merged_sce <- scater::runUMAP(merged_sce,
                              dimred = "merged_PCA",
                              name = "merged_UMAP")
merged_sce
```


Now, let's see how this new `merged_UMAP` looks compared to the `UMAP` calculated from individual libraries:

```{r uncorrected merged UMAP}
# UMAPs scaled together when calculated from the merged SCE
scater::plotReducedDim(merged_sce,
                       dimred = "merged_UMAP",
                       colour_by = "sample",
                       # Some styling to help us see the points:
                       point_size = 0.5,
                       point_alpha = 0.2) +
  # Modify the legend key so its points are larger and easier to see
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) +
  # Add a plot title
  ggtitle("UMAP calculated on merged_sce")
```

Now that we've properly accounted for batches in the `merged_sce` object, we see that the libraries are separated in space, which more reasonably reflects that this data is _not yet batch-corrected_.
Indeed, the primary "clustering" (not technical clustering, just what we see visually!) in these plots are the batches.
We can think of this UMAP as our "before" UMAP, and we can compare to the "after" UMAP we see post-integration.

Let's discuss: What visual differences do you think the UMAP on the integrated version of data will have?
What similarities do you think the integrated UMAP will have to this plot?

### Integration with `fastMNN`

Finally, we're ready to integrate!
To start, we'll use the `fastMNN` approach from the Bioconductor [`batchelor` package](http://www.bioconductor.org/packages/3.16/bioc/html/batchelor.html).

`fastMNN` takes as input the `merged_sce` object to integrate, and the first step it performs is actually to run `batchelor::multiBatchPCA()` on that SCE!
The `batch` argument is used to specify the different groupings within the `merged_sce`, and the `subset.row` argument can optionally be used to provide a vector of high-variance genes that should be considered for this PCA calculation.
`fastMNN` will return an SCE object that contains a batch-corrected PCA.

```{r}
integrated_sce <- batchelor::fastMNN(
  # the merged SCE object
  merged_sce,
  # vector indicating the batches, which we created as `$sample` when formatting SCEs
  batch = merged_sce$sample, 
  # Optionally, we can specify genes to use as the previously-ID'd
  #  high variance genes
  subset.row = hv_genes
)

# Let's have a look!
integrated_sce
```

There are couple pieces of information here of interest:

- The `corrected` reduced dimension represents the batch-corrected PCA.
- The `reconstructed` assay represents the batch-corrected normalized expression values, which `fastMNN` "back-calculated" from the batch-corrected PCA.
Generally speaking, these are not stand-alone values that you should use for other applications like differential gene expression.
If the `subset.row` argument was provided (as we did here), only genes present in `subset.row` are included in these reconstructed expression values, but this can be overridden so that all genes have reconstructed expression with the argument `correct.all = TRUE`.

We're mostly interested in the PCA that `fastMNN` calculated, so let's save that information ( (with an informative and unique name!) into our `merged_sce` object:

```{r fastmnn pcs}
# Make a new reducedDim named fastMNN_PCA from the corrected reducedDim in integrated_sce
reducedDim(merged_sce, "fastMNN_PCA") <- reducedDim(integrated_sce, "corrected")

merged_sce
```

Finally, we'll calculate UMAPs from these corrected PCs and plot them so we can see how qualitatively successful integration was:

```{r fastmnn umap}
# Calculate UMAP
merged_sce <- scater::runUMAP(
  merged_sce, 
  # create UMAP from this PCA matrix:
  dimred = "fastMNN_PCA", 
  # name the UMAP:
  name = "fastMNN_UMAP"
)
```

First, let's plot the integrated UMAP highlighting the different batches.
A well-integrated dataset will show batch mixing, but a poorly-integrated dataset will show more separation among batches, similar to the uncorrected UMAP.

```{r fastmnn umap batches}
scater::plotReducedDim(merged_sce,
                       # plot the fastMNN coordinates
                       dimred = "fastMNN_UMAP",
                       # color by sample (batch)
                       colour_by = "sample",
                       # Some styling to help us see the points:
                       point_size = 0.5,
                       point_alpha = 0.2) +
  # Modify legend so they key is larger and easier to see
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) +
  # add plot title
  ggtitle("UMAP after integration with fastMNN")
```



This `fastMNN_UMAP` certainly looks different from the one we made from `merged_UMAP`!
It particularly looks like `SCPCL000479` and `SCPCL000480` have substantial overlap - intriguingly, these two samples are from the same patient, so this overlap may have some true biological underpinnings!

However, it's a bit challenging to see all the points given the amount of overlap in the plot.
One way we can all the points a bit better is to facet the plot by sample:

```{r fastmnn umap batches faceted}
scater::plotReducedDim(merged_sce,
                       dimred = "fastMNN_UMAP",
                       colour_by = "sample",
                       point_size = 0.5,
                       point_alpha = 0.2, 
                       # Allow for faceting by a variable using `other_fields`:
                       other_fields = "sample") +
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) +
  ggtitle("UMAP after integration with fastMNN") +
  facet_wrap(~sample)
```


Importantly, one reason that batches may still appear separated in the corrected UMAP is if they _should_ be separated - for example, maybe two batches contain very different cell types.
In this case, we would not expect batches to mix heavily, since their cell types should retain some structure. 
Recall from earlier, we conveniently have cell type annotations in our SCEs, so we can explore this here!
Let's re-plot this UMAP to highlight cell types:


```{r fastmnn umap celltypes}
scater::plotReducedDim(merged_sce,
                       dimred = "fastMNN_UMAP",
                       # color by broad celltypes
                       colour_by = "celltype_broad",
                       point_size = 0.5,
                       point_alpha = 0.2) +
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) +
  ggtitle("UMAP after integration with fastMNN")
```

Something we can see already from this UMAP is that the non-tumor cell types (mostly vascular endothelium, muscle cells, and monocytes) tend to cluster together and are generally far separated from the tumor cell types, which is an encouraging pattern!

```{r fastmnn umap celltypes faceted}
scater::plotReducedDim(merged_sce,
                       dimred = "fastMNN_UMAP",
                       # color by broad celltypes
                       colour_by = "celltype_broad",
                       point_size = 0.5,
                       point_alpha = 0.2,
                       other_fields = "sample") +
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) +
  ggtitle("UMAP after integration with fastMNN") + 
  facet_wrap(~sample)
```
Looking at the cell type annotation, it appears that `SCPCL000478` uniquely is dominated by the `Tumor` cell type compared to the other samples.
`SCPCL000479` and `SCPCL000480`, which are derived from the same patient, appears both dominated by `Tumor_Myoblast` and `Tumor_Mesoderm`, and `SCPCL000481` appears dominated by `Tumor_Myoblast` and `Tumor_Myocyte`. 
The faceted plot also shows us that `SCPCL000478` fibroblasts appear to cluster with `SCPCL000480` and `SCPCL000481` muscle cells.


### Integration with `harmony`

`fastMNN` is only one of many approaches to perform integration, and different methods are not unlikely to give different results!
For contrast, let's see how integration performs when using the [`harmony` method](https://portals.broadinstitute.org/harmony/) instead, which is available from the `harmony` CRAN package.

Algorithmic differences aside, there are a couple practical differences between `fastMNN` and `harmony` to be aware of:

- Unlike `fastMNN`, `harmony` allows you to specify additional covariates (e.g., technology, patient, diagnosis, etc.)
  - This requires additional setup beyond than we will show below.
- Unlike `fastMNN`, `harmony` does not calculate corrected expression values nor does it return an SCE object.
Instead, it starts with an uncorrected PC matrix and directly returns a matrix of corrected PCs.

For input, `harmony` can either take a matrix of normalized expression values, from which it will calculate a PCA matrix which it will then batch-correct, or it can take a PCA matrix directly to perform batch-correction on.
Since we already calculated batch PCA (`merged_PCA`), we'll provide this information directly, specifying the additional argument `do_pca=FALSE` to tell `harmony` that the input matrix we provided already is PCA.


```{r harmony}
harmony_pca <- harmony::HarmonyMatrix(
  # Provide the uncorrected PCs:
  data_mat  = reducedDim(merged_sce, "merged_PCA"),
  # Provide the batch information:
  meta_data = colData(merged_sce)$sample,
  # Set do_pca = FALSE since we are passing in PCs directly
  do_pca = FALSE
)

# The result is a PCA matrix:
harmony_pca[1:5, 1:5]
```

As before with `fastMNN` results, let's store this PCA matrix directly in our `merged_sce` object with an informative name that won't overwrite any of the existing PCA matrices.

```{r save harmony}
# Store PCA as `harmony_PCA`
reducedDim(merged_sce, "harmony_PCA") <- harmony_pca

# As before, calculate UMAP on these PCs:
merged_sce <- scater::runUMAP(merged_sce, 
                              dimred = "harmony_PCA", 
                              name   = "harmony_UMAP")
```


Let's see how the `harmony` UMAP, colored by either batch or cell type, looks compared to the `fastMNN` UMAP:

```{r harmony umap batches}
scater::plotReducedDim(merged_sce,
                       dimred = "harmony_UMAP",
                       # color by sample (batch)
                       colour_by = "sample",
                       point_size = 0.5,
                       point_alpha = 0.2) +
  ggtitle("UMAP after integration with harmony") +
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) 
```

This UMAP looks very different from the one we made from `fastMNN` integration!
`SCPCL000481` uniquely appears "unintegrated" compared to the other libraries, which is unexpected given that the `SCPCL000478` library is the one with more unique cell types!
This result may qualitatively suggest that `harmony` integration was less successful than was `fastMNN`, but let's dig into these results a little deeper.

Let's highlight the cell types in the harmony UMAP:

```{r harmony umap celltypes broad}
scater::plotReducedDim(merged_sce,
                       dimred = "harmony_UMAP",
                       # color by broad celltypes
                       colour_by = "celltype_broad",
                       point_size = 0.5,
                       point_alpha = 0.2) +
  ggtitle("UMAP after integration with harmony") +
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) 
```
Similar to the `fastMNN` results, the non-tumor cell types do appear to have been well-integrated across batches, but that one library does stand out!
We can see that 

Now is a good time to remember we actually have two cell type variables: `celltype_broad` and `celltype_fine`, where the latter contains finer-grained Tumor characterizations based on differentiation stage.
Let's see what we observe if we color the UMAP instead by the finer-grained cell types:

```{r harmony umap celltypes fine}
scater::plotReducedDim(merged_sce,
                       dimred = "harmony_UMAP",
                       # color by FINE celltypes
                       colour_by = "celltype_fine",
                       point_size = 0.5,
                       point_alpha = 0.1, 
                       other_fields = "sample") +
  ggtitle("UMAP after integration with harmony") +
  guides(colour = guide_legend(override.aes = list(size = 3, alpha = 1))) +
  facet_wrap(~sample)
  
```

It looks as though `SCPCL000481` may indeed be comprised of relatively distinct cell types, which we can check with a barplot:

<!-- LATE BREAKING ADDITION IN NEED OF REVIEW/DISCUSSION, including where to put this plot? Should I make this plot? -->
```{r count celltypes fine}
# Create a table of counts sample and celltype_fine combinations
sample_celltype_table <- colData(merged_sce) %>%
  as.data.frame() %>%
  dplyr::count(sample, celltype_fine) 


sample_celltype_table

# Let's look at just tumor cells:
sample_celltype_table %>%
  dplyr::filter(stringr::str_detect(celltype_fine, "Tumor")) %>%
  ggplot(aes(x = sample, y = n, fill = celltype_fine)) +
  geom_col(position = "dodge")
```

Indeed, we see that `SCPCL000481` has a substantial `Tumor_Myocyte-A` population that the other libraries do not have, and the two libraries from the same patient show similar trends. 


What similarities and differences between `fastMNN` and `harmony` integration do you notice?
How do you think these results compare?

### Export 

Finally, we'll export the final SCE object with both `fastMNN` and `harmony` integration to a file.

```{r save integration}
readr::write_rds(merged_sce, 
                 integrated_sce_file)
```


## Print session info

As always, we'll print the session info to be transparent about what packages, and which versions, were used during this R session.

```{r sessioninfo}
sessionInfo()
```
