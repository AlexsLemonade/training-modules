---
title: "Intro to ggplot2"
output:   
  html_notebook: 
    toc: true
    toc_float: true
---

**CCDL 2020**

## Objective for this notebook analysis: 

We'll use the same gene expression dataset we used in the previous notebook. 
It is a pre-processed [astrocytoma microarray dataset](https://www.refine.bio/experiments/GSE44971/gene-expression-data-from-pilocytic-astrocytoma-tumour-samples-and-normal-cerebellum-controls) that we performed a set of [differential expression analyses on](./scripts/00-setup-intro-to-R.R).  

**More tidyverse resources:**  
- [R for Data Science](https://r4ds.had.co.nz/)  
- [Tidyverse documentation](https://dplyr.tidyverse.org/)  
- [Cheatsheet of Tidyverse data transformation](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)  
- [Online Tidyverse book chapter](https://privefl.github.io/advr38book/tidyverse.html)  

## Set Up

The `tidyverse` is a collection of packages that are handy for general data 
wrangling, analysis, and visualization. 
Other packages that are specifically handy for different biological analyses are 
found on [Bioconductor](https://www.bioconductor.org/).
If we want to use a package's functions we first need to install them.
In our Docker container, we already have `tidyverse` and other packages we will
use in this workshop installed for you. 
But if you needed to install it or other packages available on CRAN, you 
do it using the `install.packages` function like this: `install.packages("tidyverse")`

```{r Load tidyverse}
library(tidyverse)
```

### Referencing a library's function with `::`

Note that if we had not imported the tidyverse set of packages using `library` 
like above, and we were using a tidyverse function like `read_tsv`, we would need to 
tell R what package to find this function in.
To do this, we would use `::` to tell R to load in this function from the 
`readr` package by using `readr::read_tsv`.
You will see this `::` method of referencing libraries throughout the course.  

## Managing directories

Before we can import the data we need, we should double check where R is 
looking for files aka our what our *working* directory currently is. 
We can do this by using the `getwd()` function, which will tell us what folder
we are in. 

```{r}
# Let's check what directory we are in:
getwd()
```

Note that for Rmd files, the working directory is always wherever the file is 
located. 

We will want to make a directory for our output and we will call this directory: 
`results`. 
But before we create the directory, we should check if it already exists. 
We will show two ways that we can do this. 

First, we can use the `dir()` function to have R list the files in our working 
directory. 

```{r}
# Let's check what files are here
dir()
```

This shows us there is no folder called "results" yet. 

If we want to more pointedly look for "results" in our working directory we can 
use the `dir.exists` function.

```{r}
# Check if the results directory exists
dir.exists("results")
```

If the above says `FALSE` that means we will need to create a `results` directory
using the function `dir.create`.

```{r}
# Make a directory within the working directory called 'results'
dir.create("results")
```

After creating the results directory above, let's re-run `dir.exists` to see if 
now it exists.

```{r}
# Re-check if the results directory exists
dir.exists("results")
```

We can use the output of `dir.exists` to automatically create or hold off on 
creating a directory by putting this together in an `if` statement like below. 
Note that we put an exclamation point to signify that we want a directory to be
created only *if* `dir.exists(results)` is NOT equal to `TRUE`.

```{r}
# If 'results' directory doesn't exist...
if (!dir.exists("results")) {
  # ... create a 'results' directory
  dir.create("results")
}
```

Note that the `dir.exists` function will not work on files themselves.
In this case, there is an analogous function called `file.exists`.

Try using the `file.exists` function to see if the file `gene_results_GSE44971.tsv` file 
exists in the current directory.
Use the code chunk we set up for you below. 
Note that in our notebooks (and sometimes elsewhere), wherever you see a 
`<FILL_IN_THE_BLANK>` like in the chunk below, that is meant for you to replace 
with the correct phrase before you run the chunk (otherwise you will get an error).

```{r eval=FALSE}
# Replace the <PUT_FILE_NAME_HERE> with the name of the file you are looking for
# Remember to use quotes to make it a character string
file.exists(<PUT_FILE_NAME_HERE>)
```

Now that we've determined that `gene_results_GSE44971.tsv` exists, we are ready to read it 
into our R environment.

#### Read a TSV file

Declare the name of the directory where we will read in the data. 

```{r}
data_dir <- "data"
```

In R, we will use `file.path()` for this (more on this later in this notebook).  
Although base R has read-in functions, the `readr` functions are faster and more
straightforward to use so we are going to use those here. 
Because the file we are reading in is a TSV (tab separated values) file we will 
be using the `read_tsv` function. 
But note that there are analogous functions for CSV (comma separated values) 
files (`read_csv`) and other files types.

## Read in the differential expression analysis results file

Here we are using a `tidyverse` function `read_tsv` from a library of functions called `readr`. 

```{r}
stats_df <- readr::read_tsv(file.path(data_dir,
                                      "gene_results_GSE44971.tsv"))
```
```{r}
# The file we are reading in is our argument for read_tsv
gene_df <- read_tsv(file.path(data_dir, "GSE44971.tsv"))
```

Use this chunk to explore what `gene_df` looks like. 

```{r}
# Explore `gene_df`
```

What information is contained in `gene_df`?

## dplyr pipes

A nifty thing with the tidyverse is the pipes: `%>%`
This handy thing allows you to funnel the result of one expression to the next
making your code a little more streamlined.

For example, the output from this:  

```{r}
filter(stats_df, contrast == "male_female")
```  

...is the same as the output from this:  

```{r}
stats_df %>% filter(contrast == "male_female")
```  
  
This makes it so your code is cleaner and easier to read. 
Let's look at an example with our stats of of how the same 
functions look with or without pipes:

*Example 1:* without pipes: 

```{r}
stats_nopipe <- stats_df
stats_nopipe <- arrange(stats_nopipe, t_statistic)
stats_nopipe <- filter(stats_nopipe, avg_expression > 5)
stats_nopipe <- select(stats_nopipe, contrast, log_fold_change, p_value)
```
  
UGH, we have to repeat and assign `stats_nopipe` so many times here! 
It's annoying and makes it harder for people to read. 
  
*Example 2:* Same result as 1 but with pipes!

```{r}
# Example of the same modifications as above but with pipes!
stats_pipe  <- stats_df %>%
               arrange(t_statistic) %>%
               filter(avg_expression > 5) %>%
               select(contrast, log_fold_change, p_value)
```

Let's double check that these are the same by using the function, all.equal: 

```{r}
all.equal(stats_nopipe, stats_pipe)
```

`all.equal` is letting us know that these two objects are the same. 
(You can use all.equal in other instances and adjust the parameters depending on
how exact of a match you are looking for. )

Now that hopefully you are convinced that tidyverse helps your code to be neater 
and easier to use and read, let's go through some of the popular tidyverse 
functions and so we can create pipelines like this. 

## Common tidyverse functions

Let's say we wanted to filter this gene expression dataset to particular sample
groups.
In order to do this, we would use the function `filter` as well as a logic statement.

```{r}
# Here let's filter the data to a particular gene
stats_df %>% filter(gene_symbol == "SNCA")
```

We can use filter similarly for numeric statements.  

```{r}
# Here let's filter the data to have average expression values above 5
stats_df %>% filter(avg_expression > 5)
```

We can apply multiple filters at once:

```{r }
stats_df %>% filter(contrast == "male_female", 
                    avg_expression > 5)
```

When we are filtering, the `%in%` operator can come in handy if we have multiple
items we would like to match.
Let's take a look at what using `%in%` does.

```{r}
stats_df$gene_symbol %in% c("SNCA", "CDKN1A")
```

`%in%` returns a logical vector that now we can use in `dplyr::filter`.

```{r }
stats_df %>% filter(gene_symbol %in% c("SNCA", "CDKN1A"))
```

Let's return to our first `filter` and build on to it. 
This time, let's keep only some of these variables with the `select` function. 
Let's also save this as a new data.frame called `stats_filtered_df`.

```{r}
stats_filtered_df <- stats_df %>% 
  filter(contrast == "male_female", 
         avg_expression > 5) %>%
  select(log_fold_change, t_statistic)
```

Let's say we wanted to arrange this dataset so that the patients were arranged
youngest to oldest.
In order to do this, we would use the function `arrange` as well as the variable
we would like to sort by (in this case `age_mths`).

```{r}
stats_df %>% arrange(p_value) 
```

What if we want the the oldest patients at the top of this dataset instead? 
We can use the same function, but instead use the `desc` function too. 

```{r}
stats_df %>% arrange(desc(p_value))
``` 

What if we would like to create new variables? 
For that we use `mutate` function. 

```{r}
stats_df %>% 
  mutate(log10 = -log10(p_value))
```

What if we want to obtain summary statistics for a variable? 
The `summarize` function allows us to calculate summary statistics for a column. 
Here we will use summarize to obtain an average expression overall all genes. 

```{r}
stats_df %>% summarize(mean(log_fold_change))
```

What if we'd like to obtain a summary statistics but have them for various groups?
Conveniently named, there's a function called `group_by` that seamlessly 
allows us to do this. 
Also note that `group_by` allows us to group by multiple variables at a time if 
you want to.

```{r}
stats_summary_df <- stats_df %>%
      group_by(contrast) %>% 
      summarize(mean(log_fold_change))
```

Let's look at a preview of what we made:

```{r}
stats_summary_df
```

### Chunking out your code: a technique for figuring out what's happening

We did quite a few steps to get the object `stats_summary_df`. 
If we needed to troubleshoot this step, or if we got confused on what's 
happening, it could be difficult to figure this out by looking at the code chunk 
all at once. 

For these situations, we are going to introduce you to a technique called 
"chunking".

Printing out smaller units of code at a time can help you learn what is happening
at each step. 
This will help fast-track your troubleshooting attempts. 

Use this empty code chunk below to try chunking out this code chunk by following
the figure above. 

```{r}
# Try to chunk out lines of code we used to get `stats_summary_df`
```

For more troubleshooting techniques or a breakdown of the most common R errors, 
check out the [debugging resources guide](https://github.com/AlexsLemonade/training-modules/blob/master/intro-to-R-tidyverse/00b-debugging_resources.md)
in this repository.

## A brief intro to the `apply` family of functions

In base R there the `apply` family of functions can be an alternative 
methods for performing transformations across a data.frame, matrix or for other 
object structures. 

The second argument in `apply` specifies whether we are applying something 
across rows or across columns (1 for rows, 2 for columns).

```{r}
# Calculate row means
gene_means <- apply(gene_df[, -1], 1, mean) # Notice we are using 1 here

# How long will `gene_means` be? 
length(gene_means)
```

Why do we have a `[, -1]` after `gene_df` in the above chunk?

Now let's investigate the same set up, but use 2 to `apply` over the columns of
our matrix.

```{r}
# Calculate sample means
sample_means <- apply(gene_df[, -1], 2, mean) # Notice we use 2 here

# How long will `sample_means` be? 
length(sample_means)
```

Although the `apply` functions may not be as easy to use as the `tidyverse` 
functions, for some applications, `apply` methods can be better suited.
In this workshop, we will not delve too deeply into the various other apply 
functions (`tapply`, `lapply`, etc.) but you can read more examples 
about them [here](https://www.guru99.com/r-apply-sapply-tapply.html).
## The dplyr::join functions

Let's say we have a scenario where we have two data.frames that we would like to 
combine. 
Recall that `stats_pipe` and `gene_df` are data.frames that contain information about some of the same genes.
The [`dplyr::join` family of functions](https://dplyr.tidyverse.org/reference/join.html) 
are useful for various scenarios of combining data.frames. 

For now, we will focus on `inner_join`, which will combine data.frames by only
keeping information about the samples that are in both data.frames. 
We need to use the `by` argument to designate what column(s) 
should be used as a key to match the data.frames (in this case `ensembl_id`s). 

```{r}
stats_df %>% inner_join(gene_df, 
                        by = c('ensembl_id' = 'Gene')) 
```

Note that if there are columns of the same name in both data.frames, the default 
is to save both columns but a `x` or `y` is added to the name to note which 
data.frame it originated from.

## Save data to files

#### Save to TSV files

Let's write this data we edited to a file.
To do this, we can use the `readr` library of `write` functions. 
Note that the second argument of `write_tsv` needs to be a character string that 
contains our `file.path` to the new file we would like to create.
Remember that we created a `results` directory to put our output in. 
But if we want to save our data to a directory other than our working directory, 
we need to specify this. 
This is what we will use the `file.path` function for. 
Let's look at what `file.path` does, by taking a look at the print out of it 
from examples below.

```{r}
# Which of these file paths is what we want to use to save our data to the
# results directory we created at the beginning of this notebook?
file.path("docker-install", "stats_summary.tsv")
file.path("results", "stats_summary.tsv")
file.path("stats_summary.tsv", "results")
```

Replace `<NEW_FILE_PATH>` below with the `file.path` from above that will 
successfully save our file to the `results` folder 

```{r eval=FALSE}
# Write our data.frame to a TSV file
write_tsv(stats_summary_df, <NEW_FILE_PATH>)
```

Check in your `results` directory to see if your new file has successfully saved.

#### Save to RDS files

For this example we have been working with `data.frame`s, however, in other 
situations we may want to save more complicated structure objects or very large 
objects. 
RDS (R Data Serialized/Single) files may be a better option in these instances.
RDS is R's special file format for holding data exactly as you have it in your 
R environment. 
RDS files can also be compressed, meaning they will take up less space on your 
computer. 
Let's save our data to an RDS file in our `results` folder.
You will need to replace the `.tsv` with `.RDS`, but you can use what we 
determined as our `file.path` for the last chunk as your template. 

```{r eval=FALSE}
# Write your object to an RDS file
write_rds(stats_summary, <PUT_CORRECT_FILE_PATH_HERE>)
```

#### Read an RDS file

Since now you have learned the `readr` functions: `read_tsv`, `write_tsv`, and 
now, `write_rds`, what do you suppose the function you will need to read your 
RDS file is called? 
Use that function here to re-import your data in the chunk we set up for you
below.

```{r eval=FALSE}
# Read in your RDS file
reimport_df <- <PUT_FUNCTION_NAME>(file.path("results", "stats_clean.RDS"))
```

As is good practice, we will end this session by printing out our session info. 

### Session Info

```{r}
# Print out the versions and packages we are using in this session
sessionInfo()
```
