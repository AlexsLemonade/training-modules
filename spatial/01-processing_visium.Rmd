---
title: "Reading, processing, and exploring Visium data"
author: Data Lab for ALSF
date: 2026
output:
  html_notebook:
    toc: true
    toc_float: true
---

## Objectives

- Quality control and post-processing of a Visium dataset
- Learn visualization approaching for spatial data 
- Apply descriptive statistics for lattice-based spatial data


---


This notebook will analyze an anaplastic Wilms Tumor sample from a 3 year old male biopsied at initial diagnosis.
The dataset comes from the Single-cell Pediatric Cancer Atlas Portal, [project `SCPCP000006`](https://scpca.alexslemonade.org/projects/SCPCP000006).

## Set up

Load libraries and set random seed:


```{r}
suppressPackageStartupMessages({
  library(SpatialExperiment) # core object 
  library(VisiumIO) # I/O, but we'll still use :: in the code
  library(ggspavis) # plotting
  library(ggplot2) # plotting
  library(patchwork) # plotting
  library(Voyager) # SFE object & spatial descriptive stats
})
set.seed(2026)
```

Paths:

```{r}
data_path <- here::here( 
  "data", 
  "SCPCS000190",
  "SCPCL000429_spatial"
) 
```

What's in Space Ranger output?
Must note that this was processed with an older version of Space Ranger `1.3.1`.

```{r}
dir(data_path)
dir(file.path(data_path, "spatial"))
```

## Import Visium data

We'll use the `VisiumIO` package:

```{r}
# define handle, essentially
tenx_object_raw_matrix <- VisiumIO::TENxVisium(
  resources = file.path(data_path, "raw_feature_bc_matrix"),
  spatialResource = file.path(data_path, "spatial"),
  # this argument is needed: the default argument includes "cytassist" 
  # but ScPCA samples don't have that one; only have these
  images = c("lowres", "hires", "detected", "aligned")
)

# actually import it
spe <- VisiumIO::import(tenx_object_raw_matrix)
```


Let's have a look:

```{r}
spe
```

It's essentially an `SCE`, but with a few more bells and whistles.

Note that we have 4992 spots - this is not a random value! 
It's the number of spots on Visium's 6.5 x 6.5 slide. 

Unlike `SCE`s, we have spatial information in a dedicated `spatialCoords` slot:

```{r}
# handy function from our code package SpatialExperiment
# literally is giving x/y coordinates
head(spatialCoords(spe))
```

We also have a slot that just holds the images, `imgData`, although looking at it directly isn't very interesting.
But, this stored information will help us make figures!

```{r}
imgData(spe)
```

We should also point out what's in `colData`.
Unlike an `SCE`, this isn't cell metadata. 
In an `SPE`, it's _spot_ metadata; recall that each spot may contain multiple cells, which can even include partial cells!

```{r}
head(colData(spe))
```

Hmmm, check out that `in_tissue` column!
It contains 0/1 because we read in the `raw` Space Ranger output, which includes all spots including those which don't actually overlap tissue.
Ultimately, we won't want to analyze the spots that are not on top of tissue, so we'll have to deal with that.

Having all this image information in the `SPE` object means we can plot directly.
The package `ggspavis` provides several useful functions for plotting, let's see the highlights:

```{r, fig.width = 5}
# Spots overlaying the H&E, and we can see the slide boundaries as well
ggspavis::plotVisium(spe)
```

By default this shows the spots, but we can hide them and zoom into the tissue on the slide.
This is a helpful way to pop up the H&E for side-by-side comparisons with other plots you might make.

```{r, fig.width = 5}
ggspavis::plotVisium(spe, spots = FALSE, zoom = TRUE) 
```

Let's take a moment to chat about Wilm's Tumor - these tumors in the developing kidney are often composed of a couple histologic compartments, blastemal, stromal (with mesenchymal biology), and sometimes epithelial components.
In this section, we can see two major components: the bluer indicating densely cellular, ECM-poor regions consistent with blastema, and paler pink regions consistent with stromal tissue.

Let's actually go ahead and save this plot to a variable; it will be a convenient way for us to quickly pop up the H&E for side-by-side comparison with other plots we'll make later.

```{r}
p_he <- ggspavis::plotVisium(spe, spots = FALSE, zoom = TRUE) 
```


There's another function called `plotCoords` which hides the H&E to just show the spots; this plot is not currently very compelling, but once we start coloring by things it will be much more fun!

```{r, fig.width = 5}
# no H&E
ggspavis::plotCoords(spe, point_size = 1) 
```


## Quality control

### Removing uninformative bins

We only care about spots on top of tissue, so let's begin by removing the `in_tissue = 0` spots.
(Note that reading in the `filtered_feature_bc_matrix` version of Space Ranger output would already be filtered to only `1` in this column, so we're only taking this step because we read in the `raw` output).

We can visualize which spots those are, and we'll do it over the H&E to clearly see the relationship.
We'll use the `annotate` argument, but `plotVisium` sees that this column is an integer and forces it to use a continuous color scale; we'll go ahead and make it a factor for plotting.

```{r, fig.width = 5}
# make a factor version of this column to plot with
spe$in_tissue_factor <- as.factor(spe$in_tissue)

ggspavis::plotVisium(
  spe, 
  annotate = "in_tissue_factor", 
  # custom palette so we can see clearly
  pal = c("red", "lightblue")
)
```

- The tissue overhang on the left isn't colored at all - indeed, there aren't spots at those coordinates outside the slide
- Red points are those to filter out - they are uninformative.
Worth noting that some of these appear "inside" the tissue. 

```{r}
# keep only spots that are in the tissue
spe <- spe[, spe$in_tissue == 1]
spe
```

Now, we're down to 3701 spots and we can see this reflected in a plot.
We now only see spots with tissue underneath. 
Onwards!

```{r, fig.width = 5}
ggspavis::plotVisium(spe)
```

### Filtering for bin quality


We _could_ do the same kind of QC that we do for single-cell data, which (usually) involves defining global thresholds for e.g. number of detected UMIs or percent mito.
However, spatial data doesn't lend itself as well to this type of filtering since global thresholds may not be suitable for the different tissues.
Compared to spatial data, single-cell data more closely (but of course not exactly!) resembles a homogeneous pool of cells. 


Let's go ahead and calculate some QC stats and visualize them:

```{r}
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$Symbol)
mito_ensembl <- rownames(spe)[is_mito]
spe <- scater::addPerCellQC(spe, subsets=list(mito=mito_ensembl))
```

`ggspavis` comes with a helpful QC plotter (makes histograms by default but has a couple more options!)

```{r, fig.width = 8, fig.height = 4}
p1 <- ggspavis::plotObsQC(spe, x_metric = "sum") + ggtitle("sum")
p2 <- ggspavis::plotObsQC(spe, x_metric = "detected") + ggtitle("detected")
p3 <- ggspavis::plotObsQC(spe, x_metric = "subsets_mito_percent") + ggtitle("mito %")

p1 + p2 + p3
```

Distributions don't look like there are any _major_ issues with quality here.
One reason for this is - these are all spots (aggregates of cells), not cells! 
Data is sparse, but not quite as sparse.

Let's plot the same stats on the slide:

```{r, fig.width = 10}
p1 <- plotCoords(spe, annotate="sum", point_size = 1) + ggtitle("sum")
p2 <- plotCoords(spe, annotate="detected", point_size = 1) + ggtitle("detected")
p3 <- plotCoords(spe, annotate="subsets_mito_percent", point_size = 1) + ggtitle("mito %")
p1 + p2 + p3 + p_he
```

We _do_ see a relationship here with tissue type and QC stats that suggests we don't have globally homogeneous patterns - 

- the likely stromal regions look like they have relatively higher mito (although it's low all around!)
- the likely blastema regions tend to have more detected genes

This tells us that there is local structure in the data, and using global thresholds could be too aggressive/not aggressive enough depending on the local context.

### Local filtering with Spot Sweeper

A more spatially-suited approach comes from `SpotSweeper` which models QC stats to identify _local_ outliers.

We'll detect local outliers based on these three QC stats.
This function will add some `colData` columns we we can use to find all the local outliers.

```{r}
spe <- SpotSweeper::localOutliers(spe, metric="sum", direction="lower", log=TRUE) # lower-value outliers should be detected
spe <- SpotSweeper::localOutliers(spe, metric="detected", direction="lower", log=TRUE) # lower-value outliers should be detected
spe <- SpotSweeper::localOutliers(spe, metric="subsets_mito_percent", direction="higher", log=FALSE) # higher-value outliers should be detected
``` 

How many of each kind of outlier?

```{r}
c("sum_outliers", "detected_outliers", "subsets_mito_percent_outliers") |>
  purrr::set_names() |>
  purrr::map(\(x) table(spe[[x]]))
```

We'll use a built-in plotting function from `SpotSweeper` to plot these results (the `ggspavis` plotting isn't quite as nice in this case).
Each plot highlights the spots to remove, and spots are colored based on a different stat.
Again we'll include the H&E as a panel for ease of comparison.

```{r, fig.width = 10}
p1 <- SpotSweeper::plotQCmetrics(spe, metric = "sum_log", outliers = "sum_outliers") + ggtitle("log sum")
p2 <- SpotSweeper::plotQCmetrics(spe, metric = "detected_log", outliers = "detected_outliers") + ggtitle("log detected")
p3 <- SpotSweeper::plotQCmetrics(spe, metric = "subsets_mito_percent", outliers = "subsets_mito_percent_outliers") + ggtitle("mito %")

p1 + p2 + p3 + p_he
```
Some of these spots are being flagged by multiple stats, in particular both `sum` and `detected`.
Let's go ahead and filter all these cells out:

```{r}
# combine all outliers into "local_outliers" column to filter on
spe$local_outliers <- as.logical(spe$sum_outliers) |
    as.logical(spe$detected_outliers) |
    as.logical(spe$subsets_mito_percent_outliers)

spe <- spe[, spe$local_outliers == FALSE]
```




## Normalization

With single-cell, a popular normalization approach we adopt involves deconvolution - we do a quick clustering so we can get groups of cells that will share a size factor, for faster processing.
But this isn't suitable for spot-based spatial data since our units aren't cells, but potentially heterogeneous groups of cells (whole or partial).

We'll therefore use going to use library-size normalization here to correct for sequencing depth but preserve the other heterogeneous biological signal.
Bear in mind the caveat that in some cases library size itself is [also confounded with spatial structure]((https://link.springer.com/article/10.1186/s13059-024-03241-7); so, keep your eyes peeled for normalization developments, since this space is evolving rapidly!

```{r}
spe <- scuttle::computeLibraryFactors(spe)
spe <- scuttle::logNormCounts(spe)
spe # now we have a logcounts assay
```

## Dimension reduction

For this step, we're going to get a reduced dimension representation using _just_ the lens of gene expression, "ignoring" spatial information.
(Later, we'll see complementary approaches to some of this which leverages spatial information).

This all tells us we have to be careful when interpreting analyses on spatial data: "to what extent was spatial information taken into account" is something you'll want to understand.

Let's do HVG selection (again, this does not consider spatial patterns! we'll learn about _spatially_ variable genes later), PCA, UMAP, and clustering (once again, this won't be spatial regions! just _spot_ similarity based on expression - that's not the same as cells, either!)
So, we'll use a `SCE`-style approach:


```{r}
num_genes <- 2000
gene_variance <- scran::modelGeneVar(spe)
hv_genes <- scran::getTopHVGs(gene_variance, n = num_genes)

spe <- scater::runPCA(spe, subset_row = hv_genes)
spe <- scater::runUMAP(spe, dimred = "PCA")

nn_clusters <- scran::clusterCells(
  spe, # object to perform clustering on
  use.dimred = "PCA", # perform clustering on the PCA matrix
  BLUSPARAM = bluster::NNGraphParam(
    k = 20,
    type = "jaccard",
    cluster.fun = "louvain"
  )
)
spe$nn_cluster <- nn_clusters
```


We'll plot the UMAP colored by clusters, because we love UMAPs:

```{r}
scater::plotUMAP(spe, color_by = "nn_cluster") +
  # use distinct palette so we can match up with a spatial view next
  ggokabeito::scale_color_okabe_ito()
```

How do these clusters come out when using the spatial layout?
We have coordinates, after all - let's use them!

```{r, fig.width = 8}
p1 <- ggspavis::plotCoords(spe, annotate = "nn_cluster", point_size = 1) +
  # matching palette to UMAP
  ggokabeito::scale_color_okabe_ito()

p1 + p_he
```

A lot of the clusters are intermingled in space, showing that this analysis is really not spatially-aware!
But, we do see some interesting patterns - check out clusters 1, 5, & 7 in particular - they look stroma-y; also, cluster 8 ooks like a defined region in the H&E, but I'm not a pathologist so let's not overinterpret here.
When expression and tissue structure are correlated, expression-only clusters can pick up on certain spatial regions, but this is _not_ the same as finding "true" spatial domains. 


## Exploring spot-based spatial data

Let's explore this data a little more, using some marker genes.
We don't have specific cells as units here, but we can use marker gene expression to build some descriptive intuition for the data. 

We've defined some marker genes here for visualization that correspond to expected Wilm's Tumor biology:

```{r}
marker_genes <- c(
  "WT1 (kidney development, maglinant in WT)" = "ENSG00000184937",
  "SIX1 (blastema, malignant)" = "ENSG00000126778",
  "MYCN (malignant)" = "ENSG00000134323",
  "COL1A1 (fibroblast/mesenchymal)" = "ENSG00000108821",
  "TAGLN (myofibroblast/mesenchymal)" = "ENSG00000149591"
)
```

Let's plot the expression of these genes, using both UMAP and the spatial layouts to compare:

```{r, fig.width = 14}
cluster_umap <- scater::plotUMAP(spe, color_by = "nn_cluster", point_size = 0.5, point_alpha = 0.5) +
  ggtitle("expression-based clusters") + 
  coord_equal() +
  ggokabeito::scale_color_okabe_ito() 

marker_umaps <- marker_genes |>
  purrr::imap(
    \(ensembl, gene_name) {
      scater::plotUMAP(spe, color_by = ensembl, point_size = 0.5, point_alpha = 0.5) + ggtitle(gene_name) + coord_equal()
    }
  ) |>
  # cluster umap and then the marker gene umaps
  append(values = cluster_umap, after = 0)

patchwork::wrap_plots(marker_umaps, nrow = 2)
```


```{r, fig.width = 12}
cluster_coords <- ggspavis::plotCoords(spe, annotate = "nn_cluster", point_size = 0.75) +
  ggtitle("expression-based clusters") + 
  ggokabeito::scale_color_okabe_ito() 

marker_coords <- marker_genes |>
  purrr::imap(
    \(ensembl, gene_name) {
      # default assay is counts, override!
      ggspavis::plotCoords(spe, annotate = ensembl, point_size = 0.75, assay = "logcounts") +
        scale_color_distiller(palette = "Blues", direction = 1) + 
        ggtitle(gene_name)
    }
  ) |>
  # cluster cooords and then the marker gene coords
  append(values = cluster_coords, after = 0) 

p_he + patchwork::wrap_plots(marker_coords, nrow = 2) + plot_layout(widths = c(1,2))
```


Based on these observations, it seems like there could be some spatial patterns/variability here; _interpret_.
We'll talk more rigorously about quantifying spatially-variable genes later in the workshop, but for now, we can take this opportunity to to ask some descriptive questions about these genes' expression across space.



### Spatial descriptive statistics 

Although spatial analysis is an emerging field in transcriptomics, it's not new to science!
Folks in geography, epidemiology, ecology, and more have been thinking about spatial data for a long time, so we can draw from existing quantitative approaches.

Spot-based spatial data is analogous to "lattice-structure" spatial data, in contrast to high-res spatial technologies that are "point-pattern" data; see [the pasta paper](https://academic.oup.com/nar/article/53/17/gkaf870/8250477).

The R package `spdep` already exists to work with lattice-structure spatial data, and helpfully folks have already started to put this (and other spatial platforms) to work for transcriptomics data.
The `Voyager`/`SpatialFeatureExperiment`: <https://pachterlab.github.io/voyager/index.html> framework is complementary to `SpatialExperiment` and can help us use these tools.
The `SFE` object is an expanded `SPE` object with more slots to facilitate spatial analysis with existing tools (we won't get into these weeds much though, suffice to say it's a super rich environment).

When working with spot data, we can turn it into a graph and ask descriptive (not modeling!) questions about spatial structure directly.
Let's go!

First, we'll need to get it into the `SFE` framework and convert the `SPE` to an `SFE` object.

```{r}
# TODO: I have to remove the image before converting, errors otherwise. Can this be avoided?
# Error: [ext] invalid extent
spe_noimg <- spe
imgData(spe_noimg) <- imgData(spe_noimg)[0, , drop=FALSE]
sfe <- toSpatialFeatureExperiment(spe_noimg)
#sfe <- mirror(sfe, direction = "vertical") # use mirror so plots between ggspavis and this one match. 
# OR, let it be a mirror to serve as a teachable moment about space!
```

One way to make a graph is using k-nearest neighbors, but there's other ways (all of these choices matter to some degree, and we should discuss that!):
Now we'll make a graph using:

- spot centroids as nodes (don't skip that this is a _choice_!)
- knn approach with k = 10, as a starting point
- no weighting

```{r}
colGraph(sfe, "knn10") <- SpatialFeatureExperiment::findSpatialNeighbors(
  sfe, 
  type = "centroids", 
  method = "knearneigh", 
  k = 10
)
```

This will get stored in `colGraph` slot in the `SFE` object.

We can visualize it - check out those edges and nodes, it's a graph!

```{r}
Voyager::plotColGraph(
  sfe, 
  colGraphName = "knn10", 
  colGeometryName = "centroids", 
  segment_size = 0.1,
  geometry_size = 0.3
) +
  theme_void() # we just want the graph
```

Hey notice anything interesting about this image?
It's a mirror of how `ggspavis` plotted it!
Is that a problem? 
Well, no - in space we can mirror and rotate and such, but the spatial relationships are preserved.
This is a big hint that specific coordinates may not always be the same, but the distances should be.


It seems potentially cute to zoom in to prove to you that `k = 10`:

```{r}
Voyager::plotColGraph(
  sfe, 
  colGraphName = "knn10", 
  colGeometryName = "centroids", 
  segment_size = 0.1,
  geometry_size = 5
) +
  scale_y_continuous(limits = c(11500, 12000)) + 
  scale_x_continuous(limits = c(4000,4300)) +
  theme_void()
```


Alright, now that we have a graph, let's see an example of using it for exploratory analysis.
A common descriptive statistic used for lattice spatial data is "Moran's I" which quantifies spatial autocorrelation.
It asks, is the spatial distribution of a variable of interest dispersed, random, or clustered?
We'll use it to look at gene expression of some of our marker genes of interest.
In this case, Moran's I tells us: do neighboring spots (hint: this will depend on your definition of a _neighborhood_!_) have very similar, very dissimilar, or totally unrelated gene expression, where:

- close to 1 values: Nearby spots tend to have similar expression
- ~0: looks random in space
- close to -1 values: Nearby spots tend to have different expression (less commonly of interest in this sort of biology)

We'll calculate this with `Voyager` on our `SFE` object using the graph we just built.

```{r}
sfe <- Voyager::runUnivariate(
  sfe, 
  type = "moran", 
  features = marker_genes, 
  colGraphName = "knn10"
)
```

This stores results in `rowData`:

```{r}
rowData(sfe)[marker_genes, ]
```

This makes some sense given what we when plotting gene expression:

- `SIX1` and `MYCN` were just splotched all around randomly in much of the slide
- `COL1A1` and `TAGLN`  were more concentrated in certain areas
- `WT1` was somewhere in the middle - generally expressed by less variation from spot-to-spot in the plots earlier, per vibes

This global statistic gave us an overall picture, but we can calculate a variant of this statistic also called Local Moran's I which is, you guessed it, a local version.
Rather than giving a single value for the dataset, we'll get a _per-spot_ value (or rather, per node in the graph) that tells us "how much does this spot agree with its immediate neighborhood"?

- high: spot is similar to neighbors and all are high _OR_ all are low
- ~0: spatially neutral, no real relationship to neighbors
- low: spot is different from neighbors where high surrounded by low or vice versa

Let's go:

```{r}
sfe <- Voyager::runUnivariate(
  sfe, 
  type = "localmoran", 
  features = marker_genes, 
  colGraphName = "knn10", 
  name = "localmoran_knn10" # save it as this name
)

# stores it here, not so pretty...
localResults(sfe)$localmoran_knn10
```


```{r, fig.width = 10}
# we can plot with voyager, since it's in a special slot
# or we'd have to pull it out to store back in our SPE
Voyager::plotLocalResult(
  sfe,
  name = "localmoran_knn10",
  features = marker_genes,
  colGeometryName = "centroids",
  divergent = TRUE, # palette
  diverge_center = 0 # palette 
  ) 
```

For easier comparison, we can also use the standardized (z-score) values by specifying the specific attribute (the default was `"Ii"`, the actual stat).

```{r, fig.width = 10}
Voyager::plotLocalResult(
  sfe,
  name = "localmoran_knn10",
  features = marker_genes,
  attribute = "Z.Ii", # plot the normalized moran's i
  colGeometryName = "centroids",
  divergent = TRUE, 
  diverge_center = 0 
  ) 
```

### Scale matters!

We did a graph with 10 nearest neighbors. 
The number of neighbors is going to matter here!

Pick one gene (provide the ensembl id) and see how interpretation differs at different `k`'s.
Try out a really high (`k>=50`) and really low number (`k<=3`) below to calculate and plot Local Moran's I again - the real value, not scaled.
What do you see?

```{r}
gene <- marker_genes[1] # WT1, for example
colGraph(sfe, "knn100") <- findSpatialNeighbors(sfe, type="centroids", method = "knearneigh", k=100)
colGraph(sfe, "knn2") <- findSpatialNeighbors(sfe, type="centroids", method = "knearneigh", k=2)

sfe <- Voyager::runUnivariate(
  sfe, 
  type="localmoran", 
  features = gene, 
  colGraphName="knn100", 
  name = "localmoran_knn100" 
)
sfe <- Voyager::runUnivariate(
  sfe, 
  type="localmoran", 
  features = gene, 
  colGraphName="knn2", 
  name = "localmoran_knn2" 
)

p1 <- Voyager::plotLocalResult(
  sfe,
  name = "localmoran_knn100",
  features = gene,
  colGeometryName = "centroids",
  divergent = TRUE,
  diverge_center = 0
) 


p2 <- Voyager::plotLocalResult(
  sfe,
  name = "localmoran_knn2",
  features = gene,
  colGeometryName = "centroids",
  divergent = TRUE,
  diverge_center = 0
) 

p1 + p2
```

When `k` is very high, there's a lot of neighbors being consider.
Expression will have to be similar cross them all to get a high value for this stat.
But, when `k` is very low, there's very few neighbors!
Much finer-grained picture of similarity between spots.


## Session Info

```{r}
sessionInfo()
```
