---
title: "Reading, processing, and exploring Visium data"
author: Data Lab for ALSF
date: 2026
output:
  html_notebook:
    toc: true
    toc_float: true
---

## Objectives

- Quality control and post-processing of a Visium dataset
- Learn visualization approaching for spatial data 
- Apply descriptive statistics for lattice-based spatial data


---


This notebook will analyze an anaplastic Wilms Tumor sample from a 3 year old male biopsied at initial diagnosis.
The dataset comes from the Single-cell Pediatric Cancer Atlas Portal, [project `SCPCP000006`](https://scpca.alexslemonade.org/projects/SCPCP000006).

## Set up

Load libraries and set random seed:


```{r}
suppressPackageStartupMessages({
  library(SpatialExperiment) # core object 
  library(VisiumIO) # I/O, but we'll still use :: in the code
  library(ggspavis) # plotting
  library(ggplot2) # plotting
  library(patchwork) # plotting
  library(Voyager) # SFE object & spatial descriptive stats
})
set.seed(2026)
```

Paths:

```{r}
data_path <- here::here( 
  "data", 
  "SCPCS000190",
  "SCPCL000429_spatial"
) 
```

What's in Space Ranger output?
Must note that this was processed with an older version of Space Ranger `1.3.1`.

```{r}
dir(data_path)
dir(file.path(data_path, "spatial"))
```

## Import Visium data

We'll use the `VisiumIO` package:

```{r}
# define handle, essentially
tenx_object_raw_matrix <- VisiumIO::TENxVisium(
  resources = file.path(data_path, "raw_feature_bc_matrix"),
  spatialResource = file.path(data_path, "spatial"),
  # this argument is needed: the default argument includes "cytassist" 
  # but ScPCA samples don't have that one; only have these
  images = c("lowres", "hires", "detected", "aligned")
)

# actually import it
spe <- VisiumIO::import(tenx_object_raw_matrix)
```


Let's have a look:

```{r}
spe
```

It's essentially an `SCE`, but with a few more bells and whistles.

Note that we have 4992 spots - this is not a random value! 
It's the number of spots on Visium's 6.5 x 6.5 slide. 

Unlike `SCE`s, we have spatial information in a dedicated `spatialCoords` slot:

```{r}
# handy function from our code package SpatialExperiment
# literally is giving x/y coordinates
head(spatialCoords(spe))
```

We also have a slot that just holds the images, `imgData`, although looking at it directly isn't very interesting.
But, this stored information will help us make figures!

```{r}
imgData(spe)
```

We should also point out what's in `colData`.
Unlike an `SCE`, this isn't cell metadata. 
IN an `SPE`, it's _spot_ metadata; recall that each spot may contain multiple cells, which can even include partial cells!

```{r}
head(colData(spe))
```

Hmmm, check out that `in_tissue` column!
It contains 0/1 because we read in the `raw` Space Ranger output, which includes all spots including those which don't actually overlap tissue.
Ultimately, we won't want to analyze the spots that are not on top of tissue, so we'll have to deal with that.

Having all this image information in the `SPE` object means we can plot directly.
The package `ggspavis` provides several useful functions for plotting, let's see the highlights:

```{r}
# Spots overlaying the H&E, and we can see the slide boundaries as well
ggspavis::plotVisium(spe)
```

By default this shows the spots, but we can hide them and zoom into the tissue on the slide.
This is a helpful way to pop up the H&E for side-by-side comparisons with other plots you might make.

```{r}
ggspavis::plotVisium(spe, spots = FALSE, zoom = TRUE) 
```

Let's take a moment to chat about Wilm's Tumor - these tumors in the developing kidney are often composed of a couple histologic compartments, blastemal, stromal (with mesenchymal biology), and sometimes epithelial components.
In this section, we can see two major components: the bluer indicating densely cellular, ECM-poor regions consistent with blastema, and paler pink regions consistent with stromal tissue.

Let's actually go ahead and save this plot to a variable; it will be a convenient way for us to quickly pop up the H&E for side-by-side comparison with other plots we'll make later.

```{r}
p_he <- ggspavis::plotVisium(spe, spots = FALSE, zoom = TRUE) 
```


There's another function called `plotCoords` which hides the H&E to just show the spots; this plot is not currently very compelling, but once we start coloring by things it will be much more fun!

```{r}
# no H&E
ggspavis::plotCoords(spe, point_size = 1) 
```


## Quality control

### Removing uninformative bins

We only care about spots on top of tissue, so let's begin by removing the `in_tissue = 0` spots.
(Note that reading in the `filtered_feature_bc_matrix` version of Space Ranger output would already be filtered to only `1` in this column, so we're only taking this step because we read in the `raw` output).

We can visualize which spots those are, and we'll do it over the H&E to clearly see the relationship.
We'll use the `annotate` argument, but `plotVisium` sees that this column is an integer and forces it to use a continuous color scale; we'll go ahead and make it a factor for plotting.

```{r}
# make a factor version of this column to plot with
spe$in_tissue_factor <- as.factor(spe$in_tissue)

ggspavis::plotVisium(
  spe, 
  annotate = "in_tissue_factor", 
  # custom palette so we can see clearly
  pal = c("red", "lightblue")
)
```

- The tissue overhang on the left isn't colored at all - indeed, there aren't spots at those coordinates outside the slide
- Red points are those to filter out - they are uninformative.
Worth noting that some of these appear "inside" the tissue. 

```{r}
# keep only spots that are in the tissue
spe <- spe[, spe$in_tissue == 1]
spe
```

Now, we're down to 3701 spots and we can see this reflected in a plot.
We now only see spots with tissue underneath. 
Onwards!

```{r}
ggspavis::plotVisium(spe)
```

### Filtering for bin quality


We _could_ do the same kind of QC that we do for single-cell data, which (usually) involves defining global thresholds for e.g. number of detected UMIs or percent mito.
However, spatial data doesn't lend itself as well to this type of filtering since global thresholds may not be suitable for the different tissues.
Compared to spatial data, single-cell data more closely (but of course not exactly!) resembles a homogeneous pool of cells. 


Let's go ahead and calculate some QC stats and visualize them:

```{r}
is_mito <- grepl("(^MT-)|(^mt-)", rowData(spe)$Symbol)
mito_ensembl <- rownames(spe)[is_mito]
spe <- scater::addPerCellQC(spe, subsets=list(mito=mito_ensembl))
```

`ggspavis` comes with a helpful QC plotter (makes histograms by default but has a couple more options!)

```{r, fig.width = 10, fig.height = 4}
p1 <- ggspavis::plotObsQC(spe, x_metric = "sum") + ggtitle("sum")
p2 <- ggspavis::plotObsQC(spe, x_metric = "detected") + ggtitle("detected")
p3 <- ggspavis::plotObsQC(spe, x_metric = "subsets_mito_percent") + ggtitle("mito %")

p1 + p2 + p3
```

Distributions don't look like there are any _major_ issues with quality here.
One reason for this is - these are all spots (aggregates of cells), not cells! 
Data is sparse, but not quite as sparse.

Let's plot the same stats on the slide:

```{r, fig.width = 12}
p1 <- plotCoords(spe, annotate="sum", point_size = 1) + ggtitle("sum")
p2 <- plotCoords(spe, annotate="detected", point_size = 1) + ggtitle("detected")
p3 <- plotCoords(spe, annotate="subsets_mito_percent", point_size = 1) + ggtitle("mito %")
p1 + p2 + p3 + p_he
```

We _do_ see a relationship here with tissue type and QC stats that suggests we don't have globally homogeneous patterns - 

- the likely stromal regions look like they have relatively high mito (although still low overall!)
- the likely blastema regions tend to have more detected genes

This tells us that there is local structure in the data, and using a global thresholds could be too aggressive/not aggressive enough depending on the local context.

### Local filtering with Spot Sweeper

A more spatially-suited approach comes from `SpotSweeper` which models QC stats to identify _local_ outliers.

We'll detect local outliers based on these three QC stats.
This function will add some `colData` columns we we can use to find all the local outliers.

```{r}
spe <- SpotSweeper::localOutliers(spe, metric="sum", direction="lower", log=TRUE) # lower-value outliers should be detected
spe <- SpotSweeper::localOutliers(spe, metric="detected", direction="lower", log=TRUE) # lower-value outliers should be detected
spe <- SpotSweeper::localOutliers(spe, metric="subsets_mito_percent", direction="higher", log=FALSE) # higher-value outliers should be detected
``` 

How many of each kind of outlier?

```{r}
c("sum_outliers", "detected_outliers", "subsets_mito_percent_outliers") |>
  purrr::set_names() |>
  purrr::map(\(x) table(spe[[x]]))
```

We'll use a built-in plotting function from `SpotSweeper` to plot these results (the `ggspavis` plotting isn't quite as nice in this case).
Each plot highlights the spots to remove, and spots are colored based on a different stat.
Again we'll include the H&E as a panel for ease of comparison.

```{r, fig.width = 10}
p1 <- SpotSweeper::plotQCmetrics(spe, metric = "sum_log", outliers = "sum_outliers") + ggtitle("log sum")
p2 <- SpotSweeper::plotQCmetrics(spe, metric = "detected_log", outliers = "detected_outliers") + ggtitle("log detected")
p3 <- SpotSweeper::plotQCmetrics(spe, metric = "subsets_mito_percent", outliers = "subsets_mito_percent_outliers") + ggtitle("mito %")

p1 + p2 + p3 + p_he
```
Some of these spots are being flagged by multiple stats, in particular both `sum` and `detected`.
Let's go ahead and filter all these cells out:

```{r}
# combine all outliers into "local_outliers" column to filter on
spe$local_outliers <- as.logical(spe$sum_outliers) |
    as.logical(spe$detected_outliers) |
    as.logical(spe$subsets_mito_percent_outliers)

spe <- spe[, spe$local_outliers == FALSE]
```




## Normalization

With single-cell, a popular normalization approach we adopt involves deconvolution - we do a quick clustering so we can get groups of cells that will share a size factor, for faster processing.
But this isn't suitable for spot-based spatial data since our units aren't cells, but potentially heterogeneous groups of cells (whole or partial).

We'll therefore use going to use library-size normalization here to correct for sequencing depth but preserve the other heterogeneous biological signal.
Bear in mind the caveat that in some cases library size itself is also confounded with spatial structure (https://link.springer.com/article/10.1186/s13059-024-03241-7); so, keep your eyes peeled for normalization developments, since this space is evolving rapidly!

```{r}
spe <- scuttle::computeLibraryFactors(spe)
spe <- scuttle::logNormCounts(spe)
spe # now we have a logcounts assay
```

## Dimension reduction

For this step, we're going to get a reduced dimension representation using _just_ the lens of gene expression, "ignoring" spatial information.
(Later, we'll see complementary approaches to some of this which leverages spatial information).

This all tells us we have to be careful when interpreting analyses on spatial data: "to what extent was spatial information taken into account" is something you'll want to understand.

Let's do HVG selection (again, this does not consider spatial patterns! we'll learn about _spatially_ variable genes later), PCA, UMAP, and clustering (once again, this won't be spatial regions! just _spot_ similarity based on expression - that's not the same as cells, either!)
So, we'll use a `SCE`-style approach:


```{r}
num_genes <- 2000
gene_variance <- scran::modelGeneVar(spe)
hv_genes <- scran::getTopHVGs(gene_variance, n = num_genes)

spe <- scater::runPCA(spe, subset_row = hv_genes)
spe <- scater::runUMAP(spe, dimred = "PCA")

nn_clusters <- scran::clusterCells(
  spe, # object to perform clustering on
  use.dimred = "PCA", # perform clustering on the PCA matrix
  BLUSPARAM = bluster::NNGraphParam(
    k = 20,
    type = "jaccard",
    cluster.fun = "louvain"
  )
)
spe$nn_cluster <- nn_clusters
```


We'll plot the UMAP colored by clusters, because we love UMAPs:

```{r}
scater::plotUMAP(spe, color_by = "nn_cluster") +
  # use distinct palette so we can match up with a spatial view next
  ggokabeito::scale_color_okabe_ito()
```

How do these clusters come out when using the spatial layout?
We have coordinates, after all - let's use them!

```{r}
p1 <- ggspavis::plotCoords(spe, annotate = "nn_cluster", point_size = 1) +
  # matching palette to UMAP
  ggokabeito::scale_color_okabe_ito()

p1 + p_he
```

A lot of the clusters are intermingled in space, showing that this analysis is really not spatially-aware!
But, we do see some interesting patterns - check out clusters 1, 5, & 7 in particular - they look stroma-y; also, cluster 8 ooks like a defined region in the H&E, but I'm not a pathologist so let's not overinterpret here.
When expression and tissue structure are correlated, expression-only clusters can pick up on certain spatial regions, but this is _not_ the same as finding "true" spatial domains. 


## Exploring spot-based spatial data

Let's explore this data a little more, using some marker genes.
We don't have specific cells as units here, but we can use marker gene expression to build some descriptive intuition for the data. 

We've defined some marker genes here for visualization that correspond to expected Wilm's Tumor biology:

```{r}
marker_genes <- c(
  "WT1 (kidney development, maglinant in WT)" = "ENSG00000184937",
  "SIX1 (blastema, malignant)" = "ENSG00000126778",
  "MYCN (malignant)" = "ENSG00000134323",
  "COL1A1 (fibroblast/mesenchymal)" = "ENSG00000108821",
  "TAGLN (myofibroblast/mesenchymal)" = "ENSG00000149591"
)
```

Let's plot the expression of these genes, using both UMAP and the spatial layouts to compare:

```{r, fig.width = 12}
cluster_umap <- scater::plotUMAP(spe, color_by = "nn_cluster", point_size = 0.5, point_alpha = 0.5) +
  ggtitle("expression-based clusters") + 
  coord_equal() +
  ggokabeito::scale_color_okabe_ito() 

marker_umaps <- marker_genes |>
  purrr::imap(
    \(ensembl, gene_name) {
      scater::plotUMAP(spe, color_by = ensembl, point_size = 0.5, point_alpha = 0.5) + ggtitle(gene_name) + coord_equal()
    }
  ) |>
  # cluster umap and then the marker gene umaps
  append(values = cluster_umap, after = 0)

patchwork::wrap_plots(marker_umaps, nrow = 2)
```


```{r, fig.width = 14}
cluster_coords <- ggspavis::plotCoords(spe, annotate = "nn_cluster", point_size = 0.75) +
  ggtitle("expression-based clusters") + 
  ggokabeito::scale_color_okabe_ito() 

marker_coords <- marker_genes |>
  purrr::imap(
    \(ensembl, gene_name) {
      # default assay is counts, override!
      ggspavis::plotCoords(spe, annotate = ensembl, point_size = 0.75, assay = "logcounts") +
        scale_color_distiller(palette = "Blues", direction = 1) + 
        ggtitle(gene_name)
    }
  ) |>
  # cluster cooords and then the marker gene coords
  append(values = cluster_coords, after = 0) 

p_he + patchwork::wrap_plots(marker_coords, nrow = 2) + plot_layout(widths = c(1,2))
```


Based on these observations, it seems like there could be some spatial patterns/variability here; _interpret_.
We'll talk more rigorously about quantifying spatially-variable genes later in the workshop, but for now, we can take this opportunity to to ask some descriptive questions about these genes' expression across space.





## Session Info

```{r}
sessionInfo()
```
