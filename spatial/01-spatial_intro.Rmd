---
title: "Importing, processing, and exploring Visium data"
author: Data Lab for ALSF
date: 2026
output:
  html_notebook:
    toc: true
    toc_float: true
---

## Objectives

- Read Visium data into R
- Filter to spots overlapping tissue
- Calculate quality control measures on spatial transcriptomic data
- Remove likely low-quality spots with `SpotSweeper()`
- Normalize spatial expression data
- Visualize spatial transcriptomic data 

## Introduction

In this notebook, we'll learn some basic import, processing, and visualization of a Visium data set, starting with the Space Ranger output. 

The data we'll use in this notebook is from an anaplastic Wilms Tumor sample in the [Single-cell Pediatric Cancer Atlas](https://scpca.alexslemonade.org/projects/SCPCP000006).
This sample was processed using first-generation 3' Visium technology, and it was quantified with `Space Ranger 1.3.1`.

## Set up

To begin, we'll load the core library for spatial transcriptomic objects in Bioconductor, `SpatialExperiment`.
We won't be doing any calculations involving random numbers here, so we don't need to set a seed.

```{r libraries}
# Load libraries

# The main class we use for spatial transcriptomic data
library(SpatialExperiment)

# For combining plots
library(patchwork)
```

### Directories and files

Next we'll define paths and files.

```{r inputs, live=TRUE}
# define sample id we'll be analyzing 
sample_id <- "SCPCS000190"

# main data directory for this sample
data_dir <- file.path("data/wilms-tumor", sample_id)

# Path to Space Ranger output
raw_spaceranger_dir <- file.path(data_dir, "outs")

# reference data directory
ref_dir <- file.path("data/reference")

# Path to mitochondrial genes table
mito_file <- file.path(ref_dir, "hs_mitochondrial_genes.tsv")
```


```{r outputs}
# Directory and file to save output
normalized_dir <- file.path(data_dir, "normalized")

# create the directory if it does not exist
fs::dir_create(normalized_dir)

# output RDS file for normalized Spatial Experiment (SPE) object
output_spe_file <- file.path(
  normalized_dir,
  "SCPCS000190_normalized.rds"
)
```



## Reading Space Ranger data

We'll use the `VisiumIO` package to read this data in.
The directory structure typically looks something like this, with differences for different technology versions.

```markdown
_add file tree here with standard visium output_
```

Let's see what we have:

```{r dir-spaceranger, live = TRUE}
dir(raw_spaceranger_dir)
```

The filtered/raw matrix directories are analogous to we'd get from `Cell Ranger` for single-cell sequencing, but the `spatial` directory contains spatial information, including images, that augment the data with its full spatial context.
Without this directory, we could still read in the filtered/raw and make an `SCE`, but you wouldn't have the spatial info.

Along those lines, let's have a closer look at what's in the `spatial` directory:

```{r dir-spatial, live = TRUE}
dir(
  file.path(raw_spaceranger_dir, "spatial")
)
```

Placeholder to describe each image file:

- `"aligned_fiducials.jpg"`
- `"detected_tissue_image.jpg"` 
- `"tissue_hires_image.png"` 
- `"tissue_lowres_image.png"`
- `"tissue_positions_list.csv"`
- `"scalefactors_json.json"`   

It's worth mentioning that this is a slightly older technology than the current Visium `CytAssist` image, which means there is no specific `Cytassist` image.
This won't affect our analysis, but worth noting when reading in since by default the functions assume that image is present. 


We'll import the raw, not filtered, version of the data here so that we can see full processing steps and save it to a variable called `spe`, using the package `VisiumIO`.

```{r import-visium, live = TRUE}
# path to quantified RNA 10X output
rna_dir <- file.path(raw_spaceranger_dir, "raw_feature_bc_matrix")

# path to spatial 10X output
spatial_dir <- file.path(raw_spaceranger_dir, "spatial")

spe <- VisiumIO::import(
  VisiumIO::TENxVisium(
    # path that contains the sequencing data
    resources = rna_dir,
    # path that contains the spatial data
    spatialResource = spatial_dir,
    # which image(s) to import - use lowres to save some memory/space
    # we also need to override the default since it assumes there is a CytAssist image
    images = "lowres"
  )
)

# print the spe
spe
```

Let's get to know our `SPE` object!
It's essentially an `SCE`, but with a few more bells and whistles.
This means there are some functions we'll use to explore it that you might recognize, but there will also be some new ones only used for `SPE` objects.

First, note that we have 4992 spots - this is not a random value.
It's the number of spots on a Visium 6.5 x 6.5 slide. 

Like `SCE`s, we have slots like `assays` for count matrices, `rowData` for feature metadata, and `colData` for _spot_ metadata - recall, our experimental units are not individual cells in spatial transcriptomics.
Let's take a tour:

```{r spe-rowdata}
rowData(spe)
```

```{r spe-assays}
counts(spe)[1:10, 1:10]
```
Again, for the colData`, we're looking at spots and not cells.
With this technology, where each spot is 55 Âµm, we can expect there's somewhere between 1-10 cells per spot.

```{r spe-coldata, live = TRUE}
colData(spe)
```
Check out that `in_tissue` column.
It contains 0/1 because we read in the raw `Space Ranger` output, which includes all spots including those which don't actually overlap tissue.
Ultimately, we won't want to analyze the spots that are not on top of tissue, so we'll have to deal with that.

Unlike `SCE`s, we have spatial information in a dedicated `spatialCoords` slot which contains the x/y coordinates on the slide:
```{r spe-spatialcoords, live = TRUE}
# handy function from our code package SpatialExperiment
# literally is giving x/y coordinates
spatialCoords(spe) |> head()
```

We also have a slot that just holds the images, `imgData`, although looking at it directly isn't very interesting.
But, this stored information will help us make figures!

```{r spe-imgdata, live = TRUE}
imgData(spe)
```

### Introduction to spatial data visualization

Before we get further, let's go ahead and actually look at our data.
Because the spatial and image information is contained in the object, we can plot directly from this object using the viz package `ggspavis`.


```{r plot-visium, live = TRUE, fig.width = 5}
ggspavis::plotVisium(spe)
```

Here, we see the spots overlaid on the slide as well as slide boundaries.
You'll notice that every single spot is shown, including ones that don't overlap tissue directly - indeed, all 4992 spots are present int he `SPE` right now!

By default this shows the spots, but we can hide them and zoom into the tissue on the slide.
This is a helpful way to pop up the H&E for side-by-side comparisons with other plots you might make.

```{r plot-visium-zoom, live = TRUE, fig.width = 5}
ggspavis::plotVisium(
  spe, 
  spots = FALSE, # don't show the spots
  zoom = TRUE    # zoom into the slide area
) 
```

TODO: save this text for when we actually plot genes?
Let's take a moment to chat about Wilms Tumor - these tumors in the developing kidney are often composed of a couple histologic compartments, blastemal, stromal (with mesenchymal biology), and sometimes epithelial components.
In this tissue section, we can see two major components: the bluer indicating densely cellular, ECM-poor regions consistent with blastema, and paler pink regions consistent with stromal tissue.


There's another function in `ggspavis` called `plotCoords` which hides the H&E to just show the spots; this plot is not currently very compelling without any colors, but we'll add those soon!

```{r plot-coords, live = TRUE, fig.width = 5}
# plot just the spots
ggspavis::plotCoords(spe) 
```

The spot layout looks a bit different.
By default, this function will only plot spots that overlay tissue, even if those spots are still in the `SPE`.

We can override this if we want, but really what we want to do is actually remove those spots since they are entirely uninformative - we'll do this in the next section.


## Filtering empty spots

We only care about spots on top of tissue, so let's begin by removing the `in_tissue = 0` spots.
Note that if we had read in the `filtered_feature_bc_matrix` instead, the data would already be filtered to only `1` in this column, but we need to take this step because we read in the `raw`. 
We can make a rough analogy, that this analysis step is like filtering empty droplets to retain only droplets with cells in scRNA-seq, but here we're retaining only spots over tissue.

We can visualize which spots those are, and we'll do it over the H&E to clearly see the relationship.
We'll use the `annotate` argument, but `plotVisium` sees that this column is an integer and forces it to use a continuous color scale; we'll go ahead and make it a factor for plotting.

```{r plot_in_tissue, fig.width = 5}
# make a factor version of this column to plot with
spe$in_tissue_factor <- as.factor(spe$in_tissue)

ggspavis::plotVisium(
  spe, 
  annotate = "in_tissue_factor", 
  # custom palette so we can see clearly
  pal = c("red", "lightblue")
)
```

- The purple tissue overhang on the left isn't colored at all - indeed, there aren't spots at those coordinates outside the slide
- Red points are those to filter out - they are uninformative since they don't overlap tissue.

```{r filter_in_tissue, live = TRUE}
# keep only spots that are in the tissue and save to filtered_spe
filtered_spe <- spe[, spe$in_tissue == 1]

# print resulting filtered_spe
filtered_spe
```


Now, we're down to 4120 spots from the original 4992, but that's still a pretty good amount. 
But not all of these spots are necessarily good quality, so we'll want to do some additional QC filtering next.

## Filtering low-quality spots

### Filtering with global QC thresholds

As a first step towards filtering, we can borrow some approaches from scRNA-seq and calculate some quality-control measures. 
Let's do that and have a look - we'll get our mito genes for QC calculations and we'll use `scran::addPerCellQC()` like we might for single-cell.

```{r get mitochondrial genes}
# read in a table of mitochondrial genes and extract ids
mito_genes <- readr::read_tsv(mito_file) |>
  # filter to only the genes that are found in our dataset
  dplyr::filter(gene_id %in% rownames(filtered_spe)) |>
  # create a vector from the gene_id column
  dplyr::pull(gene_id)
```

```{r calculate qc, live = TRUE}
filtered_spe <- scuttle::addPerCellQC(
  filtered_spe,
  subsets = list(mito = mito_genes)
)

# print resulting colData to see QC stats
colData(filtered_spe) |> head()
```

`ggspavis` comes with a helpful QC plotter (makes histograms by default but has a couple more options!).
These are `ggplot2` objects, so we can use `ggplot2` code with them like add a title to each.

```{r global qc distributions, fig.width = 12, fig.height = 4}
p1 <- ggspavis::plotObsQC(filtered_spe, x_metric = "sum") + ggplot2::ggtitle("sum")
p2 <- ggspavis::plotObsQC(filtered_spe, x_metric = "detected") + ggplot2::ggtitle("detected")
p3 <- ggspavis::plotObsQC(filtered_spe, x_metric = "subsets_mito_percent") + ggplot2::ggtitle("mito %")

# Add plots together with patchwork
p1 + p2 + p3
```

These distributions all look unimodal without too much skew, which is different from how distributions from single-cell data might look. With single-cell data, we might typically see long right tails reflecting differences in cell biology or cell quality.
Here, QC stats are calculated per spot aka for aggregates of cells, extremes end up getting smoothed out.

Let's plot the same stats on the slide:

```{r global qc coords, fig.width = 10}
p1 <- ggspavis::plotCoords(filtered_spe, annotate="sum", point_size = 1) + ggplot2::ggtitle("sum")
p2 <- ggspavis::plotCoords(filtered_spe, annotate="detected", point_size = 1) + ggplot2::ggtitle("detected")
p3 <- ggspavis::plotCoords(filtered_spe, annotate="subsets_mito_percent", point_size = 1) + ggplot2::ggtitle("mito %")

p1 + p2 + p3
```

Now, we start to see there's more to the story.
There is spatial heterogeneity in these QC stats.

Let's plot the H&E again to see any correlation:

```{r show he for qc, fig.width = 5}
ggspavis::plotVisium(filtered_spe, spots = FALSE, zoom = TRUE)
```

We see that:

- the likely stromal regions have distinctly higher mitochondrial percentages (although these values are pretty low all around!) and fewer detected genes/UMIs
- the likely blastema regions tend to have more detected genes

This tells us that there is local structure in the data that we might like our QC approach to take into consideration.

Still, let's try to pick some global thresholds and see what would be removed, trying to infer reasonable thresholds from the histograms.
We'll choose some thresholds around the distribution's tails.


```{r global filter spe, live = TRUE}
# create a logical vector of QC filters
filter_spot <- filtered_spe$sum < 5000 |
  filtered_spe$detected < 4000 |
  filtered_spe$subsets_mito_percent > 4

# how many spots would be removed?
sum(filter_spot)
```

Let's have a look at which spots these would be:

```{r plot global filter, fig.width = 5}
# add filter_spot to object
# make it a factor to use custom discrete colors
filtered_spe$filter_spot <- as.factor(filter_spot)

# plot which spots would be removed
ggspavis::plotCoords(
  filtered_spe, 
  annotate="filter_spot", 
  point_size = 1.5, 
  # custom palette: red spots flagged for removal
  pal = c("gray", "red")
) 
```

Using these global thresholds, we can see that QC is confounded by biology. 
If we filter these spots, we'll be removing spots associated with a particular tissue region.
This shows that global thresholds may not be suitable for data with this kind of heterogeneity, so a different approach could be warranted.
Worth noting, this is not strictly a spatial transcriptomics issue; there can be quite a bit of heterogeneity in scRNA-seq data too depending on what was sequenced!
Always plot your data!

### Filtering with local QC thresholds


## Normalization

## Exploring marker gene expression


## Session info

To conclude, we'll run the `sessionInfo()` command to print out exactly what system setting and R package versions were used to run this code.

```{r}
sessionInfo()
```

