---
title: "Importing, processing, and exploring Visium data"
author: Data Lab for ALSF
date: 2026
output:
  html_notebook:
    toc: true
    toc_float: true
---

## Objectives

- Read Visium data into R
- Filter to spots overlapping tissue
- Calculate quality control measures on spatial transcriptomic data
- Remove likely low-quality spots with `SpotSweeper()`
- Normalize spatial expression data
- Visualize spatial transcriptomic data 

## Introduction

In this notebook, we'll learn some basic import, processing, and visualization of a Visium data set, starting with the Space Ranger output. 

The data we'll use in this notebook is from an anaplastic Wilms Tumor sample in the [Single-cell Pediatric Cancer Atlas](https://scpca.alexslemonade.org/projects/SCPCP000006).
This sample was processed using first-generation 3' Visium technology, and it was quantified with `Space Ranger 1.3.1`.

## Set up

To begin, we'll load the core library for spatial transcriptomic objects in Bioconductor, `SpatialExperiment`.
We won't be doing any calculations involving random numbers here, so we don't need to set a seed.

```{r libraries}
# Load libraries

# The main class we use for spatial transcriptomic data
library(SpatialExperiment)

# To support plotting
library(patchwork)

# Set ggplot2 theme
ggplot2::theme_set(ggplot2::theme_bw())
```

### Directories and files

Next we'll define paths and files.

```{r inputs, live=TRUE}
# define sample id we'll be analyzing 
sample_id <- "SCPCS000190"

# main data directory for this sample
data_dir <- file.path("data/wilms-tumor", sample_id)

# Path to Space Ranger output
raw_spaceranger_dir <- file.path(data_dir, "outs")

# reference data directory
ref_dir <- file.path("data/reference")

# Path to mitochondrial genes table
mito_file <- file.path(ref_dir, "hs_mitochondrial_genes.tsv")
```


```{r outputs}
# Directory and file to save output
normalized_dir <- file.path(data_dir, "normalized")

# create the directory if it does not exist
fs::dir_create(normalized_dir)

# output RDS file for normalized Spatial Experiment (SPE) object
output_spe_file <- file.path(
  normalized_dir,
  "SCPCS000190_normalized.rds"
)
```



## Reading Space Ranger data

We'll use the `VisiumIO` package to read this data in.
The directory structure typically looks something like this, with differences for different technology versions.

```markdown
_add file tree here with standard visium output_
```

Let's see what we have:

```{r dir-spaceranger, live = TRUE}
dir(raw_spaceranger_dir)
```

The filtered/raw matrix directories are analogous to we'd get from `Cell Ranger` for single-cell sequencing, but the `spatial` directory contains spatial information, including images, that augment the data with its full spatial context.
Without this directory, we could still read in the filtered/raw and make an `SCE`, but you wouldn't have the spatial info.

Along those lines, let's have a closer look at what's in the `spatial` directory:

```{r dir-spatial, live = TRUE}
dir(
  file.path(raw_spaceranger_dir, "spatial")
)
```

Placeholder to describe each image file:

- `"aligned_fiducials.jpg"`
- `"detected_tissue_image.jpg"` 
- `"tissue_hires_image.png"` 
- `"tissue_lowres_image.png"`
- `"tissue_positions_list.csv"`
- `"scalefactors_json.json"`   

It's worth mentioning that this is a slightly older technology than the current Visium `CytAssist` image, which means there is no specific `Cytassist` image.
This won't affect our analysis, but worth noting when reading in since by default the functions assume that image is present. 


We'll import the raw, not filtered, version of the data here so that we can see full processing steps and save it to a variable called `spe`, using the package `VisiumIO`.

```{r import-visium, live = TRUE}
# path to quantified RNA 10X output
rna_dir <- file.path(raw_spaceranger_dir, "raw_feature_bc_matrix")

# path to spatial 10X output
spatial_dir <- file.path(raw_spaceranger_dir, "spatial")

spe <- VisiumIO::import(
  VisiumIO::TENxVisium(
    # path that contains the sequencing data
    resources = rna_dir,
    # path that contains the spatial data
    spatialResource = spatial_dir,
    # which image(s) to import - use lowres to save some memory/space
    # we also need to override the default since it assumes there is a CytAssist image
    images = "lowres"
  )
)

# print the spe
spe
```

Let's get to know our `SPE` object!
It's essentially an `SCE`, but with a few more bells and whistles.
This means there are some functions we'll use to explore it that you might recognize, but there will also be some new ones only used for `SPE` objects.

First, note that we have 4992 spots - this is not a random value.
It's the number of spots on a Visium 6.5 x 6.5 slide. 

Like `SCE`s, we have slots like `assays` for count matrices, `rowData` for feature metadata, and `colData` for _spot_ metadata - recall, our experimental units are not individual cells in spatial transcriptomics.
Let's take a tour:

```{r spe-rowdata}
rowData(spe)
```

```{r spe-assays}
counts(spe)[1:10, 1:10]
```
Again, for the colData`, we're looking at spots and not cells.
With this technology, where each spot is 55 Âµm, we can expect there's somewhere between 1-10 cells per spot.

```{r spe-coldata, live = TRUE}
colData(spe)
```
Check out that `in_tissue` column.
It contains 0/1 because we read in the raw `Space Ranger` output, which includes all spots including those which don't actually overlap tissue.
Ultimately, we won't want to analyze the spots that are not on top of tissue, so we'll have to deal with that.

Unlike `SCE`s, we have spatial information in a dedicated `spatialCoords` slot which contains the x/y coordinates on the slide:
```{r spe-spatialcoords, live = TRUE}
# handy function from our code package SpatialExperiment
# literally is giving x/y coordinates
spatialCoords(spe) |> head()
```

We also have a slot that just holds the images, `imgData`, although looking at it directly isn't very interesting.
But, this stored information will help us make figures!

```{r spe-imgdata, live = TRUE}
imgData(spe)
```

### Introduction to spatial data visualization

Before we get further, let's go ahead and actually look at our data.
Because the spatial and image information is contained in the object, we can plot directly from this object using the viz package [`ggspavis`](https://bioconductor.posit.co/packages/release/bioc/vignettes/ggspavis/inst/doc/ggspavis_overview.html).


```{r plot-visium, live = TRUE}
#| fig.width: 7

ggspavis::plotVisium(spe)
```

Here, we see the spots overlaid on the slide as well as slide boundaries.
You'll notice that every single spot is shown, including ones that don't overlap tissue directly - indeed, all 4992 spots are present in the `SPE` right now!

By default this shows the spots, but we can hide them and zoom into the tissue on the slide.
This is a helpful way to pop up the H&E for side-by-side comparisons with other plots you might make.

```{r plot-visium-zoom, live = TRUE}
#| fig.width: 5

ggspavis::plotVisium(
  spe, 
  spots = FALSE, # don't show the spots
  zoom = TRUE    # zoom into the slide area
) 
```

TODO: save this text for when we actually plot genes?
Let's take a moment to chat about Wilms Tumor - these tumors in the developing kidney are often composed of a couple histologic compartments, blastemal, stromal (with mesenchymal biology), and sometimes epithelial components.
In this tissue section, we can see two major components: the bluer indicating densely cellular, ECM-poor regions consistent with blastema, and paler pink regions consistent with stromal tissue.


There's another function in `ggspavis` called `plotCoords` which hides the H&E to just show the spots; this plot is not currently very compelling without any colors, but we'll add those soon!

```{r plot-coords, live = TRUE}
#| fig.width: 7

# plot just the spots
ggspavis::plotCoords(spe) 
```

The spot layout looks a bit different.
By default, this function will only plot spots that overlay tissue, even if those spots are still in the `SPE`.

We can override this if we want, but really what we want to do is actually remove those spots since they are entirely uninformative - we'll do this in the next section.


## Filtering empty spots

We only care about spots on top of tissue, so let's begin by removing the `in_tissue = 0` spots.
Note that if we had read in the `filtered_feature_bc_matrix` instead, the data would already be filtered to only `1` in this column, but we need to take this step because we read in the `raw`. 
We can make a rough analogy, that this analysis step is like filtering empty droplets to retain only droplets with cells in scRNA-seq, but here we're retaining only spots over tissue.

We can visualize which spots those are, and we'll do it over the H&E to clearly see the relationship.
We'll use the `annotate` argument, but `plotVisium` sees that this column is an integer and forces it to use a continuous color scale; we'll go ahead and make it a factor version of it to plot with.

```{r plot_in_tissue}
#| fig.width: 7

# make a factor version of this column to plot with, specifying "No" and "Yes" plot labels
spe$in_tissue_factor <- factor(spe$in_tissue, levels = c(0, 1), labels = c("No", "Yes"))

ggspavis::plotVisium(
  spe, 
  annotate = "in_tissue_factor", 
  # specify a custom palette
  pal = c("Yes" = "yellow", "No" = "red")
) +
  # use ggplot2::guides() to override legend titles in ggspavis
  ggplot2::guides(
    fill = ggplot2::guide_legend(
      title = "Spot overlaps tissue", 
      override.aes = list(size = 2)
    )
  )
```

- The purple tissue overhang on the left isn't colored at all - indeed, there aren't spots at those coordinates outside the slide
- Red points are those to filter out - they are uninformative since they don't overlap tissue.

```{r filter_in_tissue, live = TRUE}
# keep only spots that are in the tissue and save to filtered_spe
filtered_spe <- spe[, spe$in_tissue == 1]

# print resulting filtered_spe
filtered_spe
```


Now, we're down to 4120 spots from the original 4992, but that's still a pretty good amount. 
But not all of these spots are necessarily good quality, so we'll want to do some additional QC filtering next.

## Filtering low-quality spots

### Filtering with global QC thresholds

As a first step towards filtering, we can borrow some approaches from scRNA-seq and calculate some quality-control measures. 
Let's do that and have a look - we'll get our mitochondrial genes for QC calculations and we'll use `scran::addPerCellQC()` like we might for single-cell (except here it adds per spot).

```{r get mitochondrial genes}
# read in a table of mitochondrial genes and extract ids
mito_genes <- readr::read_tsv(mito_file) |>
  # filter to only the genes that are found in our dataset
  dplyr::filter(gene_id %in% rownames(filtered_spe)) |>
  # create a vector from the gene_id column
  dplyr::pull(gene_id)
```

```{r calculate qc, live = TRUE}
filtered_spe <- scuttle::addPerCellQC(
  filtered_spe,
  subsets = list(mito = mito_genes)
)

# print resulting colData to see QC stats
colData(filtered_spe) |> head()
```

`ggspavis` comes with a helpful QC plotter (makes histograms by default but has a couple more options!).
These are `ggplot2` objects, so we can use `ggplot2` code with them like add a title to each.

```{r global qc distributions}
#| fig.width: 12
#| fig.height: 4

# Extract the colData into a data frame for plotting
coldata_df <- colData(filtered_spe) |>
  as.data.frame() |>
  # relocate barcodes to an actual column instead of rownames
  tibble::rownames_to_column("barcode") 

# Define density plots for each statistic
qc_plot_sum <- ggplot2::ggplot(coldata_df) + 
  ggplot2::aes(x = sum) + 
  ggplot2::geom_density(fill = "lightblue") +
  ggplot2::labs(title = "Total unique UMIs")

qc_plot_detected <- ggplot2::ggplot(coldata_df) + 
  ggplot2::aes(x = detected) + 
  ggplot2::geom_density(fill = "steelblue") +
  ggplot2::labs(title = "Total detected genes")

qc_plot_mito <- ggplot2::ggplot(coldata_df) + 
  ggplot2::aes(x = subsets_mito_percent) + 
  ggplot2::geom_density(fill = "slateblue") +
  ggplot2::labs(title = "Mitochondrial %")


# Plot together with patchwork
qc_plot_sum + qc_plot_detected + qc_plot_mito
```

These distributions all look unimodal without too much skew, which is different from how distributions from single-cell data might look. 

Placeholder for discussion about differences/similarities in technical artifacts between data types:

- One of the reasons we filter on these metrics in single cell is due to potential differences in cell capture across droplets
- This isn't a factor in spatial where QC stats are calculated per spot aka for aggregates of cells, extremes end up getting smoothed out
  - Differences in capture aren't due to heterogeneity from droplet capture but because of tissue biology/prep:
  - We have distinct regions of tissue or groups of cells that have less genes detected than other ones (biology) or because the tissue didn't lay on the slide completely flat or wasn't completely permeabilized in all spots equally

For example, let's consider the mitochondria percent distribution:

- We do see a long right-tail for mitochondrial percentages, but the values are all really low which doesn't suggest any major quality issues.
- The lower values here vs in single-cell data make sense because cells weren't stressed in the same way they would be for single-cell library prep; more likely to tell you about the tissue quality itself (biology) and not spot quality (technical) 

Let's plot the same stats on the slide.
We'll include the H&E plot here as well for an immediate comparison.

```{r global qc coords}
#| message: FALSE
#| fig.width: 10

he_plot <- ggspavis::plotVisium(filtered_spe, spots = FALSE, zoom = TRUE) +
  ggplot2::ggtitle("H&E") +
  # add styling to match other panels
  ggplot2::theme(
    plot.title = ggplot2::element_text(
      hjust = 0.5, 
      margin = ggplot2::margin(0, 0, 0.1, 0)
    ),
    panel.border = ggplot2::element_rect(color = "black", linewidth = 0.25)
  )

qc_spots_sum <- ggspavis::plotCoords(filtered_spe, annotate="sum", point_size = 1) + 
  # use distinct palette
  ggplot2::scale_color_distiller(palette = "Blues", direction = 1) +
  ggplot2::ggtitle("Total unique UMIs")

qc_spots_detected <- ggspavis::plotCoords(filtered_spe, annotate="detected", point_size = 1) + 
  # use distinct palette
  ggplot2::scale_color_distiller(palette = "YlOrRd", direction = 1) +
  ggplot2::ggtitle("Total detected genes")

qc_spots_mito <- ggspavis::plotCoords(filtered_spe, annotate="subsets_mito_percent", point_size = 1) + 
  # use distinct palette
  ggplot2::scale_color_distiller(palette = "Greens", direction = 1) +
  ggplot2::ggtitle("Mitochondrial %")

# wrap plots with patchwork into 2x2 grid
patchwork::wrap_plots(
  he_plot, 
  qc_spots_sum, 
  qc_spots_detected, 
  qc_spots_mito, 
  nrow = 2
)
```

Now, we start to see there's more to the story.
There is spatial heterogeneity in these QC stats:

- the likely stromal regions have distinctly higher mitochondrial percentages (although again, these values are pretty low all around!) and fewer detected UMIs/genes
- the likely blastema regions tend to have more detected UMIs/genes

This tells us that there is local structure in the data that we might like our QC approach to take into consideration.
Using these global thresholds, we can see that QC is confounded by biology. 
If we filter these spots, we'll be removing spots associated with a particular tissue region.
This shows that global thresholds may not be suitable for data with this kind of heterogeneity, so a different approach could be warranted.
Worth noting, this is not strictly a spatial transcriptomics issue; there can be quite a bit of heterogeneity in scRNA-seq data too depending on what was sequenced!
Always plot your data!

### Filtering with local QC thresholds

Rather than finding outliers based on overall QC stats derived across biologically distinct domains/tissue regions, we can instead look for _local_ outliers to filter, i.e. spots with properties that deviate from their neighborhood of nearby spots.
Placeholder text to introduce [`SpotSweeper`](https://www.bioconductor.org/packages/3.22/bioc/vignettes/SpotSweeper/inst/doc/getting_started.html):

- Evaluates spots relative to their local neighborhood which is defined with `kNN`
- Calculates local means and variances of standard QC metrics to flag outliers for removal within a local tissue context
- Can be used to find both individual outlying spots as well as so-called "hangnails" which are regional artifacts caused by e.g. issues in tissue prep or other technical issues
  - Note that hangnail detection is performed using variance in mitochondrial percentages. 
  Since our values for mitochondrial percentage are very low with minimal variance, hangnail detection won't be relevant for us here

We'll detect local outliers based using `SpotSweeper::localOutliers()` which takes these arguments:

- `metric`: name of column in `colData` with QC stat of interest
- `direction`: are lower value or higher value outliers bad?
  - e.g. we'd say "lower" for detected (we don't want low detected values), and we'd say "higher" for mitochondrial percentage
- `n_neighbors`: number of neighbors for building the `kNN` graph; Default is 36
- `log`: whether to consider the `log1p` of the metric; Default is `FALSE`
  - The method assumes a normal distribution, so logging a metric may be needed to meet assumptions
  - logging "detected" and "sum" is often recommended because these distributions are unbounded and span orders of magnitude
  - logging "mitochondrial" is not often recommended because it's bounded `[0,100]` and logging percentages can distort the distribution
- `cutoff`: Threshold for identifying outliers; Default is 3, meaning 3 standard deviations from the mean (think z-scores)
  - Can make this higher to be more stringent, lower to be less stringent, but don't go too low or you're not detecting outliers anymore
- `workers`: Number of cores for parallel processing; Default is 1

This function returns an `SPE` object with added `colData` columns we can use to find all the local outliers.

Let's start off by looking for library size ("sum" column) outliers:

```{r spotsweeper-sum, live = TRUE}
# specify defaults for sum to be explicit
filtered_spe <- SpotSweeper::localOutliers(
  filtered_spe, 
  metric = "sum", 
  direction = "lower", 
  n_neighbors = 36, 
  log = TRUE,
  cutoff = 3
)
```


What do we have now?

```{r coldata-spotsweeper-sum, live = TRUE}
colData(filtered_spe)
```
New columns include:

- `sum_log`: The `log1p()` (i.e., `log(x+1)`) of the `sum` column
- `sum_outliers`: Logical whether or not the spot is an outlier
- `sum_z`: The _local_ z-score for `sum_log`, among spots in the local neighborhood.
  - 0: same as neighbors on average
  - high positive value: much higher `sum` than neighbors
  - low negative value: much lower `sum` than neighbors, which in this case would be the ones to filter
  
We can see some of this relationship - the spots flagged as outliers are those with a `sum_z` less than -3, the default cutoff for the lower direction:
  
```{r outliers-boxplot}
filtered_spe_coldata <- colData(filtered_spe) |>
  as.data.frame() 

# TODO: Does having this plot help explain or not?
# I chose jitter because we can see all the points and know right away most are not outliers
ggplot2::ggplot(filtered_spe_coldata) + 
  ggplot2::aes(x = sum_outliers, y = sum_z) + 
  ggplot2::geom_jitter(size = 0.5) + 
  ggplot2::geom_hline(yintercept = -3, color = "red")
```


Based on this metric, most spots are not outliers, and while most are fairly close to the 3 cutoff, several are are more extreme outliers!
Let's plot this next to the H&E:
We'll use a plotting function from `SpotSweeper` )which turns out to be a bit easier to see that a `ggspavis` plot.

```{r spotsweeper-plotqc-sum}
SpotSweeper::plotQCmetrics(
  filtered_spe, 
  metric = "sum_log", # how to color spots
  outliers = "sum_outliers", # which spots to highlight with an outline
  colors = c("blue", "yellow") # low -> high palette colors. TODO: right now this is for Ally, but we don't need to do this; can use ggplot2::scale_fill_distiller instead and turn off messages
) 
```
Here, we can see how spots are distributed across the slide and can clearly tell that see some outliers are more outlying than others.
Would we have caught these if we had filtered with global thresholds?

```{r spotsweeper-vs-global}
filtered_spe_coldata |>
  dplyr::filter(sum_outliers) |>
  # rename for clarity
  dplyr::select(
    global_sum = sum, 
    spotsweeper_sum_z = sum_z
  ) |>
  dplyr::arrange(global_sum)
```

It's likely we would have caught a lot of these, but not all, especially the flagged spots with more than 5000 UMIs (a typical single-cell threshold for library size which we are learning is not necessarily the right way to think about spatial data).

**TODO: I don't know how I feel about including the next chunk - who has thoughts? Leaning heavily much towards removing it, but I wanted to include for now in case it sparks an idea during review!** 
How would this have changed if shifted the neighborhood size?
To not clutter up our existing object, we'll save to new objects and plot as a exploration to learn about neighborhood size.

```{r spotsweeper-sum-compare-k}
#| fig.width = 8

# Detect outliers with a very large neighborhood
filtered_spe_large_neighborhood <- SpotSweeper::localOutliers(
  filtered_spe, 
  metric = "sum", 
  direction = "lower", 
  n_neighbors = 1000, 
  log = TRUE,
  cutoff = 3
)


filtered_spe_small_neighborhood <- SpotSweeper::localOutliers(
  filtered_spe, 
  metric = "sum", 
  direction = "lower", 
  n_neighbors = 5, 
  log = TRUE,
  cutoff = 3
)


large_plot <- SpotSweeper::plotQCmetrics(
  filtered_spe_large_neighborhood, 
  metric = "sum_z",
  outliers = "sum_outliers", 
  colors = c("blue", "yellow")
) +
  ggplot2::ggtitle("neighborhood k = 1000")

small_plot <- SpotSweeper::plotQCmetrics(
  filtered_spe_small_neighborhood, 
  metric = "sum_z",
  outliers = "sum_outliers", 
  colors = c("blue", "yellow"), 
) +
  ggplot2::ggtitle("neighborhood k = 5")

large_plot + small_plot
```

Some spots are the same, but a lot are not! 
Note that for a high k, we are starting to identify tissue regions because we are getting closer to a global view. 
But for a low k, we are assuming a _ton_ of local structure. 

The point is, changing the cutoff or changing the neighborhood size will influence stringency - plot your data!
If you have specific biolgoical intuition, you might want to use that!

Back on track: let's do the same outlier detection for `detected` and `subsets_mito_percent`, but for the mitochondrial statistic let's use a more stringent cutoff since we know that values are low across the board here.
**TODO: more intermediate exploration of each filter?**


```{r spotsweeper-detected, live = TRUE}
filtered_spe <- SpotSweeper::localOutliers(
  filtered_spe, 
  metric = "detected", 
  direction = "lower"
)
SpotSweeper::plotQCmetrics(
  filtered_spe, 
  metric = "detected_log",
  outliers = "detected_outliers", 
  colors = c("blue", "yellow")
) 
```


```{r spotsweeper-mito, live = TRUE}
filtered_spe <- SpotSweeper::localOutliers(
  filtered_spe, 
  metric = "subsets_mito_percent", 
  direction = "higher", # we want to remove HIGHER values 
  log = FALSE, # don't log, already bounded
  cutoff = 5 # make this one really strict since we already know mito % is low everywhere
)

SpotSweeper::plotQCmetrics(
  filtered_spe, 
  metric = "subsets_mito_percent", # not log!
  outliers = "subsets_mito_percent_outliers", 
  colors = c("blue", "yellow")
) 
```


How many of each kind of outlier?

```{r count-local-outliers}
c("sum_outliers", "detected_outliers", "subsets_mito_percent_outliers") |>
  purrr::set_names() |>
  purrr::map(\(outlier_column) {
    table(filtered_spe[[outlier_column]])
  })
```

Let's go ahead and filter all these spots out:

```{r build-local-filter}
# combine all outliers into "local_outliers" column to filter on
filtered_spe$local_outliers <- as.logical(filtered_spe$sum_outliers) |
    as.logical(filtered_spe$detected_outliers) |
    as.logical(filtered_spe$subsets_mito_percent_outliers)
```


```{r perform-local-filter, live = TRUE}
# keep only spots where `local_outliers` is FALSE
filtered_spe <- filtered_spe[, filtered_spe$local_outliers == FALSE]

# print resulting SPE
filtered_spe
```

From the full set of 4992 spots, we are left with 4210 spots that both overlap tissue and don't have obvious quality issues. 


## Normalization

## Exploring marker gene expression


## Session info

To conclude, we'll run the `sessionInfo()` command to print out exactly what system setting and R package versions were used to run this code.

```{r}
sessionInfo()
```

