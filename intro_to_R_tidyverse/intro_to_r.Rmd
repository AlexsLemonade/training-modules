---
title: "Intro to R"
output:   
  html_notebook: 
    toc: true
    toc_float: true
---

**CCDL 2019**

### This RMarkdown takes you through the basics of R  

*For more comprehensive tutorials:*  
  - For a tutorial on R, RStudio and RMarkdown: https://ismayc.github.io/rbasics-book/  
  - [Datacamp](https://www.datacamp.com/) has lots of good tutorials for R and 
    the intro ones are free.

## The Basics  
R remembers what you tell it and stores assigned values in it's environment. 
You can think of an R environment as a box that you can put objects in for R to 
store. 
Going with this analogy then, you can only work in R with things that are in the 
*environment*. 
If you ask R about something that is not in its environment it will tell you it
can't find it in an error message. 
In RStudio, you will see what R has in it's *environment* in the *Environment* 
panel.
Here let's assign the value of `1` to `x` using the assignment operator: `<-`.
```{r Basic assignment}
x <- 1
```

Now R will print out `1` if we tell it `x`.
```{r Recall}
x
```

R will ignore what you say (allowing you to make comments on your code) if you 
put hashtags/pound signs.
```{r Comments}
# This is important because you should always have comments to explain your code
```

Can't remember what values you have assigned to things in your environment? 
Use the function `ls` to list everything in the current environment.  
  
*What are functions?*
Just like in math, *functions* are things that take input, transform or 
otherwise do something with this input, and then give you output. 
In R, functions take input through *arguments* within their parentheses. 
If the arguments given are inconsistent or the function built doesn't know how 
to handle what you gave it, you will get an *error* that will try to tell you 
why R can't do what you asked. 
To understand what the *error* might be pointing to, you should check the 
*function's* documentation to see how the author intended it to be used.
Use a `?` mark before a function name to bring up the documentation for that 
function.
Alternatively, you can just search for the function by name in the *help bar*
in RStudio in the lower right corner.
```{r Environment}
# It will tell us that our object "x" is in the environment
ls()

# Let's look at the info for the ls() function:
?ls
```

Based on the info we saw when we ran `ls()`, what do you suppose will happen if 
we ask for R to print `y`?
```{r error=TRUE}
y
```
This is R's way of telling us that it doesn't know what y is because it's not 
in it's environment. 
  
Base R (R without any extra frills from *packages*) knows how to do arithmetic. 
Feel free to try out division, exponents, and multiplication.   
*Hint:* `/`  `^`  `*` 
```{r Arithmetic}
# Addition:
x + 5
```

## Data Types 
R has to know how to treat different objects eg. it wouldn't make sense to try 
to perform arithmetic on letters. 
In order for R to know what to do with the things you give it, it has different 
classifications for the data *types* and data *structures* that you can put in 
its environment.
Data *types* relate to the kind of data in an object: What is it made up of?
Data *structures* refer to the sizes and dimensions of the objects. 

*Why are data types important?*  
Functions are typically built to work with certain object types.
A function's documentation should tell you what type and structure it will expect
as input (remember you can see a function's documentation by putting a question
mark in front `?functionName`).
Using the `str()` function and going through the documentation of a function 
should help you troubleshoot most problems.

R classifies objects as different data types. 
Here's a brief explanation of each but don't get too worried about understanding
these now; we will go through examples of each.  

*Data types*:  
  - *Numeric* : Numbers like 1.3333 or 1  
  - *Integer* : Numbers without decimals   
  - *Character* : Things with quotes around them; strings of characters  
  - *Factor* : Sets of variables that R will assign an factor levels to  
  - *Logical* : An object where 0 means FALSE and 1 means TRUE  

Let's go through examples to explain each of these. 
 
Based on this info, what kind of data structure do you think `x` is right
now? 
If we want to find out about the object `x` data type and structure, we can use 
the function `str` to find out. 
```{r Data structures}
# Ask R to tell you what type of data structure "x" is
str(x)
```

So x is currently numeric ("num"). 
```{r Characters}
# Let's make x something else
x <- "x"

# What do you suppose this will say now? 
str(x)
```

Quotes make it a character even if its a number in the quote: 
```{r Characters continued}
x <- "1"
str(x)
```
Let's say we change our minds and we don't want `x` to be known as `1` in our 
environment anymore. 
We can either assign `x` as being `NULL` or we can use the function `rm`.
```{r Removal}
# Remove x from the environment
rm(x)

# Take a look at our environment. Is x there? 
ls()
```

Let's bring x back so we can try to get rid of it's assignment a different way:
```{r}
# Reassign x
x <- "1"

# Make x NULL
x <- NULL

# Take a look at our environment. It's technically still there, but it's empty.
ls()
```

Let's store a bunch of things together in different types of *vectors*: 
*Vectors* are one dimensional and contain multiple pieces of data (more on that 
later).

Let's make a *numeric* vector.   
Also note that the best object names are ones that intuitively make sense to 
people.
This way people who review your code can more easily understand what's going on
(more on this later).
```{r Vectors}
# Colons tell R to take all the numbers in between. 
# We'll name this vector "nums" so it's more clear what this object is. 
nums <- 1:5

# What do you think this will give us now?: 
str(nums)
```

Let's make a *character* vector.
The `c` function allows us to put multiple things together in one vector.
We'll make a character vector and call this object `words`.
```{r Non-numeric vector}
# Let's store these words as a vector
words <- c("apple", "boy", "cat", "dog", "elephant")

# What do you think this will give us now?:
str(words)
```

Let's make a *factor* vector. 
If we want R to treat the strings that are the same as the same value such as if
we had the vector below where `blue` and `red` are repeated, we would need to 
make this into a `factor.` Side note about naming objects, its best to stay 
away from names that are already in your R environment as something else. 
In this case, it might make sense to us to call this vector "colors" but there is
already a base function in R called `colors`. 
So to avoid R or us getting confused we'll call this `color_vector`. 
```{r}
# Let's make a color vector
color_vector <- c("red", "blue", "red", "yellow", "blue")
```
  
Let's take a look at our vector `color_vector` and what it looks like.
```{r}
str(color_vector)
```
 Oh no! We wanted to make a factor vector but R thinks that we want a character
vector. That's because R will, by default, assume this is a character string. 

But what's the difference anyway?...
  
Let's take a look at our object another way using the function `summary`.
Notice that if we use `summary` on a this character vector, it doesn't give us
terribly meaningful information about how many times each color is repeated 
because R sees this as a character string and doesn't know to look at the data
like we want it to. 
```{r Summary}
summary(color_vector)
```

If we want `color_vector` to be a factor we need to tell R to treat it as such. 
If you want to try to tell R to reinterpret something as a `factor`, you need to 
use the function `as.factor`
*Note* that every character type has it's own `as.___` function eg (`as.numeric`, 
`as.character`, etc.).
```{r Coerce Factor}
# Let's turn our character vector into a factor
color_vector <- as.factor(color_vector)

# Character strings that are the same will be included in the same level
# What do you think this will give us now that we've turned this into a factor?
summary(color_vector)
```

*Logical* vectors are ones that can help you find out what data meets 
different criteria.
You can create logical vectors from using *logical statements* on other vectors.
`0` means `FALSE` and `1` means `TRUE`
  
We've already learned   `<-` is for assigning objects, here are other R operators
that can be used for logical expressions.  
  `==` : Is this equal? Note that this is different interpretation than a single
         `=` which is generally used for arguments in functions or also R will 
         interpret as an assignment(`<-`).  
  `!=` : Is this not equal? An exclamation point reverses the previous statement.
  `>` : Is this greater than?  
  `<` : Is this lesser than?  
  `>=` : Is this greater than or equal to?  
  `<=` : Is this lesser than or equal to?  
  
For example, if we want to see which of the words in our `words` vector are 
the words `"dog"`, we'll construct a statement: 
```{r Logical color_vector}
# This will print out a vector of the same length as "words" but with TRUE or 
# FALSE at each position in the vector. 
words == "dog"
```

For numeric values, we can use greater than or equal signs. 
```{r Logical nums}
nums >= 2
```

Note that when it comes to logical statements, factors can be referenced by their
character strings: 
```{r Logical factor 2}
color_vector != "red"
```

...or by their numeric level if you coerce the factor to numeric with 
`as.numeric`:
```{r Logical factor 1}
# Let's check out what numeric levels are assigned to our colors with "levels"
levels(color_vector)

# Now let's get any levels greater than 2
as.numeric(color_vector) < 2
```

## Data Structures  
Before we go through examples of each, here are some brief explanations of the
kinds of data *structures*:  
  - A *Vector* is one dimensional collection of data that is all of the same type  
  - A *Matrix* a two dimensional storage of data that is all of the same type  
  - A *Dataframe* is a two dimensional storage of data that can be a mix of data
    types  
  - A *List* is multidimensional storage of data that can be a mix of data types 
    and structures (more explanation to come with )

*Example:* You may have already noticed, but `str()` reports the dimensions of 
an object so, for a vector that has 10 pieces dimensions will be shown as 
`[1:10]`.
```{r Vectors again}
one.through.ten <- 1:10
str(one.through.ten)
```

A matrix is a two dimensional collection of data. Like in math, commas separate
rows and columns indices. 
We will generally be using matrices when we are working with only the numbers of
a gene expression matrix.
eg. for a vector that has 10 rows and 10 columns `str()` will report dimensions 
of `[1:10, 1:10]`
```{r Matrix}
# Note that we need to use arguments for the matrix function to tell R how many 
# rows "nrow = 10" and how many columns "ncol = 10" we want. 
sq.matrix <- matrix(1:100, nrow = 10, ncol = 10)
str(sq.matrix)
```

What dimensions do you suppose this matrix will have by default if we don't 
specify the number of rows and columns we want? 
```{r Matrix cont.}
not.sq.matrix <- matrix(1:100)
str(not.sq.matrix)
```

Matrices however, are not great at storing different types of data. 
Notice that in the above examples we are only using integers. 
If you try to mix data types together in a matrix, R will coerce them to be all 
one type, which will probably be bad for you because your information will be 
distorted.   
  
Hence the `data.frame` is probably what you will be using for a lot of your data. 
Working with `data.frame`s also is handy because Hadley Wickham's `tidyverse` tools 
are mostly built around using `data.frame`s or its' closely related sibling the 
`tibble`. The next Rmd will show you all about manipulating `data.frame`s with the 
tidyverse tools. 
```{r Data frames}
# Let's make a data frame from our previously created vectors!
df <- data.frame(nums , words, color_vector)
```

Note that if these vectors were not conveniently all the same length, we could 
not put them in a `data.frame` together.  
```{r}
str(df)
# Also note that "obs" are rows and "variables" are the columns in a data.frame
```

Also note that the `data.frame` function makes strings a factor by default,
unless you tell it not to. 
So let's remake this `data.frame`, but tell R not to do that with one of the 
arguments for the `data.frame` function. 
```{r Data frames cont. }
# Let's make a data frame from our previously created vectors but tell R not to
# turn strings into factors!
df <- data.frame(nums, words, color_vector, stringsAsFactors = FALSE)
str(df)
# Note that with the argument `stringsAsFactors` now our words variable remains 
# a character vector as it was before. 
```

Now that we have a nice `data.frame` and other objects to play with in our 
environment; let's play around with it and extract pieces of it. 
```{r Subsetting Indices}
# Let's say we only want to see what's in the first row and first column of this
# data.frame. We can subset data structures by using brackets. 
df[1, 1]

# Note that you can do this same thing to matrices: 
sq.matrix[3, 3]

# Why do you suppose we don't have a comma for this?: 
one.through.ten[8]
# Hint: Check it's structure with str() if you forgot what this object looks like. 
```

Data frames have column and row names. You can also specially reference 
`data.frame`s' variables by their column names. 
```{r Special data.frame things}
# data.frames store column names and row names 
df$nums
# We'll do fancier data.frame manipulations in the next Rmd so hold tight!
```

What if we want to store all of our object in one big object? 
We can't do that with data frames because not all of these are the same length 
or dimensions. 
This is where `lists` come in handy.
Lists do not care about data type or data structure, but let you store whatever
you want in one big object.
```{r}
# Let's remind ourselves of what objects we've made so far: 
ls()
```

Now let's make one crazy list with various objects of different dimensions and
types using the function `list`!
```{r Lists}
variety.list <- list(df, sq.matrix, color_vector, x)

# Let's take a look at this list 
str(variety.list)
```

How do we extract things from this weird list? We need to use brackets again. 
```{r Single bracket}
# This will show us our data.frame in the first spot as a singular item
first.item <- variety.list[1]

# Let's take a look at this, note that we've just made this a list of one now
str(first.item)
```

You'll find that the single bracket is probably not giving you what you want 
here. 
To explain this, let's look at a couple other things about how lists work. 
The structure of lists are kind of analogous to those 
[Russian nesting dolls](https://en.wikipedia.org/wiki/Matryoshka_doll) in that 
you can have lists inside of lists and you can think of them as layers.
In this analogy the single bracket is not actually extracting the `data.frame`
that is in this list. 
```{r Double Bracket}
# This however will give us the data.frame in this spot in the list. 
variety.list[[1]]

# Let's look at the structure of this after we've 'extracted' the data.frame
# from the list with the double brackets. 
str(variety.list[[1]])
```

To further clarify the difference between the double and single bracket, note 
that with a single bracket we can't use the `data.frame` as usual.
R tells us `NULL` if we try to reference the column `$color_vector` because it 
doesn't recognize it as a `data.frame`, but instead thinks of it as a `list` item.
But, with the double bracket we can play with our `data.frame` the same way as before: 
```{r Subset list and df}
# Single bracket: can't use the data.frame
variety.list[1]$color_vector

# Double bracket: can use the data.frame
variety.list[[1]]$color_vector
```

## Some last bits of advice
*Why are data types and structures important?*
Functions are typically built to work with certain object structures and types.
A function's documentation should tell you what type and structure it will expect
as input (remember you can see a function's documentation by putting a question
mark in front `?functionName`).
Note that the documentation will also tell you about the default *arguments*
that the function has. 
Knowing what the default *arguments* of a function are can also be helplful in 
your troublshooting a problem.
Using the `str()` function and going through the documentation of a function 
should help you troubleshoot most problems.
  
## Last note on code etiquette: 
Good code is clear and reproducible. 
In order for code to be clear and 
Your code is not useful to others if it isn't readable, so naming conventions, 
code style, and consistency is important. 
We suggest following a style guide like:  
- [Hadley Wickham's R Style Guide](http://adv-r.had.co.nz/Style.html)  
- [Google's R Style Guide](https://google.github.io/styleguide/Rguide.xml).   
  
For reproducibility purposes, it's also good practice to show other people your
session info.
This way, when other's try to reproduce your research, they know what packages 
you have loaded and how things were set for the code you ran. 
```{r }
sessionInfo()
```
