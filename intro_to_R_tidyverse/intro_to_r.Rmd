---
title: "Intro to R"
author: "CCDL for ALSF"
date: "1/28/2019"
output: html_document
---

## This RMarkdown takes you through the basics of R  

*For more comprehensive tutorials:*  
  - For a tutorial on R, RStudio and RMarkdown: https://ismayc.github.io/rbasics-book/  
  - [Datacamp](https://www.datacamp.com/) has lots of good tutorials for R and 
    the intro ones are free: 
  
This html is made from an [RMarkdown file](https://rmarkdown.rstudio.com/articles_intro.html). 
Rmd's are handy for times you'd like to have output that has the code along with
the output from that code. 
Rmds also have a lot of options and features for what that output looks like and 
what it includes. 

### The Basics:
R remembers what you tell it and stores assigned values in it's environment. 
In RStudio, you will see what R has in it's environment in the "environment" panel.
Here let's assign the value of `1` to `x` using the assignment operator: `<-`.
```{r Basic assignment}
# Let's tell R to remember that x is 1
x <- 1
```

Now R will print out `1` if we tell it `x`.
```{r Recall}
x
```

Use the print function to more explicitly ask R to recall what x is
```{r print}
print(x)
```

R will ignore what you say (allowing you to make comments on your code) if you 
put hashtags/pound signs.
```{r Comments}
# This is important because you should always have comments to explain your code
```

Can't remember what values you have assigned to things in your environment? 
Use the function `ls` to list everything in the current environment. 
Just like in math, 
*functions* are things that take input, transform or otherwise do something with this input, and then give you output. 
In R, functions take input through *arguments* within their parantheses. 
If the arguments don't make sense, you will get an *error* that will try to tell 
you why R can't do what you asked. 
Use a `?` mark before a function name to bring up the help page for that function
so you can see how it's supposed to be used. 
Or just search for the function by name in the *help bar* in RStudio.
```{r Environment}
# It will tell us that our object "x" is in the environment
ls()

# Let's look at the info for the ls() function:
?ls
```

Based on the info we saw when we ran `ls()`, what would happen if we got rid of the
pound sign and tried to run this following line?:
```{r }
# print(y)
```

Base R (R without any extra frills from *packages*) knows how to do arithmetic. 
Feel free to try out division, exponents, and multiplication.   
*Hint:* `/`  `^`  `*` 
```{r Arithmetic}
# Addition:
x + 5
```

### Data Types:   
R classifies objects as different data types. 
We'll go through examples of each so it's clear what these are; here's a brief
explanation of each:  
  - *Numeric* : Numbers like 1.3333 or 1  
  - *Integer* : Numbers without decimals   
  - *Character* : Things with quotes around them; strings of characters  
  - *Factor* : Sets of variables that R will assign an factor levels to  
  - *Logical* : An object where 0 means FALSE and 1 means TRUE  

Based on these categories, what kind of data structure do you think `x` is right
now? 
If we want to find out about the object `x` data type and structure, we can use 
the function `str` to find out. 
```{r Data structures}
# Ask R to tell you what type of data structure "x" is
str(x)
```

So x is currently numeric ("num"). 
```{r Characters}
# Let's make x something else
x <- "x"

# What do you suppose this will say now? 
str(x)
```

Quotes make it a character even if its a number in the quote: 
```{r Characters continued}
x <- "1"
str(x)
```
Let's say we change our minds and we don't want `x` to be known as `1` in our 
environment anymore. 
We can either assign `x` as being `NULL` or we can use the function `rm`.
```{r Removal}
# Remove x from the environment
rm(x)

# Take a look at our environment. Is x there? 
ls()
```

Let's bring x back so we can try to get rid of it's assignment a different way:
```{r}
# Reassign x
x <- "1"

# Make x NULL
x <- NULL

# Take a look at our environment. It's technically still there, but it's empty.
ls()
```

Let's store a bunch of things together in different types of *vectors*: 
Vectors are one dimensional and contain multiple pieces of data (more on that 
later).

Let's make a *numeric* vector.   
Also note that the best object names are ones that intuitively make sense to people.
This way people who review your code can more easily understand what's going on
(more on this later).
```{r Vectors}
# Colons tell R to take all the numbers in between. 
# We'll name this vector "nums" so it's more clear what this object is. 
nums <- 1:5

# What do you think this will give us now?: 
str(nums)
```

Let's make a *character* vector.
The `c` function allows us to put multiple things together in one vector.
We'll make a character vector and call this object `words`.
```{r Non-numeric vector}
# Let's store these words as a vector
words <- c("apple", "boy", "cat", "dog", "elephant")

# What do you think this will give us now?:
str(words)
```

Let's make a *factor* vector. 
If we want R to treat the strings that are the same as the same value such as if
we had the vector below where `blue` and `red` are repeated, we would need to 
make this into a `factor.` Side note about naming objects, its best to stay 
away from names that are already in your R environment as something else. 
In this case, it might make sense to us to call this vector "colors" but there is
already a base function in R called `colors`. 
So to avoid R or us getting confused we'll call this `colorz`. 
```{r}
# Let's make a color vector
colorz <- c("red", "blue", "red", "yellow", "blue")
```
  
Let's take a look at our vector `colorz` and what it looks like.
```{r}
str(colorz)
```
Oh no! We wanted to make a factor vector but R thinks that we want a character
vector. That's because R will, by default, assume this is a character string. 

But what's the difference anyway?...
  
Let's take a look at our object another way using the function `summary`.
Notice that if we use `summary` on a this character vector, it doesn't give us
terribly meaningful information about how many times each color is repeated 
because R sees this as a character string and doesn't know to look at the data
like we want it to. 
```{r Summary}
summary(colorz)
```

If we want `colorz` to be a factor we need to tell R to treat it as such. 
If you want to try to tell R to reinterpret something as a `factor`, you need to 
use the function `as.factor`
*Note* that every character type has it's own `as.___` function eg (`as.numeric`, 
`as.character`, etc.).
```{r Coerce Factor}
# Let's turn our character vector into a factor
colorz <- as.factor(colorz)

# Character strings that are the same will be included in the same level
# What do you think this will give us now that we've turned this into a factor?
summary(colorz)
```

*Logical* vectors are ones that can help you find out what data meets 
different criteria.
You can create logical vectors from using *logical statements* on other vectors.
`0` means `FALSE` and `1` means `TRUE`

In R, there are a few types of logical expressions: 
  `==` : Is this equal? (Note that this is different interpretation than a single
         `=` which is generally used for arguments in functions or also R will 
         interpret as an assignment)
  `!=` : Is this not equal? An exclamation point reverses the previous statement.
  `>` : Is this greater than? 
  `<` : Is this lesser than? 
  `>=` : Is this greater than or equal to?
  `<=` : Is this lesser than or equal to?

For example, if we want to see which of the words in our `words` vector are 
the words `"dog"`, we'll construct a statement: 
```{r Logical colorz}
# This will print out a vector of the same length as "words" but with TRUE or 
# FALSE at each position in the vector. 
words == "dog"
```

For numeric values, we can use greater than or equal signs. 
```{r Logical nums}
nums >= 2
```

Note that when it comes to logical statements, factors can be referenced by their
character strings: 
```{r Logical factor 2}
colorz != "red"
```

...or by their numeric level if you coerce the factor to numeric with `as.numeric`:
```{r Logical factor 1}
# Let's check out what numeric levels are assigned to our colors with "levels"
levels(colorz)

# Now let's get any levels greater than 2
as.numeric(colorz) < 2
```

### Data Structures:
Brief explanations of the data structures:  
  - A *Vector* is one dimensional collection of data that is all of the same type  
  - A *Matrix* a two dimensional storage of data that is all of the same type  
  - A *Dataframe* is a two dimensional storage of data that can be a mix of data
    types  
  - A *List* is multidimensional storage of data that can be a mix of data types 
    and structures (more explanation to come with )

*Example:* You may have already noticed, but `str()` reports the dimensions of an object
so, for a vector that has 10 pieces dimensions will be shown as `[1:10]`
```{r Vectors again}
one.through.ten <- 1:10
str(one.through.ten)
```

A matrix is a two dimensional collection of data. Like in math, commas separate
rows and columns indices. 
eg. for a vector that has 10 rows and 10 columns `str()` will report dimensions of `[1:10, 1:10]`
```{r Matrix}
# Note that we need to use arguments for the matrix function to tell R how many 
# rows "nrow = 10" and how many columns "ncol = 10" we want. 
sq.matrix <- matrix(1:100, nrow = 10, ncol = 10)
str(sq.matrix)
```

What dimensions do you suppose this matrix will have by default if we don't 
specify the number of rows and columns we want? 
```{r Matrix cont.}
not.sq.matrix <- matrix(1:100)
str(not.sq.matrix)
```

Matrices however, are not great at storing different types of data. 
Notice that in the above examples we are only using integers. 
If you try to mix data types together in a matrix, R will coerce them to be all 
one type, which will probably be bad for you because your information will be 
distorted.   
  
Hence the `data.frame` is probably what you will be using for a lot of your data. 
Working with dataframes also is handy because Hadley Wickham's `tidyverse` tools 
are mostly built around using `data.frame`s or its' closely related sibling the 
`tibble`. The next Rmd will show you all about manipulating `data.frame`s with the 
tidyverse tools. 
```{r Data frames}
# Let's make a data frame from our previously created vectors!
df <- data.frame(nums , words, colorz)
```

Note that if these vectors were not conveniently all the same length, we could 
not put them in a dataframe together.  
```{r}
str(df)
# Also note that "obs" are rows and "variables" are the columns in a dataframe
```

Also note that the `data.frame` function stupidly makes strings a factor by default,
unless you tell it not to. 
So let's remake this `data.frame`, but tell R not to do that with one of the 
arguments for the `data.frame` function. 
```{r Data frames cont. }
# Let's make a data frame from our previously created vectors but tell R not to
# turn strings into factors!
df <- data.frame(nums , words, colorz, stringsAsFactors = FALSE)
str(df)
# Note that with the argument `stringsAsFactors` now our words variable remains 
# a character vector as it was before. 
```

Now that we have a nice dataframe and other objects to play with in our 
environment; let's play around with it and extract pieces of it. 
```{r Subsetting Indices}
# Let's say we only want to see what's in the first row and first column of this
# dataframe. We can subset data structures by using brackets. 
df[1, 1]

# Note that you can do this same thing to matrices: 
sq.matrix[3, 3]

# Why do you suppose we don't have a comma for this?: 
one.through.ten[8]
# Hint: Check it's structure with str() if you forgot what this object looks like. 
```

Data frames have column and row names. You can also specially reference dataframes'
variables by their column names. 
```{r Special dataframe things}
# dataframes store column names and row names 
df$nums
# We'll do fancier dataframe manipulations in the next Rmd so hold tight!
```

What if we want to store all of our object in one big object? 
We can't do that with data frames because not all of these are the same length 
or dimensions. 
This is where `lists` come in handy.
Lists do not care about data type or data structure, but let you store whatever
you want in one big object. 
```{r}
# Let's remind ourselves of what objects we've made so far: 
ls()
```

Now let's make one crazy list with various objects of different dimensions and
types using the function `list`!
```{r Lists}
variety.list <- list(df, sq.matrix, colorz, x)

# Let's take a look at this list 
str(variety.list)
```

How do we extract things from this weird list? We need to use brackets again. 
```{r  Single bracket}
# This will show us our dataframe in the first spot as a singular item
variety.list[1]
```

However, if you want to the thing in that position of the list, you need to use 
the double bracket. 
```{r Double Bracket}
# This however will give us the data.frame in this spot in the list. 
variety.list[[1]]
```

Now with the double bracket we can play with our dataframe the same way as before: 
```{r Subset list and df}
variety.list[[1]]$colorz
```

### Last but most certainly not least: 
Your code is not useful to others if it isn't readable, so naming conventions, 
code style, and consistency is important. 
We suggest following a style guide like [Google's R Style Guide](https://google.github.io/styleguide/Rguide.xml). 

*Last note:* It's also good practice to show other people your session info so they
know what packages you have loaded and how things were set for the code you ran. 
```{r }
sessionInfo()
```
