---
title: "Intro_to_R"
author: "CCDL for ALSF"
date: "1/28/2019"
output: html_document
---

This Rmd is taking you through the basics of R.  

For more information:
For a tutorial on R, RStudio and RMarkdown: https://ismayc.github.io/rbasics-book/
For a tutorial on Rmarkdown's: https://rmarkdown.rstudio.com/articles_intro.html
R Google Style Guide: https://google.github.io/styleguide/Rguide.xml

RMarkdown files (like this one) are handy for times you'd like to run code and 
get output that has the code along with the output from that code. 
It also has a lot of options and features for what that output looks like and 
what it includes. 

R remembers what you tell it and stores things like this in it's environment.
```{r Basic assignment}
# We'll tell R to remember that x is 1
x <- 1

# Ask R to tell you what x is:
x

# Use the print function to more explicitly ask R to recall what x is
print(x)
```

How to make comments:
```{r Comments}
# R will ignore what you say (allowing you to make comments on your code) if you 
# put hashtags/pound signs.
# This is important because you should always have comments to explain your code
```

Can't remember what things you have in your environment that you asked R to 
remember? Use the function `ls` to list everything in the current environment. 
Just like in math, functions are things that take input, transform or otherwise
do something with it, then give you output. 
Functions take arguments within their parantheses. 
If the arguments don't make sense, you will get an error that will try to tell 
you why R can't do what you asked. 
```{r Environment}
# It will tell us that our object "x" is in the environment
ls()

# What will happen if we try to run this function?
print(y)
```

R knows how to do arithmetic. 
```{r Arithmetic}
# Addition:
x + 5
# Figure out on your own how to do division, exponents, and multiplication.
# Hint: /  ^  * 
```

### Data Types: 
R classifies objects as different data types.  
  - Numeric : Numbers like 1.3333 or 1
  - Integer : Numbers without decimals 
  - Character : Things with quotes around them; strings of characters
  - Factor : Sets of variables that R will assign an factor levels to

What kind of data structure do you think x is right now? 
```{r Data Structures}
# Ask R to tell you what type of data structure "x" is
str(x)
```

So x is currently numeric ("num"). 
```{r Characters}
# Let's make x something else
x <- "x"

# What do you suppose this will say now? 
str(x)
```

Quotes make it a character: 
```{r Characters continued}
x <- "1"
str(x)
```

Let's store a bunch of things together in a vector: 
Vectors are one dimensional and contain multiple pieces of data (more on that 
later)
Also note that the best object names are ones that intuitively make sense to people. 
This way people who review your code can more easily understand what's going on
(more on this later).
```{r Vectors}
# Colons tell R to take all the numbers in between. 
# We'll name this vector "nums" so it's more clear what this object is. 
nums <- 1:5

# What do you think this will give us now: 
str(nums)
```

The `c` function allows us to put things together in one vector.
We'll make a character vector and call this object "words. "
```{r Non-numeric vector}
# Let's store some other types of values 
words <- c("apple", "boy", "cat", "dog", "elephant")

# What do you think this will give us now?
str(words)
```

Let's make a factor vector. 
If we want R to treat the strings that are repeated as the same value such as 
`blue` and `red`, we need to make this into a factor. 
Side note, when you are naming objects, its best to stay away from names that are
already in your R environment as something else. 
In this case, it might make sense to us to call this vector "colors" but there is
already a base function in R called `colors`. 
So to avoid R or us getting confused we'll call this `colorz`
```{r Factor}
# Let's store some other types of values 
colorz <- c("red", "blue", "red", "yellow", "blue")

# What do you think this will give us now?
str(colorz)
```

### Data Structures
Brief summary of explanations of the data structures:
- A Vector is one dimensional collection of data that is all of the same type
- A Matrix a two dimensional storage of data that is all of the same type
- A Dataframe is a two dimensional storage of data that can be a mix of data types
- A List is multidimensional storage of data that can be a mix of data types and 
structures (more explanation to come with )

Example: You may have already noticed, but `str()` reports the dimensions of an object
so, for a vector that has 10 pieces dimensions will be shown as `[1:10]`
```{r Vectors again}
one.through.ten <- 1:10
str(one.through.ten)
```

A matrix is a two dimensional collection of data. Like in math, commas separate
rows and columns indices. 
eg. for a vector that has 10 rows and 10 columns `str()` will report dimensions of `[1:10, 1:10]`
```{r Matrix}
# Note that we need to use arguments for the matrix function to tell R how many 
# rows "nrow = 10" and how many columns "ncol = 10" we want. 
sq.matrix <- matrix(1:100, nrow = 10, ncol = 10)
str(sq.matrix)
```

What dimensions do you suppose this matrix will have by default if we don't 
specify the number of rows and columns we want? 
```{r Matrix cont.}
not.sq.matrix <- matrix(1:100)
str(not.sq.matrix)
```

Matrices however, are not great at storing different types of data. Notice
that in the above examples we are only using integers. 
And if you try to mix data types together, R will coerce them to be all one type.

Hence the `data.frame` is probably what you will be using for a lot of your data. 
Working with dataframes also is handy because Hadley Wickham's tidyverse tools 
are mostly built around using `data.frame`s or its' closely related sibling the 
`tibble`. The next Rmd will show you all about manipulating `data.frame`s with the 
tidyverse tools. 
```{r Data frames}
# Let's make a data frame from our previously created vectors!
df <- data.frame(nums , words, colorz)

# Note that if these vectors were not conviently all the same length, we could 
# not put them in a dataframe together.  
str(df)
# Also note that "obs" are rows and "variables"" are the columns
```
Also note that the data.frame function stupidly makes things a factor by default,
unless you tell it not to.
```{r Data frames cont. }
# Let's make a data frame from our previously created vectors!
df <- data.frame(nums , words, colorz, stringsAsFactors = FALSE)
str(df)
# Note that with the argument `stringsAsFactors` now our words variable remains 
# a character vector as it was before. 
```

Now that we have a nice dataframe and other objects to play with in our 
environment; let's play around with it and extract pieces of it. 
```{r Subsetting Indices}
# Let's say we only want to see what's in the first row and first column of this
# dataframe. We can subset data structures by using brackets. 
df[1, 1]

# Note that you can do this same thing to matrices and vectors: 
sq.matrix[3, 3]

# Why do you suppose we don't have a comma for this: 
one.through.ten[8]
# Hint: Check it's structure with str() if you forgot what this object looks like. 
```

Data frames have column and row names. You can also specially reference dataframes'
variables by their column names. 
```{r Special dataframe things}
# dataframes store column names and row names 
df$nums
# We'll do fancier dataframe manipulations in the next Rmd so hold tight!
```

What if we want to store all of our object in one big object? 
Use `ls()` to take a look at all the objects we've accumulated now. 
We can't do that with data frames because not all of these are the same length 
or dimensions. 
This is where `lists` come in handy.
Lists do not care about data type or data structure, but let you store whatever
you want in one big object. 
```{r  Lists}
# Let's remind ourselves of what objects we've made so far: 
ls()

# Now let's make one crazy list with various objects of different dimensions and
# types!
variety.list <- list(df, sq.matrix, colorz, x)

# Let's take a look at this list 
str(variety.list)
```
How do we extract things from this weird list? We need to use brackets again. 
However, if you want to extract things from your list, you need to use the 
double bracket. 
```{r  Subsetting lists}
# This will show us our dataframe in the first spot as a singular item
variety.list[1]

# This however will give us the data.frame in this spot in the list. 
variety.list[[1]]
```

Now with the double bracket we can play with our dataframe the same way as before: 
```{r Subset list and df}
variety.list[[1]]$colorz
```

### Last but most certainly not least: 
Your code is not useful to others if it isn't readable, so naming conventions,  
code style, and consistency is important. 
We suggest following a style guide like [Google's R Style Guide](https://google.github.io/styleguide/Rguide.xml). 








