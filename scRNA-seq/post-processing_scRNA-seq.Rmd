---
title: "scRNA-seq_post_processing"
output: html_notebook
---

**CCDL 2019**

In this notebook, we'll perform normalization and quality control of scRNA-seq
count data. 

We'll use Seurat for post-processing of scRNA-seq Alevin processed data
Adapted from the Seurat pbmc tutorial found [here](https://satijalab.org/seurat/pbmc3k_tutorial.html) 
```{r Install Packages}
# Attach library
library(Seurat)

# Magrittr pipe
`%>%` <- dplyr::`%>%`
```

#### Perform QC checks with 'csoneson/AlevinQC'
```{r AlevinQC}
alevin.files <- dir(file.path("data", "alevin_output"), full.names = TRUE)

lapply(alevin.files, function(file) {
  sample.name <- stringr::word(file, sep = "/", -1)
  alevinQC::alevinQCReport(file,
                          sampleId = sample.name, 
                          outputFile = paste0(sample.name, "_alevin_qc_report.html"), 
                          outputFormat = "html_document")
})
```

#### Import counts from Alevin processing
```{r Import Data}
# Get the paths to all the quant files
quant.files <- list.files(getwd(), recursive = TRUE, full.names = TRUE,
                    pattern = "quants_mat.csv")

# Read in Alevin data
counts <- do.call("cbind", lapply(quant.files, function(file) {
                 # Read in sample data from Alevin
                 sample <- readr::read_csv(file, col_names = FALSE)
                 
                 # Read in column names from Alevin
                 col.file <- gsub(".csv", "_cols.txt", file)
                 colnames(sample) <- readr::read_delim(col.file, "\n", 
                                                       col_names = FALSE)$X1
                 
                 # Read in row names from Alevin
                 row.file <- gsub(".csv", "_rows.txt", file)
                 barcodes <- readr::read_delim(row.file, "\n", 
                                               col_names = FALSE)$X1
                 
                 # Make this it's own column
                 sample <-  data.frame(t(sample))
                 
                 # Put the barcodes as the names 
                 colnames(sample) <- barcodes
                 
                 return(sample)
                 })
)

# Obtain list of genes in this dataset without version numbers 
genes <- gsub("\\.[0-9]*", "", rownames(counts.df))
```
#### Mitochondrial genes by their ensembl IDs
This list is from [here](http://jdblischak.github.io/singleCellSeq/analysis/qc-filter-ipsc.html)
```{r Set up mitochondrial gene list}
# Identify mitochondrial genes by their ensembl IDs
mtgene <- c("ENSG00000198899", "ENSG00000198727", "ENSG00000198888", 
            "ENSG00000198886", "ENSG00000212907", "ENSG00000198786",
            "ENSG00000198695", "ENSG00000198712", "ENSG00000198804",
            "ENSG00000198763","ENSG00000228253", "ENSG00000198938", 
            "ENSG00000198840")

# Get the gene symbol names for these genes add regex for exact matches
mtgene <- paste0("^", mtgene, "$")
```

#### Set up data in Seurat format
```{r Set Up Data into seurat format}
# Make our data into a Seurat Object
seurat.data <- CreateSeuratObject(raw.data = counts, min.cells = 3,
                                  min.genes = 200, project = "3k_pbmc")
```

#### Get mitochondrial gene percentages
```{r Calculate Mito Percentages}
# Get those mito genes
mito.genes <- grep(paste0(mtgene, collapse = "|"), genes)

# Calculate the percentage of mitochonrial transcripts to total transcripts
percent.mito <- Matrix::colSums(seurat.data@raw.data[mito.genes, ])/
  Matrix::colSums(seurat.data@raw.data)

# AddMetaData adds columns to object@meta.data, and is a great place to
# stash QC stats
seurat.data <- AddMetaData(object = seurat.data, metadata = percent.mito,
                           col.name = "percent_mito")
```

#### Make plots of the samples' statistics 
```{r Make Sample Set Plots}
# Make a violin plot
VlnPlot(object = seurat.data, features.plot = c("nGene", "nUMI", "percent_mito"),
        nCol = 3)

# Examine relationships of nUMI, percent_mito and nGene
par(mfrow = c(1, 2))
GenePlot(object = seurat.data, gene1 = "nUMI", gene2 = "percent_mito")
GenePlot(object = seurat.data, gene1 = "nUMI", gene2 = "nGene")
```

#### Normalize and filter data
From seurat tutorial: we employ a global-scaling normalization method “LogNormalize” 
that normalizes the gene expression measurements for each cell by the total expression,
multiplies this by a scale factor (10,000 by default), and log-transforms the result.
```{r Filter Normalize}
# Filter out cells
filtered.seurat <- FilterCells(object = seurat.data, 
                              subset.names = c("nGene", "percent_mito"), 
                              low.thresholds = c(200, -Inf), 
                              high.thresholds = c(2500, 0.05))

# Normalizing the data
filtered.seurat <- NormalizeData(object = seurat.data, 
                                 normalization.method = "LogNormalize", 
                                 scale.factor = 10000)
```

#### Explore variance to average expression 
```{r Plot Dispersion vs Avg Exp}
# Make a variance to average expression plot
filtered.seurat <- FindVariableGenes(object = filtered.seurat, 
                                     mean.function = ExpMean, 
                                     dispersion.function = LogVMR,
                                     x.low.cutoff = 0.0125,
                                     x.high.cutoff = 3,
                                     y.cutoff = 0.5)
```

#### Save the normalized data
```{r Save Data to RDS}
# Save this seurat object to an RDS file
readr::write_tsv(filtered.seurat, file = file.path("data", "seurat"))
```

```{r}
sessionInfo()
```