---
title: "Clustering cells and finding marker genes scRNA-seq data"
author: CCDL for ALSF
date: 2021
output:
  html_notebook: 
    toc: true
    toc_float: true
---
## Objectives

This notebook will demonstrate how to:

- Annotate clusters of cells in single-cell data
- Compare different clustering methods
- Identify marker genes that can be used to differentiate clusters

---

## Set Up

### Load libraries
```{r setup}
# Load libraries
library(ggplot2)
library(scater)
library(scran)
# clustering tools
library(bluster)

# Magrittr pipe
library(magrittr)

# Setting the seed for reproducibility
set.seed(12345)
```

```{r filepaths}
# main data directory
data_dir <- file.path("data", "hodgkins")

# normalized data file
normalized_rds <- file.path(data_dir, "normalized", "normalized_hodgkins_sce.rds")

# Output directory for markers
marker_dir <- file.path("analysis", "hodgkins", "markers")
if (!dir.exists(marker_dir)) {
  dir.create(marker_dir, recursive = TRUE)
}
```

```{r read data}
hodgkins_sce <- readr::read_rds(normalized_rds)
```

## Identifying cell clusters

Source of lots of info: https://bioconductor.org/books/release/OSCA/clustering.html

When we performed dimensionality reduction on our single cell data, we could see visually that the cells tended cluster together into groups. 
To the extent that such clustering is a real biological phenomenon, representing cells with similar patterns of gene expression, we might like to identify distinct groups that we can name and assign a label to.
Ultimately, we would hope that these labels correspond to previously identified (or newly identified!) cell types, and that we can use that information to provide more insight into the results of our experiment.

There are a number of methods to identify clusters and assign cells to those in multidimensional data like the single cell data we have.
We will explore a couple of those here.

### k-means clustering

The first method we will try is k-means clustering.

The k-means algorithm in it basic form requires us to pick the number of clusters we want to use

We are going to use the function `clusterRows()` from the  Bioconductor `bluster` package for our clustering. 
This function takes a matrix where each samples (cells in our case) is a row and each column is a feature.
The matrix of counts (or normalized counts) by cells in our `SingleCellExperiment` object is the wrong orientation, so at a minimum we would have to transpose that matrix before proceeding. 

However, clustering algorithms like k-means can be a bit slow with as many features as the number of genes that we have in our data set, so we would rather not use the raw data.
There is also a potential concern that noise in the raw data might disrupt the clustering algorithm, so it would be best to use some kind of dimensionality reduction algorithm first. 
But we still want to maintain a good number of dimensions, so our old friend PCA is a good (and very standard) choice.

Thankfully, we already computed *and stored* a matrix with reduced dimensions with the `runPCA()` function. 
We will extract that from the `SingleCellExperiment` object with the `reducedDim()` function, which conveniently returns a matrix with the cells as rows, so we can use that directly!

We will start with a small number for the clusters.

```{r kmeans_6}
# set the number of clusters:
k <- 6

# extract the principal components matrix
hodgkins_pca <- reducedDim(hodgkins_sce, "PCA")

# perform the clustering
kclusters <- clusterRows(hodgkins_pca, KmeansParam(centers = k))
```

The `clusterRows()` function returned a vector of cluster assignments as integers, but the numerical values have no inherent meaning. 
For plotting we will want to convert those to a factor, so R is not tempted to treat them as a continuous variable.

We can also store them back into the column (cell) information table of the original object for convenient storage and later use.

```{r store_kclusters}
hodgkins_sce$kcluster <- factor(kclusters)
```

Now we can plot the results and see how the clustering looks, using the `scater` function `plotReducedDim()`, but now coloring the points by our clustering results.
We will start by using the UMAP coordinates for the plot.
Note that this does require that the cluster identities were stored in the `SingleCellExperiment` object.


```{r plot_k}
plotReducedDim(hodgkins_sce, "UMAP", colour_by = "kcluster")
```

Do those clusters line up with what you might have expected if you were doing this by eye?
What do the results look like if you plot with the PCA coordinates? 
What happens if we change the number of clusters?

### Graph-based clustering

Another common type of clustering method for single cell data is graph-based clustering. 
This works by identifying a set of nearest neighbors for each cell that have similar expression profiles to that cell, then connecting each cell to those neighbors in a network graph. 
The connections are weighted by how similar each cell is to its neighbors.

We then break the network up by identifying clusters of cells that are more connected to each other than they are to cells outside the clusters. 

To apply this, we will use the same `bluster::clusterRows()` function as before, but we will change the second argument from `KmeansParam()` to `NNGraphParam()` to tell it that we want to use a nearest-neighbor graph-based method. 
We can then supply parameters to `NNGraphParam()` to adjust the details of the algorithm.

Here we will use `k` to specify the number of neighbors to use when building the graph and `cluster.fun` to specify the algorithm for identifying the clusters within the graph.
Despite sharing a letter, `k` here and the one from k means clustering are not the same thing!
In this case, we are telling the algorithm how many neighbor connections to make for each cell, not final number of clusters, which will be determined by the algorithm.


```{r nnclust, live = true}
# run the clustering algorithm
nnclusters <- clusterRows(
  hodgkins_pca, 
  NNGraphParam(k = 10, 
               cluster.fun = "walktrap")
  )
# store cluster results in the SCE object
hodgkins_sce$nncluster <- factor(nnclusters)
```


```{r plot_nnclust}
plotReducedDim(hodgkins_sce, "UMAP", colour_by = "nncluster")
```
How does that compare to the k-means clustering result?


### Parameters matter!

```{r}
clusterPlot <- function(sce, cluster_param, plot_dim = "UMAP"){
  pc_matrix <- reducedDim(sce, "PCA")
  clusters <- clusterRows(pc_matrix, cluster_param) %>% factor()
  sce$cluster <- factor(clusters)
  plotReducedDim(sce, plot_dim, colour_by = "cluster")
}
```

```{r}
clusterPlot(hodgkins_sce, NNGraphParam(k = 5, cluster.fun = "louvain"))
```


## Identify marker genes

The highest variance genes may not always be the most informative on their own, especially if we are trying to differentiate among cell types.
To find genes that are distinct to one cell type or another, we can use the `scran::findMarkers()` function to test for genes that are significantly different among cells of each type.
This will return a list (technically a list-like object) of tables, one for each cell type, with statistics for each gene showing how well it differentiates that cell type against all other types.

```{r find_markers}
markers <- scran::findMarkers(gbm_sce, gbm_sce$cell_type)
```

Next we can look at one of those tables, in this case the one for neurons. 
Since each of the tables in the list-like object has a name, we can select an individual table using the familiar `$` syntax..We have done some transformation here to pull the gene name into a column of its own and filtered to the genes that seem to differentiate best using the `Top` column.

```{r marker_table}
markers$Neuron %>%
  as.data.frame() %>% # convert to a data frame
  tibble::rownames_to_column("gene") %>% # make the gene names column
  dplyr::filter(Top <= 100) # most significant 100 for each pairwise comparison

```

Because we tend to like [tidy data](https://r4ds.had.co.nz/tidy-data.html), here we use a `tidyverse` function from the [`purrr` package](https://purrr.tidyverse.org) to apply the same operations as above to every element of the `markers` list. 
We will introduce `purrr` briefly here, but if you want more information and background, we recommend the [`purrr` cheatsheet (PDF)](https://github.com/rstudio/cheatsheets/raw/master/purrr.pdf) and Jenny Bryan's great [`purrr` tutorial](https://jennybc.github.io/purrr-tutorial/index.html) you might want to look at.


The main functions in `purrr` are the `map()` functions, which take as their main arguments a **list** and a **function** to apply to each element of the list. 
The first one, `purrr::map()` is essentially equivalent to the `lapply()` function that is part of base R, but with some different defaults. 
We will use it to get the top rows from each table by applying the `head()` function to each element of the list.
The results are returned as a new list.

```{r head_markers, eval = FALSE}
purrr::map(as.list(markers), # convert markers to a 'regular' list for purrr
           head) # the function to apply (note no parenthesis)
```

This returns a list of data frames, which isn't quite what we want.

There is no built-in function that will give us just the first few row names, so we will have to define one, and `purrr` gives us a nice shorthand for doing that with `~` syntax.
In this syntax we type a `~` followed by an expression (R code) that uses `.x` as a placeholder for a single element of the list.
`purrr::map()` will then apply the expression to each element of the list, and return the results as a new list.

```{r head_markernames, live = TRUE}
# Get the first few row names of each table with a purrr function.
purrr::map(as.list(markers), # convert markers to a 'regular' list for purrr
           ~ rownames(head(.x))) # our custom function.
```

Another variant is `purrr::imap()`, which allows us to use the names of the list elements in our function. 
(Try `names(markers)` to see the names for the list we are working with now.)
We will use that here to name output files where we will print each of the marker tables, one for each cell type.
We are again defining a custom function within the call to `purrr:imap()` using the `~` syntax, but this time we can use `.x` for the list elements and `.y` for their names.

In addition to writing the tables out, we are saving the data frames we created as a new list object that we can use in the next step.

```{r write_tables}
marker_df_list <- purrr::imap(
  as.list(markers), # convert markers to a 'regular' list for purrr
  ~ as.data.frame(.x) %>% # convert the table to a data frame
    tibble::rownames_to_column("gene") %>% # make genes a new column
    readr::write_tsv( # write each data frame to a file
      file.path(marker_dir, paste0(.y, "_markers.tsv")) # construct the output path
    )
  )
```

`purrr::map_df()` is another nice function in `purrr`. 
It applies the operations in the second argument and combines the output into a single data frame.
Optionally, it adds a column with the name specified by the `.id` argument to differentiate the rows that came from each element of the input list.

```{r top_markers}
# Make a data frame of the top markers for each cell type
top_markers <- purrr::map_df(marker_df_list,
                             ~ dplyr::filter(.x, Top <= 100),
                             .id = "cell_type")
```

This list has a lot of redundancy, and we really only care about the gene names for the next step, so we will reduce that column down to just the unique set of gene names with `unique()`.

```{r unique_markers}
unique_markers <- unique(top_markers$gene)
length(unique_markers)
```

Now we will use those unique markers to calculate the PCA using just those genes.

```{r marker_pca}
marker_pca <- calculatePCA(gbm_sce, 
                           subset_row = unique_markers, 
                           ntop = length(unique_markers)) %>% # use all of the markers 
  as.data.frame() %>% # converting to a data frame & adding columns in a pipe, for variety
  tibble::rownames_to_column("geo_accession") %>%
  dplyr::mutate(cell_type = gbm_sce$cell_type)
```

Now we can make a plot of the marker gene PCA!

```{r plot_marker, live = TRUE}
ggplot(marker_pca, aes(x = PC1, y = PC2, color = cell_type)) +
  geom_point() + 
  ggtitle("Marker gene PCA scores") + 
  scale_color_manual(values = unname(palette.colors(palette = "Okabe-Ito")))
```



## Session Info

```{r session}
sessionInfo()
```
