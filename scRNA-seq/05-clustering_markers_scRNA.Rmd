---
title: "Clustering cells and finding marker genes scRNA-seq data"
author: CCDL for ALSF
date: 2021
output:
  html_notebook: 
    toc: true
    toc_float: true
---
## Objectives

This notebook will demonstrate how to:

- Annotate clusters of cells in single-cell data
- Compare different clustering methods
- Identify marker genes that can be used to differentiate clusters

---

## Set Up

### Load libraries
```{r setup}
# Load libraries
library(ggplot2)
library(scater)
library(scran)
# clustering tools
library(bluster)

# Magrittr pipe
library(magrittr)

# Setting the seed for reproducibility
set.seed(12345)
```

```{r filepaths}
# main data directory
data_dir <- file.path("data", "hodgkins")

# normalized data file
normalized_rds <- file.path(data_dir, "normalized", "normalized_hodgkins_sce.rds")

# Output directory for markers
marker_dir <- file.path("analysis", "hodgkins", "markers")
if (!dir.exists(marker_dir)) {
  dir.create(marker_dir, recursive = TRUE)
}
```

```{r read data}
hodgkins_sce <- readr::read_rds(normalized_rds)
```

## Identifying cell clusters

Source of lots of info: https://bioconductor.org/books/release/OSCA/clustering.html

When we performed dimensionality reduction on our single cell data, we could see visually that the cells tended cluster together into groups. 
To the extent that such clustering is a real biological phenomenon, representing cells with similar patterns of gene expression, we might like to identify distinct groups that we can name and assign a label to.
Ultimately, we would hope that these labels correspond to previously identified (or newly identified!) cell types, and that we can use that information to provide more insight into the results of our experiment.

There are a number of methods to identify clusters and assign cells to those in multidimensional data like the single cell data we have.
We will explore a couple of those here.

### k-means clustering

The first method we will try is k-means clustering.

The k-means algorithm in it basic form requires us to pick the number of clusters we want to use

We are going to use the function `clusterRows()` from the  Bioconductor `bluster` package for our clustering. 
This function takes a matrix where each samples (cells in our case) is a row and each column is a feature.
The matrix of counts (or normalized counts) by cells in our `SingleCellExperiment` object is the wrong orientation, so at a minimum we would have to transpose that matrix before proceeding. 

However, clustering algorithms like k-means can be a bit slow with as many features as the number of genes that we have in our data set, so we would rather not use the raw data.
There is also a potential concern that noise in the raw data might disrupt the clustering algorithm, so it would be best to use some kind of dimensionality reduction algorithm first. 
But we still want to maintain a good number of dimensions, so our old friend PCA is a good (and very standard) choice.

Thankfully, we already computed *and stored* a matrix with reduced dimensions with the `runPCA()` function. 
We will extract that from the `SingleCellExperiment` object with the `reducedDim()` function, which conveniently returns a matrix with the cells as rows, so we can use that directly!

We will start with a small number for the clusters.

```{r kmeans_6}
# set the number of clusters:
k <- 6

# extract the principal components matrix
hodgkins_pca <- reducedDim(hodgkins_sce, "PCA")

# perform the clustering
kclusters <- clusterRows(hodgkins_pca, KmeansParam(centers = k))
```

The `clusterRows()` function returned a vector of cluster assignments as integers, but the numerical values have no inherent meaning. 
For plotting we will want to convert those to a factor, so R is not tempted to treat them as a continuous variable.

We can also store them back into the column (cell) information table of the original object for convenient storage and later use.

```{r store_kclusters}
hodgkins_sce$kcluster <- factor(kclusters)
```

Now we can plot the results and see how the clustering looks, using the `scater` function `plotReducedDim()`, but now coloring the points by our clustering results.
We will start by using the UMAP coordinates for the plot.
Note that this does require that the cluster identities were stored in the `SingleCellExperiment` object.


```{r plot_k}
plotReducedDim(hodgkins_sce, "UMAP", colour_by = "kcluster")
```

Do those clusters line up with what you might have expected if you were doing this by eye?
What do the results look like if you plot with the PCA coordinates? 
What happens if we change the number of clusters?

### Graph-based clustering

Another common type of clustering method for single cell data is graph-based clustering. 
This works by identifying a set of nearest neighbors for each cell that have similar expression profiles to that cell, then connecting each cell to those neighbors in a network graph. 
The connections are weighted by how similar each cell is to its neighbors.

We then break the network up by identifying clusters of cells that are more connected to each other than they are to cells outside the clusters. 

To apply this, we will use the same `bluster::clusterRows()` function as before, but we will change the second argument from `KmeansParam()` to `NNGraphParam()` to tell it that we want to use a nearest-neighbor graph-based method. 
We can then supply parameters to `NNGraphParam()` to adjust the details of the algorithm.

Here we will use `k` to specify the number of neighbors to use when building the graph and `cluster.fun` to specify the algorithm for identifying the clusters within the graph.
Despite sharing a letter, `k` here and the one from k means clustering are not the same thing!
In this case, we are telling the algorithm how many neighbor connections to make for each cell, not final number of clusters, which will be determined by the algorithm.


```{r nnclust, live = true}
# run the clustering algorithm
nnclusters <- clusterRows(
  hodgkins_pca, 
  NNGraphParam(k = 10, 
               cluster.fun = "walktrap")
  )
# store cluster results in the SCE object
hodgkins_sce$nncluster <- factor(nnclusters)
```


```{r plot_nnclust}
plotReducedDim(hodgkins_sce, "UMAP", colour_by = "nncluster")
```
How does that compare to the k-means clustering result?


### Parameters matter!

As we did with UMAP, lets take a bit of time to explore the effects of the various parameter choices that we have on the output results.


```{r}
clusterPlot <- function(sce, cluster_param, plot_dim = "UMAP"){
  pc_matrix <- reducedDim(sce, "PCA")
  clusters <- bluster::clusterRows(pc_matrix, cluster_param) %>% factor()
  sce$cluster <- factor(clusters)
  scater::plotReducedDim(sce, plot_dim, colour_by = "cluster")
}
```

```{r}
clusterPlot(hodgkins_sce, NNGraphParam(k = 5, cluster.fun = "louvain"))
```


## Identify marker genes

Assigning clusters is nice for visualization, but we would like to be able to move toward a biological interpretation of the clusters and identifying the cell types in each cluster.
To that end, we can identify marker genes that are differentially expressed among clusters. 

It is worth noting here that the statistical calculations here are more than a bit circular: we identified clusters first based on gene expression, then we are using those same clusters to find differences in gene expression. 
The result is that even if there were no *true* clusters, we would always find marker genes! 
For a much more technical exploration of this circularity (and a method to correct for it), see a preprint by [Gao et al. (2020)](https://arxiv.org/abs/2012.02936).
In light of this, it is better to think about marker gene identification as an aid in interpreting the clustering results (and possibly extending insights to new data sets), rather than results that should be interpreted on their own, and we should be extremely wary of justifying cluster assignments solely based on these results!
With that caveat, let's proceed.

To identify marker genes, we will use the `scran::findMarkers()` function, which will rank genes by their differential expression by calculating pairwise statistics among clusters.
We have a few options for how to determine the gene rankings and marker gene list for each cluster. 
At one end could include genes that are differentially expressed in *any* pairwise comparison against our focal cluster, or at the other we could only include genes that are differentially expressed in *all* comparisons with that cluster. 
We could also do something in between, including genes that differentiate the focal cluster from *some* fraction of the other clusters.
For now, we will use the `findMarkers()` function to rank the genes in each cluster by their combined scores against *all* other clusters. 

`findMarkers()` will return a list (technically a list-like object) of tables, one for each cell type, with statistics for each gene showing how well it differentiates that cell type against other types.


```{r find_markers}
markers <- scran::findMarkers(hodgkins_sce, hodgkins_sce$nncluster, pval.type = "all")
```

Next we can look at one of those tables.
We will start with the first cluster, which we will simply select as the first in the list.
We also doing a bit of transformation here to pull the gene name into a column of its own.

```{r marker_table}
markers[[1]] %>%
  as.data.frame() %>% # convert to a data frame
  tibble::rownames_to_column("gene")
```

Because we tend to like [tidy data](https://r4ds.had.co.nz/tidy-data.html), here we use a `tidyverse` function from the [`purrr` package](https://purrr.tidyverse.org) to apply the same operations as above to every element of the `markers` list. 
We will introduce `purrr` briefly here, but if you want more information and background, we recommend the [`purrr` cheatsheet (PDF)](https://github.com/rstudio/cheatsheets/raw/master/purrr.pdf) and Jenny Bryan's great [`purrr` tutorial](https://jennybc.github.io/purrr-tutorial/index.html) you might want to look at.


The main functions in `purrr` are the `map()` functions, which take as their main arguments a **list** and a **function** to apply to each element of the list. 
The first one, `purrr::map()` is essentially equivalent to the `lapply()` function that is part of base R, but with some different defaults. 
We will use it to get the top rows from each table by applying the `head()` function to each element of the list.
The results are returned as a new list.

```{r head_markers, eval = FALSE}
purrr::map(
  as.list(markers[1:3]), # select the first 3 clusters and convert to a 'regular' list for purrr
  head # the function to apply (note no parenthesis)
  )
```

This returns a list of data frames, which isn't quite what we want.

There is no built-in function that will give us just the first few row names, so we will have to define one, and `purrr` gives us a nice shorthand for doing that with `~` syntax.
In this syntax we type a `~` followed by an expression (R code) that uses `.x` as a placeholder for a single element of the list.
`purrr::map()` will then apply the expression to each element of the list, and return the results as a new list.

```{r head_markernames, live = TRUE}
# Get the first few row names of each table with a purrr function.
purrr::map(as.list(markers), # convert markers to a 'regular' list for purrr
           ~ rownames(head(.x))) # our custom function.
```

Another variant is `purrr::imap()`, which allows us to use the names of the list elements in our function. 
(Try `names(markers)` to see the names for the list we are working with now.)
We will use that here to name output files where we will print each of the marker tables, one for each cell type.
We are again defining a custom function within the call to `purrr:imap()` using the `~` syntax, but this time we can use `.x` for the list elements and `.y` for their names.
Because we don't know the names of the clusters, these are just the cluster numbers for now.

In addition to writing the tables out, we are saving the data frames we created as a new list object that we can use in the next step.

```{r write_tables}
marker_df_list <- purrr::imap(
  as.list(markers), # convert markers to a 'regular' list for purrr
  ~ as.data.frame(.x) %>% # convert the table to a data frame
    tibble::rownames_to_column("gene") %>% # make genes a new column
    readr::write_tsv( # write each data frame to a file
      file.path(marker_dir, # construct the output path
                sprintf("cluster%02d_markers.tsv", .y) # format cluster numbers in file names with leading zeros
                )
      )
  )
```

`purrr::map_df()` is another nice function in `purrr`. 
It applies the operations in the second argument and combines the output into a single data frame.
Optionally, it adds a column with the name specified by the `.id` argument to differentiate the rows that came from each element of the input list.

```{r top_markers}
# Make a data frame of the top markers for each cell type
top_markers <- purrr::map_df(marker_df_list,
                             ~ dplyr::filter(.x, Top <= 10),
                             .id = "cluster")
```

This list has a lot of redundancy, because some genes come up as markers for multiple clusters.

Let's see if we can find a marker that is unique to cluster 1.

```{r unique_markers}
other_markers <- top_markers %>%
  dplyr::filter(cluster != "1") %>%
  dplyr::pull(gene) %>%
  unique()

c1_markers <- top_markers %>%
  dplyr::filter(cluster == "1",
                !(gene %in% other_markers) ) %>%
  dplyr::pull(gene)

```

Now we will use those unique markers to calculate the PCA using just those genes.

```{r marker_pca}
marker_pca <- calculatePCA(hodgkins_sce, 
                           subset_row = unique_markers, 
                           ntop = length(unique_markers)) %>% # use all of the markers 
  as.data.frame() %>% # converting to a data frame & adding columns in a pipe, for variety
  tibble::rownames_to_column("geo_accession") %>%
  dplyr::mutate(cluster = hodgkins_sce$nncluster)
```

Now we can make a plot of the marker gene PCA!

```{r plot_marker, live = TRUE}
ggplot(marker_pca, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(alpha = 0.4) + 
  ggtitle("Marker gene PCA scores") +
  theme_bw()
```
```{r}
plotReducedDim(hodgkins_sce, "UMAP", colour_by = "ENSG00000159958")
```



## Session Info

```{r session}
sessionInfo()
```
