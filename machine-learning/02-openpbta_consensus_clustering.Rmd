---
title: "OpenPBTA: Cluster validation"
output: 
  html_notebook:
    toc: true
    toc_float: true
author: CCDL for ALSF
date: 2020
---

If we want to identify groups or clusters using expression data, we often want to **validate** those groups in some way, such as determining the "correct" number of groups or checking for agreement within clusters.

In this notebook, we'll use the medulloblastoma data from the OpenPBTA project to look at two techniques for cluster validation and look how clusters overlap with sample labels that are available in our metadata.

## Set up

### Libraries

```{r}
# Bit o' data wrangling
library(tidyverse)
# Consensus clustering library
library(ConsensusClusterPlus)
# Library we'll use for silhouette values
library(cluster)
library(ComplexHeatmap)
```

### Directories and files

#### Directories

```{r}
# Directory with the prepared/lightly cleaned OpenPBTA data
data_dir <- file.path("data", "open-pbta", "processed")

# Create a directory to hold our cluster validation results if it doesn't
# exist yet
results_dir <- "results"
if (!dir.exists(results_dir)) {
  dir.create(results_dir, recursive = TRUE)
}
```

#### Input files

```{r}
histologies_file <- file.path(data_dir, "pbta-histologies-stranded-rnaseq.tsv")
rnaseq_file <- file.path(data_dir, "pbta-vst-stranded.tsv")
```

#### Output files

```{r}
cc_results_file <- file.path(results_dir, "consensus_clustering_results.RDS")
```

## Read in and filter data

### Sample metadata

Let's read in the sample metadata and get the sample identifiers for medulloblastoma samples.

```{r}
# Read in metadata TSV
histologies_df <- read_tsv(histologies_file)

# Only pull out sample identifiers (KidsFirst biospecimen identifiers) that
# correspond to medulloblastoma samples
medulloblastoma_samples <- histologies_df %>%
  filter(short_histology == "Medulloblastoma") %>%
  pull(Kids_First_Biospecimen_ID)
```

### RNA-seq data

```{r}
# Read in transformed RNA-seq data
rnaseq_df <- read_tsv(rnaseq_file)

# For our clustering validation analyses, we want a matrix of only 
# medulloblastoma samples where the gene identifiers are rownames rather than
# in the first column
rnaseq_mat <- rnaseq_df %>%
  # This makes sure we retain all of the columns with biospecimen IDs that 
  # correspond to medulloblastoma samples
  select(gene_id, all_of(medulloblastoma_samples)) %>%
  tibble::column_to_rownames("gene_id") %>%
  as.matrix()
```

## Cluster validation

### Consensus clustering

The first method we'll use is called consensus clustering.
Consensus clustering to finds the "consensus" across multiple runs of the algorithm using a resampling procedure.

We'll use the package [`ConsensusClusterPlus`](https://bioconductor.org/packages/release/bioc/html/ConsensusClusterPlus.html) that we loaded up top.

The consensus clustering methodology was first introduced in [Monti et al. _Machine Learning_. 2003.](https://doi.org/10.1023/A:1023949509487)

Consensus clustering is one way to help you determine the number of clusters in your data, but it is not the only methodology available. 
Check out the [Data Novia course _Cluster Validation Essentials_ by Alboukadel Kassambara](https://www.datanovia.com/en/courses/cluster-validation-essentials/) for a deeper dive.

```{r}
cc_results <- ConsensusClusterPlus(rnaseq_mat,
                                   maxK = 15,
                                   # Setting this seed is necessary for the 
                                   # results to be reproducible
                                   seed = 2020,
                                   innerLinkage = "average",
                                   finalLinkage = "average",
                                   distance = "pearson")
```

It seems like there are 3 main stable clusters from the consensus clustering results.
A cluster of a few samples may not be that helpful in reaching our analysis goals.

Let's take a look at the class labels for _k_ = 9.

```{r}
# table() creates a contingency table of counts
table(cc_results[[9]]$consensusClass)
```

(Note: the numbering of the clusters is arbitrary here.)

**Let's consider clusters 1, 3, and 4 for further analysis.**
But first, we'll save the entirety of the consensus clustering results to file.

```{r}
write_rds(cc_results, path = cc_results_file)
```

And now to extract the samples in the clusters of interest.
What we used `table()` on before is actually a named vector.

```{r}
cc_cluster_labels <- cc_results[[9]]$consensusClass
head(cc_cluster_labels)
```

We'll extract the names (biospecimen IDs) for samples in clusters 1, 3, and 4, which contain the majority of samples.

```{r}
sample_index <- which(cc_cluster_labels %in% c(1, 3, 4))
samples_in_clusters <- names(cc_cluster_labels)[sample_index]
```

Check what proportion of total samples are in one of these three clusters.

```{r}
# number of samples that met our logical criterion above divided by total 
# number of samples
length(sample_index) / length(cc_cluster_labels)
```

And now we'll filter the RNA-seq matrix.

```{r}
filtered_rnaseq_mat <- rnaseq_mat[, samples_in_clusters]
dim(filtered_rnaseq_mat)
```

### Silhouette coefficient

The silhouette coefficient or value is a measure of cluster consistency that ranges from -1 to 1.
It is calculated on a per-sample basis -- it measures how similar a sample is to the cluster it's in compared to other clusters ([Wikipedia entry for silhouette](https://en.wikipedia.org/wiki/Silhouette_(clustering))).

We'll use the [`cluster` package](https://cran.r-project.org/web/packages/cluster/index.html) to compute our silhouette values for the clusters we identified using consensus clustering above.

The `silhouette()` function takes the class labels and dissimilarities.
Let's use Pearson correlation as we have been throughout.

```{r}
all.equal(names(cc_cluster_labels[sample_index]), 
          colnames(filtered_rnaseq_mat))
```

```{r}
# Calculate the Pearson correlation between samples (columns of the matrix)
mb_sample_correlation <- cor(filtered_rnaseq_mat,
                             use = "pairwise.complete.obs",
                             method = "pearson")
# Dissimilarity means we need to subtract these values from 1
mb_sample_dist <- as.dist(1 - mb_sample_correlation)
```

Let's calculate the silhouette values and then plot them.

```{r}
silhouette_results <- silhouette(x = cc_cluster_labels[sample_index],
                                 dist = mb_sample_dist)
plot(silhouette_results)
```

### Compare clustering results to external metadata labels

There are multiple medulloblastoma molecular subtypes and this classification largely relies on gene expression data.
A [medulloblastoma subtype classifier](https://github.com/d3b-center/medullo-classifier-package), which is an example of _supervised machine learning_, has been applied to the medulloblastoma samples included in OpenPBTA.
How do the subtype labels from this classifier (in the `molecular_subtype` column of our sample metadata) stack up to the clusters we identified with unsupervised methods?

Let's first make a data frame that holds the subtype labels.
We can use this both to compare our unsupervised clustering results to the subtype labels and to 

```{r}
mb_molecular_subtype_df <- histologies_df %>%
  filter(short_histology == "Medulloblastoma") %>%
  select(Kids_First_Biospecimen_ID, molecular_subtype)
```

```{r}
cc_df <- data.frame(cc_cluster_labels) %>%
  tibble::rownames_to_column("Kids_First_Biospecimen_ID") %>%
  inner_join(mb_molecular_subtype_df)
```

```{r}
table(cc_df$cc_cluster_labels, cc_df$molecular_subtype)
```

Hm... there's some agreement with the subtype labels but it's not perfect. 
Why might that be?
Let's start by looking at the overview figure for the medulloblastoma classifier.

![](https://github.com/d3b-center/medullo-classifier-package/raw/aba25b6acc0f8dab11f46db6955a38ffac3d0140/images/workflow.png)

We used a different measure (VST values vs. FPKM) and used all features. 

## Low-dimensional representation

Let's see if a low-dimensional representation, we'll use UMAP, seems to agree with our other unsupervised results.

```{r}
# Set seed for reproducible UMAP results
set.seed(2020)
# umap() expects features (genes) to be columns
umap_results <- umap::umap(t(rnaseq_mat))
```

The UMAP coordinates are in the `layout` element of the list returned by `umap::umap()`.

```{r}
umap_plot_df <- as.data.frame(umap_results$layout) %>%
  tibble::rownames_to_column("Kids_First_Biospecimen_ID") %>%
  inner_join(mb_molecular_subtype_df)
```

Let's make a scatter plot and color our samples by the subtype labels.

```{r}
umap_plot_df %>%
  ggplot(aes(x = V1, 
             y = V2,
             color = molecular_subtype)) +
  geom_point() +
  scale_color_manual(values = colorblindr::palette_OkabeIto) +
  theme_bw() +
  xlab("UMAP1") +
  ylab("UMAP2")
```

## Session Info

```{r}
sessionInfo()
```


